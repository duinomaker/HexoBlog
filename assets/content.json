{"pages":[{"title":"404","text":"哎呀，页面不见了！ 博客维护记录：/maintenance/","link":"/404.html"},{"title":"Concrete Mathematics Notes","text":"PrefaceThese are my notes on Concrete Mathematics. Exercises in this book, compared to their SICP counterparts, are really more challenging. I’m running out of my brain power (together with draft paper) while solving them. To advance my proficiency in written English, I’ll be taking notes in English since April 25, 2020. Although previous works are done in Chinese, I feel no need to translate them, since it would be time-consuming and would have little to do with my comprehension of the book. NotesChapter I&nbsp;&nbsp;&nbsp;Recurrent ProblemsChapter II&nbsp;&nbsp;Sums ExercisesChapter I&nbsp;&nbsp;&nbsp;Recurrent ProblemsChapter II&nbsp;&nbsp;SumsChapter III&nbsp;Integer Functions","link":"/CM/"},{"title":"Logical Foundations Notes","text":"PrefaceBuilding reliable software is hard. The developing of large-scale systems are prone to bugs and insecurities. Computer scientists have responded these challenges for improving reliability, using mathematical techniques for specifying and reasoning about properties of software and tools for helping validating these properties. The Software Foundations series is focused on this last set of tools. This course is based around Coq, which enables a variety of works: As a platform for modeling programming languages. As an environment for developing formally certified software and hardware. As a realistic environment for functional programming with dependent types. As a proof assistant for higher-order logic. The most basic programming style is to keep the computations pure as much as possible, avoiding side effects such as changes of local states; this makes the programs easier to understand and reason about. Coq is a proof assistant yet a functional programming language. These two sides of Coq are the reflection of the underlying machinery, that is, proofs are programs. NotesChapter 1&nbsp;Functional Programming in CoqChapter 2&nbsp;Proof by InductionChapter 3&nbsp;Working with Structured DataChapter 4&nbsp;Polymorphism and Higher-Order FunctionsChapter 5&nbsp;More Basic TacticsChapter 6&nbsp;Logic in CoqChapter 7&nbsp;Inductively Defined PropositionsChapter 8&nbsp;Total and Partial Maps","link":"/SF-LF/"},{"title":"SICP Notes","text":"PrefaceThese are my notes on Structure and Interpretation of Computer Programs. To advance my proficiency in written English, I’ll be taking notes in English since April 25, 2020. Although previous works are done in Chinese, I feel no need to translate them, since it would be time-consuming and would have little to do with my comprehension of the book. NotesChapter I&nbsp;&nbsp;&nbsp;Building Abstractions with ProceduresChapter II&nbsp;&nbsp;Building Abstractions with DataChapter III&nbsp;Modularity, Objects, and State Exercises1.1&nbsp;The Elements of Programming1.2&nbsp;Procedures and the Processes They Generate1.3&nbsp;Formulating Abstractions with Higher-Order Procedures 2.1&nbsp;Introduction to Data Abstraction2.2&nbsp;Hierarchical Data and the Closure Property2.3&nbsp;Symbolic Data2.4&nbsp;Multiple Representations for Abstract Data 3.1&nbsp;Assignment and Local State3.2&nbsp;The Environment Model of Evaluation3.3&nbsp;Modeling with Mutable Data","link":"/SICP/"},{"title":"关于我","text":"我是 duinomaker，就读于南京邮电大学计算机学院，大二学生。 当前，我正在读《Software Foundations》系列以及《Structure and Interpretation of Computer Programs》的第四、五章；阅读的同时我将自己的笔记发布到此博客。 我使用了 Toggl Track 平台来记录自己的各类学习时长，并辅之以几个脚本，用来将过去一周内的记录显示在本页面，每到整点更新一次。 正在加载... &nbsp;E-Mail: duinomaker@gmail.com","link":"/about/"},{"title":"Hello, intrepid explorer","text":"There’re at least three possible explanations for your clicking on my avatar. If you wanted to inspect my avatar, here’s a high resolution one. If you want to read my profile, go to the “About” page. Otherwise you may have noticed something in your address bar that is irrelevant. Apparently, my diary is hidden somewhere in this website. You may find the place by inspecting the corresponding GitHub repository.","link":"/diaries/"},{"title":"博客维护记录","text":"2021-05-12 开设 /SF-LF/ 用于记录 Logical Foundations 阅读笔记 2021-01-18 在 /about/ 页面中增加七天总结模块2021-01-02 更改中文博文的标题字体为微软雅黑 2020-10-18 更改 KaTeX 公式的 white-space 策略，使公式自行换行 2020-08-16 加深部分文字颜色，提高文章内容可读性2020-08-16 更新 Hexo 至 ^5.0.0 版本 2020-07-01 改进字数统计功能，使其能统计到各笔记页面的字数 2020-06-24 取消 RSS 订阅功能2020-06-23 移除网站备案信息2020-06-23 博客迁移至 Github Pages，页面资源使用 jsDelivr 提供 2020-05-15 增加页面内容的水平占比，调整卡片间的垂直距离2020-05-10 优化 MathJax 在移动设备上的显示效果 2020-04-17 移除主页卡片中的 “Read More” 按钮2020-04-14 开设 /notes/ 作为笔记的索引页2020-04-14 开设 /CM/ 用于记录 Concrete Mathematics 阅读笔记2020-04-08 将 MathJax 更新至 3.x 版本2020-04-06 开设 /SICP/ 用于记录 SICP 阅读笔记2020-04-05 博客迁移至云主机2020-04-03 修改文章底部 hashtags 的样式，禁止其内容自动换行2020-04-03 修改内联代码字体颜色为 currentColor，大小为 0.875em 2020-03-28 禁用 Google Analytics 插件2020-03-26 添加网站备案信息2020-03-15 修复数学公式水平长度溢出问题，自动增加水平滚动条2020-03-10 增加 /about/ 页面的 Friends 区块2020-03-10 取消 /diaires/ 中各页面和 404 页面的评论功能2020-03-10 统一文章顶部分类与各子分类之间分割符颜色为灰色2020-03-05 增加 Valine 评论系统2020-03-02 缩小桌面版字体大小 2020-02-22 禁止 Safari 浏览器自动检测页面中电话号码2020-02-21 开设 /diaries/ 用于记录日记2020-02-20 禁止内置搜索引擎搜索 pages2020-02-20 调整导航栏 logo 垂直位置，使之在各平台都可以居中2020-02-20 禁用页面动画效果2020-02-17 更新 profile 中的头像2020-02-12 增加 gulp 插件压缩 html 文件2020-02-12 增加 sitemaps、auto nofollow 插件和 robots.txt2020-02-10 博客诞生","link":"/maintenance/"},{"title":"Notes","text":"Structure and Interpretationof Computer Programs Logical Foundations Concrete Mathematics","link":"/notes/"},{"title":"Repositories","text":"随手写的一些实用工具。 2020-06-16 /repos/mega-helper/2020-04-03 /repos/white-space-converter/","link":"/repos/"},{"title":"Initial Commit","text":"Having configured this editor with my favorite font and style, and set up a lock over all the documents, I’ll start to write diaries on this Mac with Ulysses. Notice that previous diaries, four sheets in total I remember, are not included here. These sheets were filled with anxiety about my poor academic performance or self-punishment for my idleness in school. But now I realize that these aren’t what diaries were intended for; diaries should provide a person with a chance to write down his thoughts, not his complaints.","link":"/diaries/2020-11-03/"},{"title":"The Reason I Regard a Smile as an Emblem of Evil","text":"decrypt a4 98 a1 c2 8b 63 19 29 73 02 57 f1 a6 33 85 69 10 31 bc d3 2c 52 55 5f 69 57 c0 29 64 ba c6 aa 7e dc 05 68 3d a1 17 6f 9a 47 ff f5 d1 c8 fd 27 c3 30 4c 1d 5b 8b 46 22 f9 76 ae 94 61 bd c2 e7 02 5b 46 2e a6 ac 87 71 e5 f2 99 9f 0e 72 38 d4 73 17 f9 10 c4 a7 ca 83 82 b0 ac 4c c0 76 f3 ad ae 60 59 cf 01 b5 ae 55 ab a3 fa a7 91 44 b9 b7 f7 17 08 87 fd 01 c1 ba fc 4f ce 4d e3 bd 82 a9 e0 81 b3 33 da f9 ef 3e 5b 84 19 b1 20 e4 88 30 46 de ed d4 40 3b 9c e3 51 f3 5b 20 66 ef 01 31 d9 ed 2e 30 e9 d9 fa 36 25 32 82 b0 8d d5 ac 3a 4f a0 8b 5d 6c 0c c0 5c ca 9c a3 73 5e 6b 11 49 23 0f 84 e5 62 4c 9c f4 48 db 07 12 2e fc e1 07 87 74 d7 c0 d0 2f d3 6c df ee a4 c7 83 e3 c1 0b 2d 6c b7 e1 03 b3 b6 72 ba 75 99 df 72 6b f3 bf e0 1c c2 59 ba 85 f9 57 47 68 5c cc 9f dd 83 32 d6 f9 44 16 97 27 62 20 4e 58 c2 14 e5 61 78 f2 09 a9 31 fb c5 d4 b5 9d 60 a3 16 9a e3 e8 95 08 db 7e 21 ce 90 bb 46 79 dd bf 8b c1 be fc a0 cf 88 f7 c6 56 bd f6 83 f8 05 66 cc 0d ae 80 7f fb e2 ed 4f 29 ed fd f6 05 4e 96 c4 2e f2 2f c8 27 68 40 9b 64 ba e3 cb 44 24 17 2b ec 72 58 4d 75 aa f4 33 bc 47 50 ec df fe 5a 6c cd c9 79 42 ec 89 2e b5 5a 8e 3e 8c 6a 97 fe 76 f1 35 2b 91 78 dc e8 e3 5c 99 ca 59 a8 a8 d4 06 04 2c c3 da 02 58 94 6e 19 d0 4c 0d 53 db da 1e 07 dd 2f 54 dd a0 de 39 1a 27 40 e7 f8 19 5e e8 6e 01 16 74 88 26 e7 a3 c0 e4 70 27 92 84 f2 87 9d 99 78 5b 7f 5c 76 29 81 2e 36 06 fc 55 82 d5 5b 19 55 b1 26 26 44 14 7f d2 9e bd 93 e3 da 66 4f 65 c2 c7 32 53 5b 79 eb 04 d7 15 7c bf 1f f4 8a 62 ab e3 04 52 df fb 3d c8 6b 3e b7 13 0f 19 37 1f fd 47 52 15 d4 30 40 e0 f1 b1 51 cf 57 1a 44 6c 8a 9d d8 c0 11 4c b5 e2 dd 1f 15 e3 a6 1e eb b9 ce 86 d7 59 bb a7 82 9a 44 d5 3d 9a 53 7e aa 6d a1 b5 20 7d f8 f2 7a 90 75 3a 27 68 ba 39 1f 28 ff d3 1f e6 db 1f 8c ac 25 40 74 f9 e8 70 5c 5d 81 4b 3b 0f f6 75 e4 9f 96 79 14 9f 08 5b 59 d2 98 3a 3b b2 61 ae a5 05 f8 85 d9 f8 45 18 7f 40 35 c7 44 a9 56 27 2c 09 71 d6 01 e3 e8 25 a5 07 25 40 af 3a ef b1 e6 53 58 5a 16 6b ef a1 35 ff 53 57 df 17 19 3a 0c 15 c1 2b 5d 80 75 33 0a ed 15 2d 9a 29 66 cc af 86 2d 16 ca 53 f4 96 07 b0 98 6e 8f 73 32 52 58 c9 c5 ab be a4 e8 95 91 fd 7f 35 a1 a5 74 24 a3 d2 09 76 85 a9 34 64 58 3e f6 24 2d 46 56 ac d0 9b f6 75 ed 65 03 bf 78 b6 d2 8f 88 95 6a 32 41 74 a3 31 95 06 cc e4 1e d2 0a c1 b2 58 84 f2 5b 6e 14 6e ae 52 f6 0c 90 77 76 2a dd 7b 6d 50 cd 20 96 9b 15 45 2b 25 a6 5b 05 37 c9 d1 2b 7f 52 df 7b ce ba ea 07 e4 95 ed db d9 f8 70 33 8c 4c 7c 44 ff b2 97 c5 cf 3a 51 dd 35 51 9d 8d 18 0a 38 03 b4 a3 09 8a 40 11 a9 19 34 33 bc bf c6 39 bd 88 87 18 b5 29 a3 61 1f d2 26 74 62 97 10 83 5b ab e4 ce 75 1b 55 80 c0 42 89 f0 79 c1 4d 22 8f cb 9e 01 ac 3f 20 76 0a cf 33 12 8c d8 4a 38 f4 c8 26 43 21 e3 9b 55 cd 01 6a d2 e6 b2 25 eb 91 c4 d2 b6 f3 75 24 0f 32 eb 7b fb 7f 30 2e ef ae 9e 88 88 f4 8f d0 15 b1 d5 e0 64 0c f9 8c 1f 53 18 f6 8b 11 dc 98 16 06 24 09 53 11 cc ce c9 3b 58 17 87 07 b2 6e 09 ed ee 18 55","link":"/diaries/2020-11-07/"},{"title":"Domestic Life is Harmful","text":"Before beginning, how to express “harmful?” I mean, different word expresses shallower or deeper degree of harmfulness, for example pernicious, that implies irreparable harm done through evil or insidious corrupting or undermining; baneful (archaic), that implies injury through poisoning or destroying; noxious, that applies to what is both offensive or injurious to the health of a body or mind; deleterious (formal), that applies to what has an often unsuspected harmful effect; detrimental, that implies obvious harmfulness to something specified. decrypt 82 97 89 b9 8a ef 3f 16 ae ba 9f d4 44 e5 22 24 a0 c9 d3 fa 4b 74 38 49 5f ed e7 48 1f fc 0f 8e 4a 92 57 15 11 32 22 95 e3 7d 41 4b 11 ed ee 85 36 41 6e 80 69 61 d1 48 e8 de e8 47 a3 c9 fb 66 48 75 98 b1 6d dc ac c2 f3 8d 97 21 2c 7a fa a4 cf c1 5c 82 fc 12 8c 1e e9 12 60 e2 65 69 eb da 4f 3b e8 ee 89 c3 96 7c c8 3f 47 cf 4c 6e 70 6e 0f 90 b6 06 c0 e7 c3 03 2d d9 5a 11 dc bd 09 be 06 a3 47 55 f3 55 fa 95 a7 c6 93 0a 1f 1c 7a da f4 69 bc 48 ec be 33 a1 5f 26 60 4a 23 68 8f e8 7a 60 f9 85 f7 50 c8 4e 8b 9b ef d1 83 0d e7 24 e8 7d 7d c1 04 2a 11 87 75 b3 dd 8b af 8b ed 2c e3 16 b2 23 22 f1 8d 9c 87 db c3 10 87 87 e8 8e 53 e7 71 7f a4 e9 fd b0 d4 88 b4 98 96 8b d6 93 65 8b eb 10 67 2d 0d e6 e2 73 14 54 43 f9 f6 c4 e1 a3 a1 b6 25 cd 8d fd de 63 94 b1 0e 1a 49 ae 4c 18 27 84 1e e9 c2 6e 8f a4 f8 b5 ba 25 8f 0c aa f3 5b 5e 4e 3d 22 5d aa e2 44 21 d2 05 f6 26 0c 1e 70 ff 3d 81 1b 52 81 4d ab e2 21 da dc 29 40 06 32 8c 63 b6 b1 3b 46 ba de 3d 39 40 c4 46 3f f8 d5 70 a1 38 f1 f0 79 99 7a f1 aa 72 2a ef ce 95 47 74 24 95 3a f4 52 8f 88 4f f7 ff a6 bd 6c f7 bf e4 ca 09 1c 4b 8d b8 9c 5a 8e c4 b7 63 67 2c b7 50 82 ee b2 ff a9 5c 56 20 d1 b8 94 1c 0e d5 9d e4 d0 ae 1d 7a e0 0e 9c 98 4c b8 4f 3e b5 00 9c 31 04 08 a7 28 40 91 14 2f 60 de 3e 5c 11 38 03 d0 3f a6 3c 93 d3 96 f5 b5 81 d4 3e 71 b4 58 0c 34 a7 d5 0f ec bd df ef ba a9 65 b9 70 6d 0f 63 cc 79 7b 2d 43 12 3c 7c e5 76 67 c5 35 77 b4 50 5d 35 3d 6b ca 7b 65 6b 2e 17 97 47 e1 11 f0 8d 8c a5 34 c4 ae fd 1e 21 94 fd 9a 2b 2d db a6 bc 52 09 bc 52 0d fc c2 88 d8 ea f8 f3 c7 2d ca e4 3a 15 1d 66 08 08 15 ca d3 8e ac df 26 de 07 61 4e 77 0c d2 14 2a e7 80 16 e5 29 7f fc ba fa aa 06 ee 8f d6 5b 74 aa 64 3a a8 b3 3a 10 e7 09 6e a1 96 f6 fe 50 f4 9a 51 09 a1 5d 4a 00 3e 45 2c 11 84 1a 2a 06 77 7f 98 9c e8 3e f0 f6 93 73 ae 12 24 88 15 e6 97 06 c0 be fb a3 4a 07 2b 06 2b e5 80 e0 7b 96 4a 25 63 dc d8 ba 40 a8 6e 10 4d 64 83 22 02 25 7f e0 7f 33 1c df f8 93 d4 e1 35 e8 3b 6f 7c 87 2e c4 9e d4 a7 7b 36 9c 2a 76 a3 28 c1 f5 e6 2d 69 40 3d c5 94 99 a5 d9 3f dc 65 86 b5 4c 37 7d 39 35 82 31 d6 68 c1 7d e2 37 e1 e7 f7 ce ce 68 ee 1f 6e 23 83 74 71 3a 90 78 fa 14 2c 37 3f 12 66 da 51 e9 f2 54 c7 67 7c 92 e7 a4 dc 54 fd 85 2c 3b ce 0e 5c 33 f3 c8 ee e7 3b 83 55 7e 3f 77 fd 02 43 dd 1e 2e 30 1f 84 74 79 b6 6d 87 f3 8b a6 f5 e4 c7 3e 8c 88 e5 86 d1 35 38 3b 4c c7 ed 86 57 75 45 fc 32 22 41 ad 35 d2 75 5b 3b 38 35 a9 4b 41 ba 96 a5 41 ee 74 02 35 ca 8c 83 70 b7 8b 56 99 61 2c 06 0a d2 4e df 01 83 2b 6d d7 64 74 4c 32 a4 d3 d0 4b 39 0c be dd 8b 00 c3 73 e0 4d bd e5 da e6 24 c0 94 0a c3 d9 59 61 5f c0 b7 77 39 81 6b c6 93 ef 6a 5d 88 91 b1 62 75 4c bd dd 67 73 57 03 b2 eb f8 08 e6 cf 3d 99 6b fe 84 31 76 55 f0 e8 02 70 d5 35 a2 95 e5 76 67 69 14 0a dd 04 b6 b8 b1 ef 57 52 f2 f2 cb 4a 62 c8 ac 26 cd d9 9e c4 06 ad c8 b5 5a 1c 14 38 2f 47 31 16 60 5d 6c b5 95 4d 5f 97 80 78 aa f6 82 d2 9c 92 44 3a b8 57 b3 a8 e2 0c 02 46 aa 1f 48 2e fc 95 2a 95 0f a8 7e 38 ae 90 5b 9f de 88 03 a1 d7 b3 ea d9 41 84 34 39 3b 1d a3 44 9a 21 64 85 1e f5 f0 04 de 5a 4b 5a 42 d1 05 ad 60 59 c2 d3 c5 cd ff 36 80 53 7a a6 32 30 70 fb 0c 9f b2 ef 90 75 13 98 99 a8 c6 93 58 24 f1 78 ca 12 f0 c8 12 0f 7b 17 d5 4e d6 41 41 46 89 06 c8 01 c3 02 98 8b cc 58 f7 25 1d eb f4 98 67 af f4 20 29 8b 57 6a 62 61 14 71 9b 0b f3 2d f1 b1 5f ed 5e 36 23 9d 1e 03 4c 88 e0 cc 19 c5 8d 4d a5 de 85 d9 10 70 74 7f dd af 3e 77 af 1e b4 57 3a 04 3f 7b 1b 66 9f 85 24 e1 d5 58 d5 72 64 c2 61 4d 14 65 b0 cc ae be ed 32 47 e5 72 45 c3 b1 cb c8 cf 7d 85 d7 4c f5 ac 7f 65 68 ed 7e 5e e9 ec d4 1e 9c 88 63 86 b3 f5 21 1e 80 40 86 63 fb 5e e2 82 b1 a0 44 1b f3 17 0c 22 42 79 43 94 b4 b2 25 9d 2e 98 9e 73 e0 10 19 1a 27 67 cf dd 97 e1 13 47 1a ec 55 65 dc 6b ff 36 e6 db 83 a8 d3 f5 ca dd 51 46 44 29 65 70 55 9d da 00 04 8e aa 66 f1 ad c5 0e 06 9c 39 a8 c9 6b 6e 3f f3 02 f7 47 dc e2 27 a8 b3 bd ab 51 99 bf 1e d7 87 7f 0b 2e 01 e3 b6 cd a5 dd 53 e9 7b 93 09 5b 9a c3 73 98 85 86 c7 a4 6b eb ce 75 6d 2b a9 28 84 e7 21 da f3 d6 e0 da a1 32 63 ad 61 b3 d5 56 72 78 3c 62 df 25 a4 80 ce 7f 82 99 77 a3 87 46 1f f9 dd 47 59 9e d5 67 3e 8a 2d e5 5d 03 8c ce 46 82 4e 25 69 1b 7d 6d 6a 52 22 0e 9c 46 1a 02 eb 70 8a 84 03 67 0b d6 1f fd 04 36 92 70 98 6f be 34 cb 95 6c 43 5e 59 d1 9d 3b ea 24 c0 68 00 ab e1 d2 16 20 54 d0 70 e3 fd a1 2a 2f b0 bb dd 10 e8 f8 2a f0 bc 98 7d 3e 0a 0e 75 f2 ef 7e c4 69 78 fd 08 78 36 67 b1 a9 f1 56 56 e0 0a 79 85 84 5b a5 e4 2d 77 3e af 9d c1 8f b5 aa 22 9f 8a 58 cf d6 71 29 11 d1 ed 1e 15 53 83 57 70 44 4a 3f 90 aa 11 7b cf 97 44 84 35 84 60 64 c4 d8 32 a4 85 f7 22 6d 0a 10 bc 7f 37 e2 cd c9 d9 7e 8a 0e 24 7a 02 4d 3a b3 5f df c8 4b 91 ed 02 9e ce 87 ac ff ec 2d 3e 68 f9 2d c6 94 cf af 31 c6 d7 26 45 89 9c 62 4c 49 ce 12 de 62 6c 49 33 a6 97 11 93 38 10 dd 3b 50 ee 7f 20 6c 6a 86 73 b4 4a 84 06 2b 98 ee 5f df db 02 5c 12 0c 15 9d cd ae 0b 10 1e 60 17 03 67 c1 88 4b 43 a9 7c d5 94 f2 47 51 81 11 fe 8a 22 67 c4 3a c8 a7 81 ab db 95 02 c6 b5 67 03 68 6c f3 ac 96 db 8e bf bd 37 3e fd 6d 34 6c 45 05 07 f8 e5 69 db 47 76 48 e0 cf 04 5e d9 c6 4a cd 6f fb 28 4e 54 94 7b 68 ae 29 65 22 51 83 9c b1 54 1c 92 e7 4a ed 6f a6 81 f0 01 ae 63 cc 67 07 fc 44 2f 0a 91 2d 04 76 ae e2 a1 36 ba 5f 5c a1 0b f3 33 7b a2 5c 17 e7 5b 40 4a 8e 87 40 9f d1 b8 8b 3b f8 fd 20 c4 49 b3 7b f4 dc 4a 65 96 e1 78 6f 33 5f c0 c9 97 47 7a 5b 4e a5 37 19 76 7a 2f 5e 77 19 33 2e 7e 83 59 f4 14 aa 7a 7d f0 38 60 33 39 8c 0c d0 d6 30 f9 03 6f 2c df 50 61 d3 e5 de 89 6d 89 e3 89 24 06 bd c9 0b 8b ed 77 96 cd 35 ee 31 0d af 1b 0f c6 67 ee 3d 7d 0d fc 0a 41 52 40 ce 6a 00 12 59 37 34 5b 55 08 df b1 e1 cc c5 f4 7f ec 0c 30 91 aa 5d b3 49 8d f9 72 95 80 ae f1 03 d6 0e d7 4a e6 58 74 ce 47 f9 64 b3 19 a7 75 e8 3c 3c 7d 7d 3f 41 67 31 2a 3e f9 d1 e0 9e c1 e5 a9 1c 7e 0a f1 6d f0 7b 3d fb ea fa f3 92 79 0b f6 3c df 95 f4 a7 a6 3d 34 f3 c6 29 31 59 cf f2 69 81 1d 24 b1 dd 76 43 a4 6d c3 7e f3 d5 bd 22 8d 31 37 7c cf 48 ac f5 38 3b 65 20 e1 ab 84 49 0d ee 80 46 c5 3d 70 0d 61 1a b9 22 0b 6a e4 28 4e f7 04 54 c4 ab 52 2b 81 bf 16 c8 fd 07 ea a1 f0 e6 f8 f9 a3 bd c5 a6 18 af 53 cd 6d 57 11 6c 01 79 1f b9 10 92 8f 83 04 10 12 ed 68 aa 73 78 48 ef 43 60 a8 ac 67 11 e0 a4 5d 01 02 d9 b3 bb cd 9f 23 c7 24 78 45 35 2e ba 03 cf 9b be da a1 aa 77 a0 1c 82 cd 97 a0 5d e7 50 72 6d c8 a3 d9 c1 51 84 e7 ad e6 61 30 3a 4b 06 5f d2 5d cb f5 bd 38 f6 b4 b9 b7 ae 64 b8 b3 83 08 15 ad ec 63 94 71 14 25 ab 1a 50 58 37 11 8f b0 58 14 7a 71 8a d0 ed 80 c6 ae 51 21 ed 3d ca fc 14 2d 6c 5f 99 6e dc 77 b9 87 35 1a 58 4b 1e d8 a3 e5 89 9a 4c c7 76 5c ae 94 3f 12 69 a6 91 45 3e 11 94 74 6e 51 d8 5d 12 5f db af bc bf 1e a3 93 a0 26 78 4e a1 12 1c 90 85 4b 59 3b 9a 28 69 51 b3 9b 0c 6a 00 5e 61 ef 68 30 af cc 36 52 90 29 e7 39 7a 50 5d ac 6b 4b ea c4 dc 3c 06 e0 94 89 a8 ad 17 da 0d 90 8c 96 99 c3 a2 60 17 24 2d e4 d8 a0 cd 5a 15 f6 7b 41 f8 22 9e ac 96 a0 a4 ab 0f fd a0 3c 77 a3 30 13 c8 9c ee 91 8c 38 33 69 71 fa 27 29 55 6f 6f c0 91 e6 46 d3 78 93 9f ae 7b b1 3e 51 8e f2 a4 31 d8 80 06 1c 78 30 71 7d 22 bc 7f 1e 55 a6 49 d3 7c 50 40 ea 72 bd 74 82 32 38 f1 6d a7 1e fe 64 10 99 f8 ec d9 87 ea 76 6b c5 2d 18 66 37 7e a8 de 42 6d 07 37 39 19 e0 41 68 1f a0 5f a3 62 f4 ac f5 0e 6d 99 0b e3 1b b6 c0 30 35 ad c3 63 b2 16 0e c7 18 3b 10 47 fa fe a7 d6 77 12 90 18 14 9e 93 be ed 3a 6a c4 a2 df 3c 67 75 07 bd ef f8 74 5f bd f9 91 f0 be 08 57 71 0f 33 73 5a f9 f7 70","link":"/diaries/2020-11-08/"},{"title":"近期小结","text":"近期发生的要事不少，个人性情正在剧烈变化。为了能够自然地、完整地记录下自己的想法，我选择了自己的母语——中文作为本篇日记的写作语言。 decrypt 欣慰aa 85 3c 4c e8 5a 57 39 b4 36 1b 78 93 f2 f0 76 1d 57 45 cc e9 97 61 1a ce 1e c0 b6 14 8a 9f 6f 15 21 3d 1a c9 86 3e f6 49 6f 06 a8 e5 a4 54 4e 88 00 d0 de 52 93 b8 8d 2e af f1 93 a6 c8 c4 78 bc 48 bc 0e 0d c8 7c de 29 38 8e 4c 74 0f 7b 78 07 72 8b 2f bb ef 33 1d 11 fb d5 3b 1c 25 a6 53 44 67 20 3a 8d 28 bb b1 7f cd f2 7d 7a 9f 35 88 6d 87 36 76 75 21 8d 6a 71 83 78 33 27 82 2e f1 c0 ad eb ca c1 aa 60 58 c4 16 11 64 ee 0e 5d 23 76 68 71 85 f1 da 8b 19 51 b0 8b 5a 5c 29 18 37 05 1c 3b 09 bb 82 12 3f 5a ea c2 0f 12 9a ac 51 64 d9 b0 90 db 3c b2 0d ee c8 b9 d8 38 5d 0f ef 29 a4 05 81 82 a6 39 36 18 5a 90 c6 6d ca 2f 1d e3 9d 69 e2 ee f9 94 13 18 18 71 06 54 fb 3d fd b3 5d dd bf 14 b7 ab ed 41 00 e0 b0 e1 c4 59 8c cb 17 90 75 a4 e1 4e b6 12 f1 80 82 4c 23 24 0a 66 b8 75 d6 7d 20 0e bd 26 ba 5b 2e bc 0f b9 03 33 70 74 1c a2 ea 5f e3 f5 2f df c3 50 3b 29 4f 25 d2 67 a7 88 0d 55 95 a4 bf 9e 5f b1 87 ad 79 35 13 13 68 ec 19 ac a6 10 84 7a e2 d0 9b 76 34 a5 8d 65 84 2c 20 12 2c c2 45 92 ae f6 7d f5 28 23 68 20 72 ce 65 c2 c8 01 09 ff fd d1 ad a3 aa f1 ae 25 4a 33 61 24 b7 30 49 6f 9e b8 f5 9f ef 1b e4 e2 be aa 0a 63 c5 2d c2 a4 f9 61 03 22 52 41 8b e8 cc 38 71 51 57 52 19 25 48 f5 9e c5 1e bd 0a 3e 20 4d 2e 61 23 8c 46 4e 7b 7c a9 e0 42 c0 5f 3a a7 82 ed e4 df 18 02 58 c8 f1 c0 4e 4c 47 18 08 9e 64 62 d7 9f f6 41 10 4d 76 2a 5c b3 5b cc f8 1e 67 6b cc e7 ea 0d 3c 07 f6 5f d0 71 11 b4 f8 b2 f1 35 a4 b4 d8 86 89 b0 0c 4b d2 32 a3 53 e6 69 e6 e4 cf 43 a6 ae a7 df 13 4b f1 31 01 ab 51 f4 66 c1 9b df 2e 91 47 fb 42 1b 4d e7 77 da 5e b2 3c 46 8a 6b 30 57 57 3a 18 68 2d b1 3e be 0d d8 24 85 90 09 45 e6 76 95 86 a0 11 b4 17 b3 5a 2e c4 53 66 3a 0a 4c df 2a 89 f7 d5 f4 98 fc 3c fc 55 e6 46 a2 e9 ff a2 3c 50 db 9a b1 a3 c2 25 18 bd a6 72 ba 69 6c d1 0e 65 6b 97 a8 38 20 d7 6e c4 c8 83 a0 be 35 31 f3 53 7c 8a 33 0a 9a f1 9b bb 48 08 2d 47 38 44 f5 98 33 01 da 58 01 69 0e dd dd 8d d2 4a 24 33 d7 5e 4f 50 67 74 01 90 26 2f e5 e9 cc 5b 39 ba 2e f7 f7 c6 7c 99 83 3d bc 51 f0 80 22 80 7e 02 b5 bc b8 fd 09 16 3b 39 e7 9a c7 b4 35 64 95 83 4c c4 24 be ec 05 f8 9c 24 40 d6 ff 39 cc 76 22 49 8e 49 f6 3f 焦虑1f e5 ee 43 ea 78 27 54 78 d9 31 36 20 d9 c0 77 dc be 24 20 28 e1 b0 d4 b4 e7 7c 01 1e ce c8 82 58 aa f8 9a 03 53 15 bd 03 0b 5b df 5d ca 49 a6 c2 29 69 e9 c1 01 85 e5 6e 5b ca 8d e9 1d 7d f6 4e 13 0e 21 31 88 f3 f6 8e 56 3f a6 60 be ce a9 ff 64 f4 c8 80 fa 24 f2 21 cb 2c 6b 4d 0c c0 e1 3b 3c 81 c5 36 a0 8a 90 0b e1 f3 42 de 7e 15 bc de 01 a7 7c b6 da 50 1c 88 0d 46 0a bd b3 06 6c 56 72 77 35 e1 23 6f ca 32 b2 42 cd 1f ac 92 5c 5e ab a1 36 8c a8 ac ed b6 61 a0 15 b4 a9 cf fe d9 34 62 b6 5b 0a 7e 82 8b e9 f6 45 49 63 79 35 6c 9c 51 cc 52 f4 20 5c fc 07 9d 4d e2 bb 26 6d 忧郁a1 f5 c1 95 05 4b de dd 67 20 61 78 83 54 a1 76 7a 14 a1 0d 9e 99 34 02 ee c5 71 02 37 92 49 f0 3b da 60 8a 62 74 ba 07 af e1 ce d5 8f d5 35 a6 76 a4 d4 f2 3b ba 0b 6b 22 b4 78 d4 52 b3 2d fa 15 a6 b5 87 4b 8d 31 82 23 11 30 ce fd 4f 4d 93 07 79 e0 8b 1b 47 f8 c1 ef b5 e2 bb 71 db b4 a1 24 75 89 34 4e cd 57 59 58 5f eb 24 a0 03 cc 64 8f cd f4 1d 6a 70 93 e2 74 c6 1a e8 05 66 69 e1 2a 99 4a 43 fe 8e 1e 18 e2 9e fd 53 0d 01 c7 d1 e9 4c b2 f3 91 4c db 9b 0c a8 6e 29 b2 de 3e 39 c1 e7 7c 93 84 0b a7 76 82 5c 21 15 02 f0 16 60 29 20 78 3f d1 6a 63 3e 51 ea 04 b5 54 d2 19 bb af 76 ff 8f 12 61 e8 16 2e c6 c5 57 10 3a a4 61 7b d6 52 a7 a4 96 6f 81 39 cb b8 32 14 8c ea ff a2 e3 9f 5a 64 62 dc f1 13 4d b7 80 ba 1a ca 72 96 c8 be f4 e6 35 ad 0e ba 72 91 f6 21 30 02 4a 3d 55 16 d4 d7 2b cb 64 f1 ff be d4 70 bc b9 97 b5 89 cd b9 b1 fc ae e7 f5 8f f5 67 d5 30 0e 73 8e cf 33 99 79 14 2d 8b 7a a9 f4 a8 7f 8c 8a 2e b4 c7 4f a2 ae 66 a0 3a fa e6 e0 3b 95 46 6e de 24 79 3e cb a4 73 80 07 a0 6a 4e d5 ca 03 80 4f 0d ab e9 97 83 b6 e7 eb 48 c6 1d 64 8d 43 9a 12 c2 60 ac 72 00 6e e5 d4 b3 b4 03 b8 e5 be 8c b1 3d 21 51 66 e4 22 62 32 ce 71 1f 3a 7d 90 4c 35 d6 6b d0 ff 02 70 1b 69 4f 2b d2 67 24 bb 56 6f 75 e4 23 08 aa 55 95 61 ec 81 fe 47 c2 44 01 86 2f a1 23 09 16 6b 3d 2b 2a 9b 43 78 0d 6d 7f c2 ee bd f4 55 36 6e d0 4d ef ea 37 d9 51 72 27 5f d4 01 f7 69 df 81 fb 0b 7e 40 c3 5d 35 61 e5 42 9d 81 54 76 9c 7e cf b8 f1 82 09 23 12 29 ae a7 64 54 b4 d1 5c f1 06 e6 a9 ed 15 fc 33 a4 9a 7b 1e 70 ed 87 1c e2 7a 21 de 13 5c d1 90 65 19 d6 96 46 fc 69 b2 58 e1 37 42 b1 04 52 2e c5 f8 ea 60 61 2b dd 8f fa 90 3c be 99 f0 f3 e0 bb 84 f5 69 e7 a8 ec 20 35 57 4a 78 59 b3 78 7d 8c da bf b0 6b b0 e6 1e 98 11 b0 de 45 7c b9 da 97 19 1a 0b ad e8 42 55 55 62 1d fd dd 26 e7 88 c2 b5 74 49 f7 b4 28 e4 43 9c 72 55 22 1e d9 eb ca 93 0c c3 99 13 5b 6c af 75 a7 cb 1a 0b ee 02 9c 37 4f 07 2b 10 ca cc ed e4 94 cf 42 18 27 5d e8 5b 73 5c 65 1d 02 b7 8b d9 73 3e 9f eb f9 e0 f1 95 76 22 d4 df c0 ec 9b e0 b1 06 a2 2f 7e ad 15 b0 cd ac 58 23 f0 f3 dc 25 d7 9a 19 84 87 c5 67 e4 c9 b5 77 9e ea ac 92 69 ae 92 d0 af 5a 39 eb 29 89 a8 c2 b7 c6 05 23 df 15 75 1e 7a d9 21 75 91 d1 54 cc 15 58 73 a0 ad 1b 42 7f 66 60 ec 14 6c 87 19 92 b7 c4 9c 51 a3 da 0d 59 95 f8 45 6c a4 53 22 db 2e ec 8d 69 5e d0 6b 64 51 e4 8e 82 ef 6b d0 9e 15 9b 57 ea 7e c6 3e 79 dc 29 c3 21 bb fa d2 25 c9 93 4b 0d 38 4e 5a ef 01 d5 9a 3c 40 a8 e4 96 22 bb ec 93 42 39 a3 61 dc 6b 66 42 08 8b 9d 65 3a dc 01 ac 54 24 4e f0 ed a7 29 9b 5c d0 47 d2 d3 81 57 17 10 26 91 8e 89 08 56 fc cd e8 b7 31 a8 fb ae ae 7c 21 95 f5 e0 48 2f c2 21 b9 16 29 62 54 c6 fa ad d2 3f c6 bf d8 18 44 7b be e4 c1 ae 2b ad cc f9 51 65 09 4d 4f 43 1b 60 b9 b7 62 eb 8e a7 0f f6 93 fe 5a 05 97 dd bd c0 d8 0a 86 93 a9 ca f6 b1 e2 a4 c4 c0 ca b8 14 d3 ad b4 af 46 13 64 3b b7 56 00 63 47 43 5c 7e 00 37 7e 2a bf 7d af 31 84 eb a6 ea e1 8c 6b e6 f9 5e a3 fa 2f 07 fd 01 e0 0f 2e 85 51 1e 99 d4 0d 37 06 b2 cb 31 2d 35 b0 82 15 c2 51 fc d3 e6 d7 a9 33 3c ec 5a 56 d3 df 52 d2 f9 5d fa 13 da 99 92 36 d5 59 2b 08 2c 49 4c 48 db a5 82 0a 6d 2a d4 83 c0 30 77 f0 b4 2d b2 c7 e4 36 70 5e 6d d3 db c8 06 0d 18 23 62 e9 68 70 af ec 2b 4a 84 0c ee 37 4d 42 84 c9 ac 36 27 75 0f e9 14 b0 24 80 ae 8a 8b 53 ba c6 37 50 11 bc e1 1c 3f ef 92 19 20 69 58 fd a6 a4 5f 44 63 08 c8 d1 1d fc 93 a2 16 95 fb b1 79 25 e5 42 c3 3a f1 87 9e 4e 6f 14 37 3c 76 f7 b5 e5 d4 0e a3 82 c0 c6 ae cc 0f 87 e8 d9 07 df c5 72 ef 15 5a 38 26 e8 ca 81 dd 99 ff 90 5e 32 76 02 c2 c6 f1 f5 4b d5 97 46 0c 9e 93 00 01 9d 70 43 ca fd 77 b2 05 0e 62 74 16 67 17 2c 4a 4f ce 78 61 bd 1f 37 93 51 3e cb 8f 6d dc 42 97 a4 4c ce e4 7e 82 8d 52 07 1f 63 24 c5 54 cc 04 07 ae d4 77 48 36 e5 79 5b 37 b1 24 42 a8 76 f3 61 d7 27 64 04 4b 9f 58 1c 2b 53 d9 ba d5 fe b1 82 b2 b5 16 9b 5a 16 2c ce a0 4c 65 6a c7 bd 09 9a f5 38 e9 7c 0d cf 9f 89 56 19 5f a5 ba 0e 3a 83 b9 0c f8 c6 62 df 3a 83 15 71 34 24 6e","link":"/diaries/2020-12-19/"},{"title":"实践之前","text":"decrypt d7 25 8f b2 77 b1 0e 35 00 2a 9a 69 4c d8 ba 7c f0 e7 1e 2f 07 e6 1e 62 9a 7f 83 6c 0a e2 5d 56 7e 2e 29 7e b6 80 da 7e 21 3a 96 2a 07 f8 a0 fa一篇文章，很有意思。说一个正在招实习生的技术团队，不着重考察实习生的知识储备，而更注重实习生的学习能力。其中一位有经验的面试官认为实习生可分为两类：“学习者”和“拼凑者”。真正有能力的是“学习者”，无论当前掌握的知识多少，进入新领域时都能够构建自己的知识脉络，而不是将临时搜集到的零碎知识拼凑起来，立刻产生一些成果。一般来说，“拼凑者”看上去什么都会一些，但做出来的东西效果差、没有整体性。这是因为他的知识脉络还不够清晰，无法从整体角度思考整个课题。 最近f5 8e 5b ca 86 24 78 4e 5e 76 14 04 14 da 34 76 3a f3 43 0a 8e 5c f4 3f c5 81 14 cf 11 1c af 37 2b a7 48 57 fe 47 9b e2 90 01 6e 63 4c 5f ca 57的课题是“多变量时间序列预测”，课题现在做了一些，我发现自己正在扮演“拼凑者”。我没有首先从整体的角度思考这个课题，而是用搜索引擎盲目地检索知识，并将搜集到的资料拼凑起来。例如看到有人说LSTM适合这个课题，我不先去了解LSTM的理论知识，而是直接找来了可用于实现LSTM的框架；发现两个变量之间有线性关系，我就去分析这种关系，而不去想这种分析究竟有没有意义。 “欲速则不达”这个道理，我现在明白了。明天开始，我将暂停编程实践，花几天时间系统地了解与课题相关的技术，并做好总结，以构建一个完整的知识脉络。","link":"/diaries/2021-01-30/"},{"title":"README","text":"更进一步地利用我的独立博客，我干脆连日记也一起放在上面，用于写下一些不成熟的想法和批判自己，理论上算是公开了。 这是个很矛盾的想法，其实我是写给自己看的——毕竟实际看到这个页面的人很少。但我又想在名义上沾上一些 “公开”，于是就这样做了。另外，如果你看到了这些页面，不要告诉我，不确定是个十分奇妙的感受。让其处于 被其他人看到了 和 没有被其他人看到 相互交织的一种状态，就像薛定谔的猫一样。 某些时候，一些特定的内容涉及隐私。这些内容我不想揭露，但必须得写下来，于是就有了加密机制。下方是加密内容的一个例子，我使用了 AES (CBC 模式 + PKCS7 填充)： decrypt 23 2c 59 6e db e0 7a b3 ef 63 31 40 9d b5 ef 5b 07 84 3f 88 78 63 43 72 85 c4 65 59 3f 8c 06 ad 05 84 ca 81 cf 17 0d 10 d1 d5 55 b4 aa e5 0e fa 密码错误的话，会提示再试一次。好奇的你可能会对密码输入框 “Inspect Element”，接着会发现一段长长的 SHA256 Digest，之后开始怀疑我是否严谨。说明一下吧，我喜欢烹饪，可是加盐时从来不考虑口味（雾 密码正确的话，这些绿色的字节就会变为： “这是一段加密文字。” 目录2021-01-30&nbsp;实践之前2020-12-19&nbsp;近期小结2020-11-08&nbsp;Domestic Life is Harmful2020-11-07&nbsp;The Reason I Regard a Smile as an Emblem of Evil2020-11-03&nbsp;Initial Commit","link":"/diaries/README/"},{"title":"","text":"function browserdetails(useragent) { var os = false; // var brand = false; var details = {}; if (Object(useragent).details !== undefined) { return useragent.details; } useragent = (' ' + useragent).toLowerCase(); // if (useragent.indexOf('~:') !== -1) { // brand = useragent.match(/~:(\\d+)/); // brand = brand && brand.pop() | 0; // } if (useragent.indexOf('windows phone') > 0) { os = 'Windows Phone'; } else if (useragent.indexOf('android') > 0 || useragent.indexOf('andr0id') > 0) { os = 'Android'; } else if (useragent.indexOf('iphone') > 0) { os = 'iPhone'; } else if (useragent.indexOf('imega') > 0) { os = 'iPhone'; } else if (useragent.indexOf('ipad') > 0) { os = 'iPad'; } else if (useragent.indexOf(' edga/') > 0) { os = 'Android'; } // else if (useragent.indexOf(' crios') > 0) { // details.brand = 'CriOS'; // } details.os = os || ''; // if (brand) { // details.brand = brand; // } return details; } var ua = window.navigator.userAgent.toLowerCase(); try { ua = Object(ua); ua.details = Object.create(browserdetails(ua)); } catch (e) { } function isMobile() { var mobileStrings = [ 'iphone', 'ipad', 'android', 'blackberry', 'nokia', 'opera mini', 'ucbrowser', 'windows mobile', 'windows phone', 'iemobile', 'mobile safari', 'bb10; touch' ]; for (var i = mobileStrings.length; i--;) { if (ua.indexOf(mobileStrings[i]) > 0) { return true; } } return false; } var is_mobile = isMobile(); var is_ios = is_mobile && (ua.indexOf('iphone') > -1 || ua.indexOf('ipad') > -1 || ua.indexOf('ipod') > -1); if (is_ios) { tmp = ua.match(/(?:iphone|cpu) os (\\d+)[\\._](\\d+)/); if (tmp) { is_ios = parseInt(tmp[1]); if (!is_ios) { is_ios = true; } } tmp = undefined; if (is_mobile) { // Prevent Safari's copy&paste bug.. window.onhashchange = function () { location.reload(); }; } } // file: mega://#!! // folder: mega://#F!! var input_bar = document.getElementsByClassName('input')[0]; function getAppLink() { var link = input_bar.value.trim(); var result = link.match(/mega.nz\\/(file|folder)\\/(.+)?#(.+)/); try { var key = result.pop(); var id = result.pop(); var type = result.pop(); } catch (e) { return false; } return (type === 'file' ? '#!' : '#F!') + id + '!' + key; } function getStoreLink() { switch (ua.details.os) { case 'iPad': case 'iPhone': return 'https://itunes.apple.com/app/mega/id706857885'; case 'Windows Phone': return 'zune://navigate/?phoneappID=1b70a4ef-8b9c-4058-adca-3b9ac8cc194a'; case 'Android': return 'https://play.google.com/store/apps/details?id=mega.privacy.android.app&referrer=meganzindexandroid'; default: return false; } } function redirectToApp() { var redirectLink = getAppLink(); if (!redirectLink) { window.alert(\"The link is invalid.\"); return; } // If iOS (iPhone, iPad, iPod), use method based off https://github.com/prabeengiri/DeepLinkingToNativeApp/ if (is_ios) { var appLink = 'mega://' + redirectLink; window.location = appLink; // var timeout = null; // var redirectToStore = function () { // window.top.location = getStoreLink(); // }; // var redirect = function () { // var ms = 500; // window.location = appLink; // if (is_ios > 8 && ua.details.brand !== 'CriOS') { // ms = 4100; // } // timeout = setTimeout(redirectToStore, ms); // }; // redirect(); } // Otherwise if Windows Phone else if (ua.details.os === 'Windows Phone') { window.location = 'mega://' + redirectLink; } // Otherwise if Android else if (ua.indexOf('android') > -1) { var intent = 'intent://' + redirectLink + '/#Intent;scheme=mega;package=mega.privacy.android.app;end'; document.location = intent; } else { // Otherwise show an error saying the device is unsupported window.alert('This device is unsupported.'); } return false; } function redirectToStore() { var storeLink = getStoreLink(); if (!storeLink) { window.alert('This device is unsupported.'); return; } window.top.location = storeLink; }","link":"/repos/mega-helper/helper.js"},{"title":"MEGA Helper","text":"如果您未安装MEGA应用，点击此处下载安装。 OPEN IN MEGA APP 该项目的源代码由MIT许可证进行许可。 project-hierarchy >folded1234mega-helper├── helper.js├── index.html└── LICENSE","link":"/repos/mega-helper/"},{"title":"","text":"const input_bar = document.getElementById('password') const output_bar = document.getElementById('out') function stringToBytes(str) { var bytes = new Array() var len, c len = str.length for (var i = 0; i < len; i++) { c = str.charCodeAt(i) if (c >= 0x010000 && c > 18) & 0x07) | 0xF0) bytes.push(((c >> 12) & 0x3F) | 0x80) bytes.push(((c >> 6) & 0x3F) | 0x80) bytes.push((c & 0x3F) | 0x80) } else if (c >= 0x000800 && c > 12) & 0x0F) | 0xE0) bytes.push(((c >> 6) & 0x3F) | 0x80) bytes.push((c & 0x3F) | 0x80) } else if (c >= 0x000080 && c > 6) & 0x1F) | 0xC0) bytes.push((c & 0x3F) | 0x80) } else { bytes.push(c & 0xFF) } } return bytes } function bytesToString(arr) { if (typeof arr === 'string') { return arr } var str = '', _arr = arr for (var i = 0; i < _arr.length; i++) { var one = _arr[i].toString(2), v = one.match(/^1+?(?=0)/) if (v && one.length == 8) { var bytesLength = v[0].length var store = _arr[i].toString(2).slice(7 - bytesLength) for (var st = 1; st < bytesLength; st++) { store += _arr[st + i].toString(2).slice(2) } str += String.fromCharCode(parseInt(store, 2)) i += bytesLength - 1 } else { str += String.fromCharCode(_arr[i]) } } return str } function encode() { let str = input_bar.value let length = stringToBytes(str).length if (length % 4) str = str.padEnd(Math.ceil(length / 4) * 4, '\\0') let bytes = stringToBytes(str) let groups = length / 4 let result = [] for (let i = 0; i < groups; ++i) { let tmp = 0 for (let j = 0; j < 4; ++j) tmp = tmp * 256 + bytes[i * 4 + j] for (let j = 0; j < 14; ++j) { result = [226, 128, 139 + (tmp % 5)].concat(result) tmp = Math.floor(tmp / 5) } } output_bar.innerHTML = bytesToString(result) } function decode() { let data = input_bar.value.match(/[\\u200b\\u200c\\u200d\\u200e\\u200f]/g) if (data == null || data.length % 14) { output_bar.innerHTML = '无隐藏信息或是格式错误' return } let cipher = data.map((c) => (c.charCodeAt(0) - 8203)) let result = [] let groups = cipher.length / 14 for (let i = 0; i < groups; ++i) { let tmp = 0 for (let j = 0; j < 14; ++j) tmp = tmp * 5 + cipher[i * 14 + j] for (let j = 0; j < 4; ++j) { result = [tmp % 256].concat(result) tmp = Math.floor(tmp / 256) } } output_bar.innerHTML = bytesToString(result) } document.getElementById('decode').removeAttribute('disabled') document.getElementById('encode').removeAttribute('disabled') var clipboard = new ClipboardJS(\"#encode\") clipboard.on('success', function (e) { if (output_bar.innerHTML == '') output_bar.innerHTML = '请输入需要编码的内容' else output_bar.innerHTML = '编码后的内容已复制到剪贴板' }) clipboard.on('error', function (e) { output_bar.innerHTML = '[' + output_bar.innerHTML + '] 复制失败，请手动复制中括号中的内容' })","link":"/repos/white-space-converter/converter-deprecated.js"},{"title":"","text":"const input_bar = document.getElementById('cipher') const output_bar = document.getElementById('out') const dict = '\\u200b\\ufeff' function stringToCipher(str, dict) { let hex = CryptoJS.enc.Utf8.parse(str).toString(CryptoJS.enc.Hex) let bytes = new Array for (let i = 0; i < hex.length; i += 2) bytes.push(parseInt(hex[i], 16) * 16 + parseInt(hex[i + 1], 16)) let result = '' for (let i = 0; i < bytes.length; ++i) { let tmp = '', t = bytes[i] for (let j = 0; j < 8; ++j) { tmp = dict[t % 2] + tmp t = Math.floor(t / 2) } result += tmp } if (result.length) return dict[0] + result return '' } function cipherToString(cipher, dict) { let bits = Array.from(cipher).map((x) => (x == dict[0] ? 0 : 1)) let bytes = new Array for (let i = 0, i_ = (bits.length - 1) / 8; i < i_; ++i) { let tmp = 0 for (let j = 0; j < 8; ++j) tmp = tmp * 2 + bits[i * 8 + j + 1] bytes.push(tmp) } let hex = '' for (let i = 0; i < bytes.length; ++i) hex += bytes[i].toString(16) return CryptoJS.enc.Hex.parse(hex).toString(CryptoJS.enc.Utf8) } function encode() { output_bar.innerHTML = stringToCipher(input_bar.value, dict) } function decode() { const regex = new RegExp(`[${dict[0]}${dict[1]}]`, 'g') let cipher = input_bar.value.match(regex) if (cipher == null) output_bar.innerHTML = '无隐藏内容' else if ((cipher.length - 1) % 8) output_bar.innerHTML = '编码格式有误' else output_bar.innerHTML = cipherToString(cipher.join(''), dict) } const clipboard = new ClipboardJS(\"#encode\") clipboard.on('success', function (e) { if (output_bar.innerHTML == '') output_bar.innerHTML = '请输入需要编码的内容' else output_bar.innerHTML = '编码后的内容已复制到剪贴板' }) clipboard.on('error', function (e) { if (output_bar.innerHTML == '') output_bar.innerHTML = '请输入需要编码的内容' else output_bar.innerHTML = '[' + output_bar.innerHTML + '] 复制失败，请手动复制中括号中的内容' }) document.getElementById('decode').removeAttribute('disabled') document.getElementById('encode').removeAttribute('disabled')","link":"/repos/white-space-converter/converter.js"},{"title":"White-space Converter","text":"decode encode 该项目的源代码由MIT许可证进行许可。 project-hierarchy >folded12345white-space-converter├── converter-deprecated.js├── converter.js├── index.html└── LICENSE","link":"/repos/white-space-converter/"},{"title":"Chapter 1 Recurrent Problems","text":"WarmupsHomework exercises1.8List $Q_1$ through $Q_6$, we could find out that $Q$ is periodic. $$\\begin{aligned}Q_m&amp;=\\alpha;\\\\Q_{m+1}&amp;=\\beta;\\\\Q_{m+2}&amp;=(1+\\beta)/\\alpha;\\\\Q_{m+3}&amp;=(1+\\alpha+\\beta)/(\\alpha\\beta);\\\\Q_{m+4}&amp;=(1+\\alpha)/\\beta,\\quad\\text{for $m\\in\\{0,5,10,\\ldots\\}$.}\\end{aligned}$$ 1.9a$$\\begin{aligned}x_1\\ldots x_{n}&amp;\\leq\\left(\\frac{x_1+\\cdots+x_{n-1}+x_n}{n}\\right)^n\\qquad\\text{by $(n-1)x_n=x_1+\\cdots+x_{n-1}$}\\\\x_1\\ldots x_{n}&amp;\\leq\\left(\\frac{(n-1)x_n+x_n}{n}\\right)^n\\\\x_1\\ldots x_{n-1}&amp;\\leq(x_n)^{n-1}\\\\x_1\\ldots x_{n-1}&amp;\\leq\\left(\\frac{x_1+\\cdots+x_{n-1}}{n-1}\\right)^{n-1}.\\end{aligned}$$ 1.9b$$\\begin{aligned}x_1\\ldots x_n x_{n+1}\\ldots x_{2n}&amp;\\leq\\left(\\frac{x_1+\\cdots+x_n}{n}\\right)^n\\left(\\frac{x_{n+1}+\\cdots+x_{2n}}{n}\\right)^n\\qquad\\text{by $P(2):x_1x_2\\leq\\left(\\frac{x_1+x_2}2\\right)^2$}\\\\&amp;\\leq\\left(\\frac{\\left(\\frac{x_1+\\cdots+x_n+x_{n+1}+\\cdots+x_{2n}}2\\right)^2}{n^2}\\right)^n\\\\&amp;\\leq\\left(\\frac{x_1+\\cdots+x_n+x_{n+1}+\\cdots+x_{2n}}{2n}\\right)^{2n}.\\end{aligned}$$ 1.9cFor example, $P(5)$ follows from $P(6)$ from $P(3)$ from $P(4)$ from $P(2)$ which is proved to be true. And whenever $n&gt;1$, $P(n)$ is finally based on $P(2)$. 1.10It’s clear that $Q_n=2R_n-1$ if we move $n-1$ disks counter-clockwise; move the largest disk clockwise; move $n-1$ disks counter-clockwise again. Then $R_n=2R_n+Q_{n-1}+2$ if we move $n-1$ disks counter-clockwise; move the largest disk clockwise; move $n-1$ disks clockwise; move the largest disk clockwise again; move $n-1$ disks back counter-clockwise. Plug $Q_n=2R_n-1$ in, then $R_n=Q_n+Q_{n-1}+1$. 1.11aMove a double $(n-1)$-tower, then move the two largest disks, which takes $2$ moves, then move the double $(n-1)$-tower again. Let $A_n$ be the minimum number of moves, hence $A_n=2A_{n-1}+2=2^{n+1}-2$. 1.11bLet $\\require{enclose}\\enclose{horizontalstrike}{B_n}$ be the minimum number of moves to move a double $\\require{enclose}\\enclose{horizontalstrike}{n}$-tower in the original order; $\\require{enclose}\\enclose{horizontalstrike}{H_n}$ be the minimum number of moves to move a double $\\require{enclose}\\enclose{horizontalstrike}{n}$-tower except for the bottom disk. Then we have $\\require{enclose}\\enclose{horizontalstrike}{B_n=H_n+1+B_{n-1}+1+B_{n-1}}$ and $\\require{enclose}\\enclose{horizontalstrike}{H_n=B_{n-1}+1+B_{n-1}}$. Insert $\\require{enclose}\\enclose{horizontalstrike}{H_n}$ to the $\\require{enclose}\\enclose{horizontalstrike}{B_n}$ equation, we could get $\\require{enclose}\\enclose{horizontalstrike}{B_n=4B_{n-1}+3=4^n-1}$. By referring to the answer, I found out that my approach above wasn’t correct. I’ve made a mistake that I postulated all disks never change the order during their moves, which is not necessary. It can be shown that no strategy does better than $B_n=A_{n-1}+2+A_{n-1}+2+B_{n-1}$. This strategy changes the order of bottom two disks twice but doesn’t care whether the upper disks keep the order during their moves, which is also the reason why we use $A_n$ here. Thus, $B_n=2^{n+2}-5$. 1.12$$A(m_1,\\ldots,m_n)=2A(m_1,\\ldots,m_{n-1})+m_n.$$ This is an equation of the “generalized Josephus” type, whose solution is $(m_1\\ldots m_k)_2$. 1.13We already know $n$ straight lines define $L_n=\\frac{n(n+1)}2+1$ regions on a plane, and when the $n$-th line is added in, $n$ new areas are created. Let the zig-zags be extremely narrow to be seen as straight lines to some extent. So when the $n$-th zig-zag is added in, $n$ new areas are created “in the straight line manner.” We could also see that when two zig-zags intersect, $8$ new areas are created “around their intersection” in the way shown below: And when the $n$-th zig-zag is added in, there are at most $n-1$ new “intersections.” So $$Z\\!Z_n=Z\\!Z_{n-1}+n+8(n-1)=\\frac92n^2+\\frac72n+1.$$ 1.14$n$ new areas are created when the $n$-th line is added into the plane, which is equal to the maximum number of line segments created by splitting a line with $n-1$ points. Analogously, $L_{n-1}$ new pieces of cheese is created when making the $n$-th slice. So, in recurrence form $$P_n=\\begin{cases}1,&amp;\\text{if $n=0$};\\\\P_{n-1}+L_{n-1},&amp;\\text{if $n&gt;0$}.\\end{cases}$$ We have $P_5=26$. 1.15The function $I$ has the same recursion relation as $J$, but with different boundary values, which are $I(2)=2,I(3)=1$. Thus, we cannot find a unique $I(1)$ that satisfies this recurrence. So we have to split it into two cases, one with $I(2)=2$ and one with $I(3)=1$. Let’s represent in terms of $n=2^m+l$, and let $\\beta_0=-1,\\beta_1=1$. The recurrence unfolds, binary-wise: $$\\begin{aligned}I\\big((b_mb_{m-1}\\ldots b_0)_ 2\\big)&amp;=2I\\big((b_mb_{m-1}\\ldots b_1)_ 2\\big)+\\beta _ {b_0}\\\\&amp;\\;\\;\\vdots\\\\&amp;=2^{m-1}I\\big((b_mb_{m-1})_2\\big)+\\cdots+2\\beta _{b_1}+\\beta _{b_0}.\\end{aligned}$$ Then we can stop here, so far the function $I$ have the same form as $J$, and the two leading bits $(b_mb_{m-1})_2$ are enough to contain the two cases: $$\\begin{aligned}J(2)=1,I(2)=2&amp;\\implies I(n)-J(n)=2^{m-1};\\\\J(3)=3,I(3)=1&amp;\\implies I(n)-J(n)=-2^m.\\end{aligned}$$ That is to say $$I(n)=\\begin{cases}J(n)+2^{m-1},&amp;\\text{if $0\\leq l&lt;2^{m-1}$};\\\\J(n)-2^m,&amp;\\text{if $2^{m-1}\\leq l&lt;2^m$}.\\end{cases}$$ 1.16Express $g(n)$ in the form $$g(n)=A(n)\\alpha+B(n)\\beta_0+C(n)\\beta_1+D(n)\\gamma.$$ Let $g(n)=1$, which implies $(\\alpha,\\beta_0,\\beta_1,\\gamma)=(1,-2,-2,0)$. Then $$A(n)-2B(n)-2C(n)=1.\\tag{1}$$ Let $g(n)=n$, which implies $(\\alpha,\\beta_0,\\beta_1,\\gamma)=(1,0,1,-1)$. Then $$A(n)+C(n)-D(n)=n.\\tag{2}$$ Let $(\\alpha,\\beta_0,\\beta_1,\\gamma)=(1,-2,-2,0)$, which gives $g(n)=3^m$. Then (note we’re representing in terms of $n=2^m+l$) $$A(n)=3^m.\\tag{3}$$ Let $(\\alpha,\\beta_0,\\beta_1,\\gamma)=(0,0,1,0)$. Similar to the binary expansion in the Josephus problem, we have $$C(n)=(b_{m-1}\\ldots b_0)_3.\\tag{4}$$ I also checked that for $(1)(2)(3)$ and $(4)$, $$\\left|\\begin{array}{cccc}1&amp;-2&amp;-2&amp;0\\\\1&amp;0&amp;1&amp;-1\\\\1&amp;0&amp;0&amp;0\\\\0&amp;0&amp;1&amp;0\\end{array}\\right|\\neq0.$$ The recurrence is solvable; hence $$\\begin{aligned}A(n)&amp;=3^m;\\\\B(n)&amp;=\\big(3^m-2(b_{m-1}\\ldots b_0)_ 3-1\\big)/2;\\\\C(n)&amp;=(b_{m-1}\\ldots b_0)_ 3;\\\\D(n)&amp;=3^m+(b_{m-1}\\ldots b_0)_3-n.\\end{aligned}$$ Then $$\\begin{aligned}g(n)&amp;=3^m\\alpha+\\big(3^m-2(b_{m-1}\\ldots b_0)_ 3-1\\big)\\frac{\\beta_0}2+(b_{m-1}\\ldots b_0)_ 3\\beta_1+\\big(3^m+(b_{m-1}\\ldots b_0)_ 3-n\\big)\\gamma\\\\&amp;=\\left(\\alpha+\\frac{\\beta_0}2+\\gamma\\right)3^m+(-\\beta_0+\\beta_1+\\gamma)(b_{m-1}\\ldots b_0)_3-\\frac{\\beta_0}2-n\\gamma.\\end{aligned}$$","link":"/CM/exercises/1/"},{"title":"Chapter 3 Integer Functions","text":"WarmupsBasics3.10The given expression equals to $\\left\\lceil x-\\frac12\\right\\rceil+\\big[(2x+1)/4\\text{ is integer}\\big]$. This is the nearest integer to $x$, if $\\{x\\}\\neq\\frac12$; otherwise it is the nearest even integer to $x$. 3.11If $n$ is an integer in the interval, $\\alpha\\lt n\\lt\\beta$$\\iff$$\\lfloor\\alpha\\rfloor\\lt n\\lt\\lceil\\beta\\rceil$. The number of such $n$’s is $(\\beta-\\alpha-1)$, which could be negative if $\\alpha,\\beta$ are integers and $\\alpha=\\beta$. 3.12$$\\begin{aligned}\\left\\lceil\\frac nm\\right\\rceil&amp;=\\left\\lfloor\\frac{n+m-1}m\\right\\rfloor\\\\\\left\\lfloor\\frac nm\\right\\rfloor+\\left\\lceil\\frac{n\\,{\\rm mod}\\,m}m\\right\\rceil&amp;=\\left\\lfloor\\frac nm\\right\\rfloor+\\left\\lfloor\\frac{(m-1)+n\\,{\\rm mod}\\,m}m\\right\\rfloor.\\end{aligned}$$ Both sides are equal to $\\left\\lfloor\\frac nm\\right\\rfloor+[n\\,{\\rm mod}\\,m&gt;0]$. 3.13Use the definition of $N(\\alpha,n)$, by $(3.14)$. We also have a useful property that $\\lceil x\\rceil-\\lfloor x\\rfloor=1$, if $x$ is irrational. Then $$\\begin{aligned}N(\\alpha,n)+N(\\beta,n)&amp;=\\left\\lceil\\frac{n+1}\\alpha\\right\\rceil-1+\\left\\lceil\\frac{n+1}\\beta\\right\\rceil-1\\\\&amp;=\\left\\lfloor\\frac{n+1}\\alpha\\right\\rfloor+\\left\\lfloor\\frac{n+1}\\beta\\right\\rfloor\\\\&amp;=\\frac{n+1}\\alpha-\\left\\{\\frac{n+1}\\alpha\\right\\}+\\frac{n+1}\\beta-\\left\\{\\frac{n+1}\\beta\\right\\}\\\\&amp;=n+1-\\left\\{\\frac{n+1}\\alpha\\right\\}-\\left\\{\\frac{n+1}\\beta\\right\\}.\\end{aligned}$$ Since $\\alpha,\\beta$ are irrational, the last two terms are both non-zero; and they must add up to one. Finally $$N(\\alpha,n)+N(\\beta,n)=n.$$ 3.14$$\\begin{aligned}(x\\,{\\rm mod}\\,ny)\\,{\\rm mod}\\,y&amp;=x-ny\\left\\lfloor\\frac x{ny}\\right\\rfloor-y\\left\\lfloor\\frac{x-ny\\left\\lfloor\\frac x{ny}\\right\\rfloor}y\\right\\rfloor\\\\&amp;=x-y\\Bigg\\lfloor\\frac xy-n\\left\\lfloor\\frac x{ny}\\right\\rfloor+n\\left\\lfloor\\frac x{ny}\\right\\rfloor\\Bigg\\rfloor\\\\&amp;=x-y\\left\\lfloor\\frac xy\\right\\rfloor=x\\,{\\rm mod}\\,y.\\end{aligned}$$ 3.15$$\\lceil mx\\rceil=\\lceil x\\rceil+\\left\\lceil x-\\frac1m\\right\\rceil+\\cdots+\\left\\lceil x-\\frac{m-1}m\\right\\rceil.$$ 3.16According to the explanation on Page 93, and $\\gcd(n,3)=1$ if integer $n$ is not an integer multiple of $3$, the sequence of numbers $$0\\,{\\rm mod}\\,3,\\;n\\,{\\rm mod}\\,3,\\;2n\\,{\\rm mod}\\,3$$ must hit $1,2,3$ exactly once, respectively. So we have $$\\begin{aligned}n\\,{\\rm mod}\\,3=0&amp;\\implies a+b+c=0;\\\\n\\,{\\rm mod}\\,3=1&amp;\\implies a+b\\omega+c\\omega^2=1;\\\\n\\,{\\rm mod}\\,3=2&amp;\\implies a+b\\omega^2+c\\omega=2.\\end{aligned}$$ This gives $$\\begin{aligned}a&amp;=1,\\\\b&amp;=\\frac12\\left(-1+\\frac i{\\sqrt3}\\right)=\\frac13(\\omega-1),\\\\c&amp;=\\frac12\\left(-1-\\frac i{\\sqrt3}\\right)=\\frac{-1}3(\\omega+2).\\end{aligned}$$ Hence, $n\\,{\\rm mod}\\,3=1+\\frac13\\big((\\omega-1)\\omega^n-(\\omega+2)\\omega^{2n}\\big)$. 3.17$$\\begin{aligned}\\sum_{0\\leq k\\lt m}\\left\\lfloor x+\\frac km\\right\\rfloor&amp;=\\sum_{j,k\\geq0}\\left[1\\leq j\\leq x+\\frac km\\right][k\\lt m]\\\\&amp;=\\sum_{j,k\\geq0}\\big[1\\leq j\\leq\\lceil x\\rceil\\big]\\big[m(j-x)\\leq k\\lt m\\big]\\\\&amp;=\\sum_k\\Big[m\\big(\\lceil x\\rceil-x\\big)\\leq k\\lt m\\Big]+\\sum_{j,k}\\big[1\\leq j\\lt\\lceil x\\rceil\\big][0\\leq k\\lt m]\\\\&amp;=\\lceil m\\rceil-\\Big\\lceil m\\big(\\lceil x\\rceil-x\\big)\\Big\\rceil+m\\big(\\lceil x\\rceil-1\\big)\\\\&amp;=-\\lceil-mx\\rceil=\\lfloor mx\\rfloor.\\end{aligned}$$ Homework exercises3.19$$\\begin{aligned}&amp;\\big\\lfloor\\log_b\\lfloor x\\rfloor\\big\\rfloor=m\\\\&amp;\\iff m\\leq\\log_b\\lfloor x\\rfloor\\lt m+1\\\\&amp;\\iff b^m\\leq\\lfloor x\\rfloor\\lt b^{m+1};\\\\\\\\&amp;\\lfloor\\log_bx\\rfloor=m\\\\&amp;\\iff m\\leq\\log_bx\\lt m+1\\\\&amp;\\iff b^m\\leq x\\lt b^{m+1}.\\end{aligned}$$ If and only if $b^m,b^{m+1}$ are integers, we have $b^m\\leq\\lfloor x\\rfloor\\lt b^{m+1}$$\\iff$$b^m\\leq x\\lt b^{m+1}$. Since $m\\geq0$, this happens only when $b$ is an integer. 3.20$$\\begin{aligned}\\sum_kkx[\\alpha\\leq kx\\leq\\beta]&amp;=x\\sum_kk\\left[\\frac\\alpha x\\leq k\\leq\\frac\\beta x\\right]\\\\&amp;=\\frac12x\\big(\\left\\lfloor\\beta/x\\right\\rfloor+\\left\\lceil\\alpha/x\\right\\rceil\\big)\\big(\\left\\lfloor\\beta/x\\right\\rfloor-\\left\\lceil\\alpha/x\\right\\rceil+1\\big).\\end{aligned}$$ 3.21(Note: ‘$\\lg x$’ is binary logarithm, and ‘$\\log x$’ is common logarithm.) $$\\begin{aligned}&amp;\\sum_{k,m}\\big[10^k\\leq2^m\\lt2\\cdot10^k\\big][0\\leq m\\leq M]\\\\&amp;\\quad=\\sum_{k,m}\\big[\\lg10^k\\leq m\\lt\\lg2\\cdot10^k\\big][0\\leq m\\leq M]\\\\&amp;\\quad=\\sum_{k,m}\\Big[\\left\\lceil\\lg10^k\\right\\rceil\\leq m\\lt\\left\\lceil\\lg10^k\\right\\rceil+1\\Big][0\\leq m\\leq M]\\\\&amp;\\quad=\\sum_{k,m}\\big[m=\\lceil k\\lg10\\rceil\\big][-1\\lt m\\leq M]\\\\&amp;\\quad=\\sum_k\\big[-\\log2\\lt k\\leq M\\log2\\big]\\\\&amp;\\quad=1+\\lfloor M\\log2\\rfloor.\\end{aligned}$$ 3.22An integer $n$ can always be decomposed into $2^{k-1}q$, where $k,q$ are integers and $q$ is odd. Hence, only the $k$-th term in $S_{n-1}$ is one less than $S_n$. In other words, we have the recurrence $$\\begin{aligned}S_0&amp;=0;\\\\S_n&amp;=S_{n-1}+1,\\quad\\text{for $n\\geq1$.}\\end{aligned}$$ This implies $S_n=n$. Likewise, only the $k$-th term in $T_{n-1}$ is $2^kq=2n$ less than $T_n$. We have the recurrence $$\\begin{aligned}T_0&amp;=0;\\\\T_n&amp;=T_{n-1}+2n,\\quad\\text{for $n\\geq1$.}\\end{aligned}$$ This implies $T_n=n(n+1)$. 3.23The $n$-th element of the sequence equals to $m$, which gives $$\\begin{aligned}&amp;\\frac{m(m-1)}2\\lt n\\leq\\frac{m(m+1)}2\\\\&amp;\\iff m^2-m\\lt 2n\\leq m^2+m\\\\&amp;\\iff m^2-m+\\frac14\\leq 2n\\lt m^2+m+\\frac14\\\\&amp;\\iff m-\\frac12\\leq\\sqrt{2n}\\lt m+\\frac12\\\\&amp;\\iff m=\\left\\lfloor\\sqrt{2n}+\\frac12\\right\\rfloor.\\end{aligned}$$ 3.24The number of times a non-negative integer occurs in ${\\rm Spec}\\big(\\alpha/(\\alpha+1)\\big)$ is exactly one more than the number of times it occurs in ${\\rm Spec}(\\alpha)$. That’s because $$\\begin{aligned}&amp;N\\big(\\alpha/(\\alpha+1),n\\big)-N(\\alpha,n)\\\\&amp;\\quad=\\left\\lceil(\\alpha+1)\\frac{n+1}\\alpha\\right\\rceil-1-\\left\\lceil\\frac{n+1}\\alpha\\right\\rceil+1\\\\&amp;\\quad=n+1.\\end{aligned}$$ 3.25If we could find an $m$ such that $K_m\\leq m$, we could violate the stated inequality. But the existence of such an $m=n^\\prime+1$ requires $$K_{\\lfloor n^\\prime/2\\rfloor}\\leq\\lfloor n^\\prime/2\\rfloor\\quad\\text{or}\\quad K_{\\lfloor n^\\prime/3\\rfloor}\\leq\\lfloor n^\\prime/3\\rfloor.$$ This goes down further and further, implying that $K_0\\leq0$, which contradicts $K_0=1$. Hence, there’s no such an $m$, and the inequality that $K_n&gt;n$ stands. 3.26$D_n^{(q)}$ is an auxiliary Josephus number that satisfies the recurrence $$\\begin{aligned}D_0^{(q)}&amp;=1;\\\\D_n^{(q)}&amp;=\\left\\lceil\\frac q{q-1}D_{n-1}^{(q)}\\right\\rceil,\\quad\\text{for $n\\geq0$.}\\end{aligned}$$ Show that the auxiliary Josephus numbers satisfy $$\\left(\\frac q{q-1}\\right)^n\\leq D_n^{(q)}\\leq q\\left(\\frac q{q-1}\\right)^n,\\quad\\text{for $n\\geq0$.}$$ The left part is easy to prove. First, the basis $1\\leq D_0^{(q)}$ stands when $n=0$; then $$\\begin{aligned}&amp;\\left(\\frac q{q-1}\\right)^{n-1}\\leq D_{n-1}^{(q)}\\\\&amp;\\iff\\left(\\frac q{q-1}\\right)^n\\leq\\frac q{q-1}D_{n-1}^{(q)}\\\\&amp;\\implies\\left(\\frac q{q-1}\\right)^n\\leq\\left\\lceil\\frac q{q-1}D_{n-1}^{(q)}\\right\\rceil\\\\&amp;\\iff\\left(\\frac q{q-1}\\right)^n\\leq D_n^{(q)}.\\end{aligned}$$ But the right part is a little tricky. Let’s try to prove it directly, we would have $$\\begin{aligned}&amp;D_{n-1}^{(q)}\\leq q\\left(\\frac q{q-1}\\right)^n\\\\&amp;\\iff\\frac q{q-1}D_{n-1}^{(q)}\\leq q\\left(\\frac q{q-1}\\right)^{n+1}\\end{aligned}$$ but no more, because there’s no “space” left on the right-hand side for us to add a pair of ceiling on the left-hand side. To proceed, we would have to subtract something from the right-hand side at the beginning. For example, we could subtract $q-1$ from the right-hand side and then prove the stronger hypothesis: $$D_n^{(q)}\\leq q\\left(\\frac q{q-1}\\right)^n-q+1=(q-1)\\left(\\left(\\frac q{q-1}\\right)^{n+1}-1\\right),\\quad\\text{for $n\\geq0$.}$$ First, the basis $D_0^{(q)}\\leq1$ stands when $n=0$; then $$\\begin{aligned}&amp;D_{n-1}^{(q)}\\leq(q-1)\\left(\\left(\\frac q{q-1}\\right)^n-1\\right)\\\\&amp;\\iff\\frac q{q-1}D_{n-1}^{(q)}\\leq(q-1)\\left(\\left(\\frac q{q-1}\\right)^{n+1}-1\\right)-1\\\\&amp;\\implies\\left\\lceil\\frac q{q-1}D_{n-1}^{(q)}\\right\\rceil\\lt(q-1)\\left(\\left(\\frac q{q-1}\\right)^{n+1}-1\\right)\\\\&amp;\\iff D_n^{(q)}\\lt(q-1)\\left(\\left(\\frac q{q-1}\\right)^{n+1}-1\\right).\\end{aligned}$$ Since the hypothesis is stronger than original, in other words, $(q-1)\\left(\\left(\\frac q{q-1}\\right)^{n+1}-1\\right)\\lt q\\left(\\frac q{q-1}\\right)^n$, we have $D_n^{(q)}\\leq q\\left(\\frac q{q-1}\\right)^n$. 3.27Any positive integer could be decomposed into $2^mb+a$, where integer $m\\geq1$, positive integer $b$ is odd, and $a$ is $0$ or $1$. If $D_n^{(3)}=2^mb-a$, we can deduce that $$\\begin{aligned}&amp;D_n^{(3)}=2^mb-a\\\\&amp;\\iff D_{n+m}^{(3)}=3^mb-a\\\\&amp;\\iff D_{n+m}^{(3)}=(3^mb-1)+(1-a)\\\\&amp;\\iff D_{n+m}^{(3)}=2^{m^\\prime}b^\\prime+(1-a).\\end{aligned}$$ Then, we have a new version of the three original variables. Since $m^\\prime\\geq1$, we could push $D_n^{(3)}$ further and further with larger $n$’s. While we’re proceeding with $D_n^{(3)}$, $a$ alters between $1$ and $0$ every iteration; since $2^mb$ is even, this causes $D_n^{(3)}$ to change between odd and even every iteration. Thus, infinitely many of the numbers $D_n^{(3)}$ are even, and that infinitely many are odd. …………","link":"/CM/exercises/3/"},{"title":"Chapter 2 Sums","text":"WarmupsBasics2.11$$\\begin{aligned}\\sum_{0\\leq k\\lt n}(a_{k+1}-a_k)b_k&amp;=\\sum_{0\\leq k\\lt n}\\big(a_{k+1}b_{k+1}-a_kb_k-a_{k+1}(b_{k+1}-b_k)\\big)\\\\&amp;=\\sum_{0\\leq k\\lt n}(a_{k+1}b_{k+1}-a_kb_k)-\\sum_{0\\leq k\\lt n}a_{k+1}(b_{k+1}-b_k)\\\\&amp;=a_nb_n-a_0b_0-\\sum_{0\\leq k\\lt n}a_{k+1}(b_{k+1}-b_k),\\quad\\text{for $n\\geq0$.}\\end{aligned}$$ 2.12If $x=p(k)$ then $x+c=k+\\big((-1)^k+1\\big)c$. Observe that $\\big((-1)^k+1\\big)c$ is even, $x+c$ must have the same parity as $k$. This gives $(-1)^k=(-1)^{x+c}$ and $k=x-(-1)^{x+c}c$. Conversely, this value of $k$ yields $x=p(k)$. 2.13The sum is a special case of the general recurrence $$\\begin{aligned}R_0&amp;=\\alpha;\\\\R_n&amp;=R_{n-1}+(-1)^n(\\beta+\\gamma n+\\delta n^2),\\quad\\text{for $n&gt;0$,}\\end{aligned}$$ whose solution would be $$R(n)=A(n)\\alpha+B(n)\\beta+C(n)\\gamma+D(n)\\delta.$$ Setting $R_n=1$ yields $A(n)=1$.Setting $R_n=(-1)^n$ yields $A(n)+2B(n)=(-1)^n$.Setting $R_n=(-1)^nn$ yields $-B(n)+2C(n)=(-1)^nn$.Setting $R_n=(-1)^nn^2$ yields $-C(n)+2D(n)=(-1)^nn^2$. Therefore, $D(n)=(-1)^n(n^2+n)/2$. For this sum, we have $\\delta=1$; hence $$\\sum_{k=0}^n(-1)^kk^2=(-1)^n(n^2+n)/2.$$ 2.14$$\\begin{aligned}\\sum_{k=1}^nk2^k&amp;=\\sum_{1\\leq j\\leq k\\leq n}2^k\\\\&amp;=\\sum_{1\\leq j\\leq n}\\sum_{j\\leq k\\leq n}2^k\\\\&amp;=\\sum_{1\\leq j\\leq n}(2^{n+1}-2^j)\\\\&amp;=n2^{n+1}-(2^{n+1}-2)\\\\&amp;=(n-1)2^{n+1}-2.\\end{aligned}$$ 2.15$$\\begin{aligned}\\sum_{k=1}^nk^3+\\sum_{k=1}^nk^2&amp;=2\\sum_{1\\leq j\\leq k\\leq n}jk\\\\\\sum_{k=1}^nk^3+\\sum_{k=1}^nk^2&amp;=\\left(\\sum_{1\\leq k\\leq n}k\\right)^2+\\sum_{1\\leq k\\leq n}k^2\\\\\\sum_{k=1}^nk^3&amp;=\\left(\\sum_{1\\leq k\\leq n}k\\right)^2\\\\\\sum_{k=1}^nk^3&amp;=n^2(n+1)^2/4.\\end{aligned}$$ 2.16If no denominator is zero, $$\\begin{aligned}x^{\\underline m}/(x-n)^{\\underline m}&amp;=x^{\\underline n}/(x-m)^{\\underline n}\\\\x^{\\underline m}(x-m)^{\\underline n}&amp;=x^{\\underline n}(x-n)^{\\underline m},\\end{aligned}$$ the latter is applicable to the law of exponents. 2.17$$\\begin{aligned}x^{\\overline m}&amp;=x(x+1)\\cdots(x+m-1)\\\\&amp;=(-1)^m(-x)(-x-1)\\cdots(-x-m+1)\\\\&amp;=(-1)^m(-x)^{\\underline m}.\\end{aligned}$$ $$\\begin{aligned}x^{\\overline m}&amp;=x(x+1)\\cdots(x+m-1)\\\\&amp;=(x+m-1)\\cdots(x+1)x\\\\&amp;=(x+m-1)^{\\underline m}.\\end{aligned}$$ $$\\begin{aligned}x^{\\overline m}&amp;=x(x+1)\\cdots(x+m-1)\\\\&amp;=1/(x-1)^{\\underline{-m}}.\\end{aligned}$$ The second line is similar. 2.18If $\\sum_{k\\in K}a_k$ is absolutely convergent, so are $\\sum_{k\\in K}(\\Re a_k)^+$, $\\sum_{k\\in K}(\\Re a_k)^-$, $\\sum_{k\\in K}(\\Im a_k)^+$ and $\\sum_{k\\in K}(\\Im a_k)^-$. For all finite subset $F\\subsetneq K$, there must be a bounding constant $B$ such that $$\\sum_{k\\in F}|a_k|\\leq\\sum_{k\\in F}\\big((\\Re a_k)^++(\\Re a_k)^-+(\\Im a_k)^++(\\Im a_k)^-\\big)\\leq B.$$ Conversely, with the fact that $(\\Re z)^+,(\\Re z)^-,(\\Im z)^+,(\\Im z)^-\\leq|z|$, we know that $\\sum_{k\\in K}(\\Re a_k)^+$, $\\sum_{k\\in K}(\\Re a_k)^-$, $\\sum_{k\\in K}(\\Im a_k)^+$ and $\\sum_{k\\in K}(\\Im a_k)^-$ are each absolutely convergent, so is $\\sum_{k\\in K}a_k$. Homework exercises2.19Multiply both sides by $2^{n-1}/n!$, we get $$\\begin{aligned}\\frac{2^n}{n!}T_n&amp;=\\frac{2^{n-1}}{(n-1)!}T_{n-1}+3\\cdot2^{n-1}\\\\T_n&amp;=\\frac{n!}{2^n}\\left(T_0+\\sum_{k=1}^n3\\cdot2^{n-1}\\right)\\\\T_n&amp;=3\\cdot n!+\\frac{n!}{2^{n-1}}.\\end{aligned}$$ 2.20$$\\begin{aligned}\\sum_{k=0}^nkH_k&amp;=\\sum_{k=0}^n\\big((k+1)H_{k+1}-(n+1)H_{n+1}\\big)\\\\\\sum_{k=0}^nkH_k&amp;=\\sum_{k=0}^nkH_{k+1}+\\sum_{k=0}^nH_{k+1}-(n+1)H_{n+1}\\\\(n+1)H_{n+1}&amp;=\\sum_{k=0}^n\\frac k{k+1}+\\sum_{k=0}^nH_{k+1}\\\\(n+1)H_{n+1}&amp;=\\sum_{k=0}^n(H_k+1)\\\\(n+1)(H_n-1)&amp;=\\sum_{k=0}^nH_k.\\end{aligned}$$ 2.21$$\\begin{aligned}\\sum_{k=0}^n(-1)^{n-k}&amp;=\\sum_{k=0}^n(-1)^{n-k-1}+(-1)^n+1\\\\2\\sum_{k=0}^n(-1)^{n-k}&amp;=(-1)^n+1\\\\S_n&amp;=\\begin{cases}1,&amp;\\text{$n$ is even;}\\\\0,&amp;\\text{$n$ is odd.}\\end{cases}\\end{aligned}$$ $$\\begin{aligned}\\sum_{k=0}^n(-1)^{n-k}k&amp;=\\sum_{k=0}^n-(-1)^{n-k}(k+1)+n+1\\\\2\\sum_{k=0}^n(-1)^{n-k}k&amp;=-\\sum_{k=0}^n(-1)^{n-k}+n+1\\\\2T_n&amp;=-S_n+n+1\\\\T_n&amp;=\\begin{cases}n/2,&amp;\\text{$n$ is even;}\\\\(n+1)/2,&amp;\\text{$n$ is odd.}\\end{cases}\\end{aligned}$$ If we did the first step for $T_n$ differently, we could find out that $\\sum_{k=0}^n(-1)^{n-k}(2k+1)=n+1$, which would be useful later. $$\\begin{aligned}\\sum_{k=0}^n(-1)^{n-k}k^2&amp;=\\sum_{k=0}^n-(-1)^{n-k}(k^2+2k+1)+n^2+2n+1\\\\2\\sum_{k=0}^n(-1)^{n-k}k^2&amp;=-\\sum_{k=0}^n(-1)^{n-k}(2k+1)+n^2+2n+1\\\\2\\sum_{k=0}^n(-1)^{n-k}k^2&amp;=n^2+n\\\\U_n&amp;=n(n+1)/2.\\end{aligned}$$ 2.22$$\\begin{aligned}&amp;\\sum_{1\\leq j\\lt k\\leq n}(a_jb_k-a_kb_j)(A_jB_k-A_kB_j)\\\\&amp;\\quad=\\sum_{1\\leq j\\lt k\\leq n}(a_jb_kA_jB_k+a_kb_jA_kB_j)-\\sum_{1\\leq j\\lt k\\leq n}(a_jb_kA_kB_j+a_kb_jA_jB_k)\\\\&amp;\\quad=\\sum_{1\\leq j,k\\leq n}a_jb_kA_jB_k-\\sum_{1\\leq k\\leq n}a_kb_kA_kB_k-\\sum_{1\\leq j,k\\leq n}a_jb_kA_kB_j+\\sum_{1\\leq k\\leq n}a_kb_kA_kB_k\\\\&amp;\\quad=\\sum_{1\\leq j,k\\leq n}a_jb_kA_jB_k-\\sum_{1\\leq j,k\\leq n}a_jb_kA_kB_j\\\\&amp;\\quad=\\left(\\sum_{k=1}^na_kA_k\\right)\\left(\\sum_{k=1}^nb_kB_k\\right)-\\left(\\sum_{k=1}^na_kB_k\\right)\\left(\\sum_{k=1}^nb_kA_k\\right).\\end{aligned}$$ 2.23a$$\\begin{aligned}\\sum_{k=1}^n\\frac{2k+1}{k(k+1)}&amp;=\\sum_{k=1}^n(2k+1)\\left(\\frac1{k}-\\frac1{k+1}\\right)\\\\&amp;=\\sum_{k=1}^n\\frac1k+\\sum_{k=1}^n\\frac1{k+1}\\\\&amp;=2H_n-\\frac n{n+1}.\\end{aligned}$$ 2.23bLet $u=2k+1$, then $\\Delta v=(k-1)^{\\underline{-2}}$, $\\Delta u=2$ and $v=-(k-1)^{\\underline{-1}}$. $$\\begin{aligned}\\sum_{k=1}^n\\frac{2k+1}{k(k+1)}&amp;=-\\frac{2k+1}k\\Bigg|_1^{n+1}+\\sum _{1\\leq k\\lt n+1}2k^{\\underline{-1}}\\\\&amp;=2H_n-\\frac n{n+1}.\\end{aligned}$$ 2.24Sum by parts to evaluate the general form $\\sum_{0\\leq k\\lt n}H_kk^{\\underline m}$, let $u=H_k$, then $\\Delta v=k^{\\underline m}$, $\\Delta u=k^{\\underline{-1}}$ and $v=k^{\\underline{m+1}}/(m+1)$. $$\\begin{aligned}\\sum_{0\\leq k\\lt n}H_kk^{\\underline m}&amp;=H_k\\frac{k^{\\underline{m+1}}}{m+1}\\Bigg|_0^n-\\sum _{0\\leq k\\lt n}\\frac{k^{\\underline m}}{(m+1)^2}\\\\&amp;=\\frac{0^{\\underline{m+1}}}{(m+1)^2}+\\left(\\frac{H_n}{m+1}-\\frac1{(m+1)^2}\\right).\\end{aligned}$$ In this case, we have $m=-2$, so the sum is $1-(H_n+1)/(n+1)$. 2.25$$\\begin{aligned}&amp;\\prod_{k\\in K}a_k^c=\\left(\\prod_{k\\in K}a_k\\right)^c;&amp;&amp;\\text{(distributive law)}\\\\&amp;\\prod_{k\\in K}a_kb_k=\\left(\\prod_{k\\in K}a_k\\right)\\left(\\prod_{k\\in K}b_k\\right);&amp;&amp;\\text{(associative law)}\\\\&amp;\\prod_{k\\in K}a_k=\\prod_{p(k)\\in K}a_{p(k)};&amp;&amp;\\text{(commutative law)}\\\\&amp;\\prod_{k\\in K}a_k=\\prod_ka_k^{[k\\in K]};&amp;&amp;\\text{(Iverson’s convention)}\\\\&amp;\\prod_{\\substack{j\\in J\\\\k\\in K}}a_{j,k}=\\prod_{j\\in J}\\prod_{k\\in K}a_{j,k};&amp;&amp;\\text{(interchanging the order)}\\\\&amp;\\prod_{\\substack{j\\in J\\\\k\\in K}}a_j^{b_k}=\\left(\\prod_{j\\in J}a_j\\right)^{\\sum_{k\\in K}b_k}.&amp;&amp;\\text{(general distributive law)}\\end{aligned}$$ 2.26$$\\begin{aligned}\\left(\\prod_{1\\leq j\\leq k\\leq n}a_ja_k\\right)^2&amp;=\\left(\\prod_{1\\leq j,k\\leq n}a_ja_k\\right)\\left(\\prod_{1\\leq j=k\\leq n}a_ja_k\\right)\\\\\\left(\\prod_{1\\leq j\\leq k\\leq n}a_ja_k\\right)^2&amp;=\\left(\\prod_{1\\leq k\\leq n}a_k\\right)^n\\left(\\prod_{1\\leq k\\leq n}a_k\\right)^n\\left(\\prod_{1\\leq k\\leq n}a_k^2\\right)\\\\\\prod_{1\\leq j\\leq k\\leq n}a_ja_k&amp;=\\left(\\prod_{1\\leq k\\leq n}a_k\\right)^{n+1}.\\end{aligned}$$ 2.27$$\\begin{aligned}\\Delta(c^{\\underline x})&amp;=c^{\\underline{x+1}}-c^{\\underline x}\\\\&amp;=(c-1)c^{\\underline x}-xc^{\\underline x}.\\end{aligned}$$ $$\\begin{aligned}\\sum_{k=1}^n\\frac{(-2)^{\\underline k}}k&amp;=\\sum_{1\\leq k\\lt n+1}(k+1)(-2)^{\\underline{k-2}}\\\\&amp;=\\sum_{1\\leq k\\lt n+1}(k-2)(-2)^{\\underline{k-2}}-(-3)(-2)^{\\underline{k-2}}\\\\&amp;=-(-2)^{\\underline{k-2}}\\Big|_{1}^{n+1}\\\\&amp;=(-1)^nn!-1.\\end{aligned}$$ 2.28From the second line to the third line, the interchange of summation is not justifiable. That’s because the terms in $$\\sum_{k\\geq1}\\sum_{j\\geq1}\\left(\\frac{k}j[j=k+1]-\\frac{j}k[j=k-1]\\right)$$ do not converge absolutely.","link":"/CM/exercises/2/"},{"title":"第一章 递归问题","text":"这一章通过汉诺塔、线段分割平面、约瑟夫问题这三个问题引入了递归问题的概念。它们都用到递归的思想，即一定规模的问题的解取决于同一个问题更小规模的解。 为了解决这类问题，一般需要这些步骤： 给问题中需要求解的量命名； 探究小规模的问题，并尝试得到它们的解； 找到所求量的数学表达式，并证明； 如果可以，找到解的封闭形式，并证明。 在汉诺塔中，首先将需要求解的，将 $n$ 个盘转移到另一根柱的最少一定次数命名为 $T_n$，显然有 $T_0=0$ 成立。 接下来，观察到需要先移动 $n-1$ 个盘，再移动最底下的盘，最后再移动 $n-1$ 个盘。据此可以得到，移动 $2T_{n-1}+1$ 次就足够了，即 $T_n\\leq2T_{n-1}+1$&hairsp;；为了得到等号，还需证明移动 $2T_{n-1}+1$ 次是必须的，即 $T_n\\geq2T_{n-1}+1$，证明过程这里略过。 顺带一提，在线段分割平面问题中也是先找到上限&hairsp;$(L_n\\leq L_{n-1}+n)$，再证明能够取到等号，有些像充分必要性的证明。 总之，这样一来，就得出了 $$\\begin{aligned}T_0&amp;=0;\\\\T_n&amp;=2T_{n-1}+1,\\quad\\text{for}\\;n&gt;0.\\end{aligned}$$ 这样的式子叫做递归式&hairsp;(recurrence)，由边界值和递归关系组成。为了方便有时只写出递归关系，尽管完整的式子是包含边界值的。 数学归纳法是一个用于证明某个关于整数 $n$ 的关系式的正确性的一般方法。首先是证明该关系式对某个 $n_0$ 成立，作为归纳基础&hairsp;(basis)&hairsp;；接着，在假定该关系式对于 $n_0$ 到 $n-1$ 的一切整数都成立的基础上，证明该关系式对于整数 $n$ 也成立，这称为归纳推理&hairsp;(induction)&hairsp;。 封闭形式的式子中，只包含 “经典的” 运算，加减乘除、乘方、阶乘等。例如 $1+2+\\cdots+n$ 不是封闭形式，因为它用 “$\\cdots$” 作弊；而 $n(n+1)/2$&hairsp;、$2^n-1$ 等都是封闭形式。 在推广约瑟夫问题时，我们需要求解 $$\\begin{aligned}f(1)&amp;=\\alpha;\\\\f(2n)&amp;=2f(n)+\\beta,\\quad\\text{for}\\;n\\geq1;\\\\f(2n+1)&amp;=2f(n)+\\gamma,\\quad\\text{for}\\;n\\geq1.\\end{aligned}$$ 可以将上式的解表示为 $f(n)=A(n)\\alpha+B(n)\\beta+C(n)\\gamma.\\quad(*)$ 于是我们引入成套方法&hairsp;(repertoire method)，它的本质是求解线性方程组。首先求出某些特殊情况的解，等攒够了特殊情况（有多少个未知函数就需要多少个特殊情况），再代入原式求解。 还是刚才的例子，选取这些特殊情况，分别是 $$\\begin{aligned}f(n)=2^m&amp;\\implies(\\alpha,\\beta,\\gamma)=(1,0,0);\\\\f(n)=1&amp;\\implies(\\alpha,\\beta,\\gamma)=(1,-1,-1);\\\\f(n)=n&amp;\\implies(\\alpha,\\beta,\\gamma)=(1,0,1).\\end{aligned}$$ 代入 $(*)$ 式可得到 $$\\begin{aligned}A(n)&amp;=2^m,\\quad\\text{where}\\;n=2^m+l\\;\\text{and}\\;0\\leq l&lt;2^m;\\\\A(n)-B(n)-C(n)&amp;=1;\\\\A(n)+C(n)&amp;=n.\\end{aligned}$$ 求出 $A(n)$&hairsp;、$B(n)$&hairsp;、$C(n)$ 后代入 $(*)$ 式，即可得解。","link":"/CM/notes/1/"},{"title":"Chapter 2 Sums","text":"2.1 NotationThe summation of an explicit sequence denoted as a succession of summations like $a_1+a_2+\\cdots+a_n$ can be written in the delimited form $\\sum_{k=1}^na_k$. Here, $a_k$ is called the summand, and $k$ is an index variable said to be bound to the summation. Summations can also be written in the general form like $\\sum_{1\\leq k\\leq n}a_k$, making it easier for manipulations such as substitution of index variables. 2.2 Sums and RecurrencesThere’s a neat relation between sums and recurrences. A sum like $$S_n=\\sum_{k=0}^na_k$$ is equivalent to the recurrence $$\\begin{aligned}S_0&amp;=a_0;\\\\S_n&amp;=S_{n-1}+a_n,\\quad\\text{for $n&gt;0$.}\\end{aligned}$$ Therefore we can evaluate a sum using methods of solving recurrences, such as the repertoire method we’ve learnt in Chapter 1. We developed a technique that can reduce any recurrence of the form $$a_nT_n=b_nT_{n-1}+c_n$$ to a sum, by multiplying both sides by a summation factor $s_n$, such that $s_nb_n=s_{b-1}a_{n-1}$. Then we can view $s_na_nT_n$ as a whole and go on. 2.3 Manipulation of SumsTo evaluate sums in closed form or to simplify sums, the key to success is the ability to change one summation into another under a few rules. Let $K$ be any finite set of integers. Sums over the elements of $K$ can be transformed by using these three rules: $$\\begin{aligned}\\sum_{k\\in K}{ca_k}&amp;=c\\sum_{k\\in K}{a_k};&amp;&amp;\\text{(distributive law)}\\\\\\sum_{k\\in K}(a_k+b_k)&amp;=\\sum_{k\\in K}a_k+\\sum_{k\\in K}b_k;&amp;&amp;\\text{(associative law)}\\\\\\sum_{k\\in K}a_k&amp;=\\sum_{p(k)\\in K}a_{p(k)}.&amp;&amp;\\text{(commutative law)}\\end{aligned}$$ The commutative law allows us to reorder terms. Here $p(k)$ is any permutation of the set of all integers. Actually, it’s a special case of a more generalized rule: Suppose there’s an arbitrary function $f:J\\to K$ that takes an integer $j\\in J$ into an integer $k\\in K$. The formula is $$\\sum_{j\\in J}a_{f(j)}=\\sum_{k\\in K}a_k\\#f^-(k),$$ where $\\#f^-(k)$ stands for the number of elements in the set $f^-(k)=\\big\\{j\\mid f(j)=k\\big\\}$. If $f$ is an one-to-one correspondence between $J$ and $K$, we have $\\#f^-(k)=1$ for all $k$, and the formula reduces to the commutative law. 2.4 Multiple SumsMultiple sums follow two additional rules: $$\\begin{aligned}\\sum_{P(j,k)}a_{j,k}&amp;=\\sum_j\\sum_ka_{j,k}\\big[P(j,k)\\big]=\\sum_k\\sum_ja_{j,k}\\big[P(j,k)\\big];&amp;&amp;\\text{(interchanging the order of summation)}\\\\\\sum_{\\substack{j\\in J\\\\k\\in K}}a_jb_k&amp;=\\left(\\sum_{j\\in J}a_j\\right)\\left(\\sum_{k\\in K}b_k\\right).&amp;&amp;\\text{(general distributive law)}\\end{aligned}$$ Another representation of the law of interchanging the order of summation is $$\\sum_{j\\in J}\\sum_{k\\in K(j)}a_{j,k}=\\sum_{k\\in K^\\prime}\\sum_{j\\in J^\\prime(k)}a_{j,k}.$$ Here the sets $J$, $K(j)$, $K^\\prime$ and $J^\\prime(k)$ must be related in such a way that $$[k\\in K]\\big[j\\in J(k)\\big]=[j\\in J^\\prime]\\big[k\\in K^\\prime(j)\\big].$$ It might be hard to understand at the first sight. But imagine that all items spread within a table like the one here: the left-hand side of the equation means for every $k$, sum up all items available in the $k$-th column, that is, all items in $J(k)$; the right-hand side is similar, $K^\\prime(j)$ is the set of all items available in the $j$-th row. 2.5 General MethodsMethod 0 is to look up. The authors suggested a few huge books for manual look ups. Fortunately, the on-line database OEIS is available; it is a more suitable tool than books for such knowledge. Method 1 is guessing then proving. Since guessing needs flashes of inspiration, this method do not always work, and proving should in fact be a complement for other methods that establish sums from scratch. Method 2 is the perturbation method. Perturb the sum a bit, then find relations between the perturbed sum and the original sum. Method 3 is the repertoire method. This method still needs intuition to determine what form the recursion should be. Method 4 uses infinite calculus to approximate the sum, then use other methods to compensate for the error terms. Method 5 is to clever rewrite of the original sum. This method requires even more intuition than the repertoire method does. Expand a single sum to multiple sums to simplify the summand. Method 6 is the topic of the next section. Method 7 will be introduced in later chapters. 2.6 Finite and Infinite CalculusJust like in calculus, we need a huge repertoire to evaluate sums effectively. Here are some useful formulas: $$\\begin{aligned}&amp;x^{\\underline{m+n}}=x^{\\underline m}(x-m)^{\\underline n};\\\\&amp;\\sum\\nolimits_a^bc^x\\delta x=\\frac{c^b-c^a}{c-1};\\\\&amp;\\sum\\nolimits_a^bx^{\\underline m}\\delta x=\\begin{cases}\\frac{x^{\\underline{m+1}}}{m+1}\\Big|_a^b,&amp;\\text{if $m\\neq-1$;}\\\\H_x\\Big|_a^b,&amp;\\text{if $m=-1$.}\\end{cases}\\end{aligned}$$ The relation of $\\Delta(uv)=u\\Delta v+{\\rm E}v\\Delta u$ yields the rule for summation by parts: $$\\sum u\\Delta v=uv-\\sum{\\rm E}v\\Delta u.$$ This rule is useful when $\\sum{\\rm E}v\\Delta u$ is easier to evaluate than the original one. 2.7 Infinite SumsIn this section, we proved the validity of the three basic laws for absolutely convergent sums. Make sure the sum converges absolutely before applying these rules.","link":"/CM/notes/2/"},{"title":"Chapter 3 Integer Functions","text":"3.1 Floors and Ceilings3.2 Floor/Ceiling Applications3.3 Floor/Ceiling Recurrences “In trying to devise a proof by mathematical induction, you may fail for two opposite reasons. You may fail because you try to prove too much: Your $P(n)$ is too heavy a burden. Yet you may also fail because you try to prove too little: Your $P(n)$ is too weak a support. In general, you have to balance the statement of your theorem so that the support is just enough for the burden.”—&hairsp;George Pólya, Induction and Analogy in Mathematics 3.4 ‘MOD’: The Binary Operation3.5 Floor/Ceiling Sums","link":"/CM/notes/3/"},{"title":"Chapter 1 Functional Programming in Coq","text":"Data and FunctionsCoq’s set of built-in features is extremely small, we could define new data-types from scratch ourselves. Every expression in Coq has a type, describing what sort of thing it computes. Coq allows us to create data-types by explicitly enumerating a finite set of elements, called constructors. Constructor expressions are formed by applying to a constructor zero or more other constructor expressions. To test the correctness of a function, we check that it works on some examples. We could (1) use Compute to evaluate an expression, (2) use Example with the expected result given, then prove by tactics, (3) extract the function to another language like Haskell. Use Fixpoint when having to use the data-type definition itself in its constructors. Use Notation to introduce our own notations; we could make several annotations to control how these notations are treated by Coq’s parser, for example associativity and scope. Proof by SimplificationAlthough reflexivity does more simplifications than simpl, we sometimes need simpl to read and understand the new goal it creates, so as to not leaving the goal in a messy state. Use intros tactic to introduce a quantifier in the goals to context of current assumptions. If the quantifier is $\\forall n:\\mathbb{N}$, intros n is like saying “Suppose $n$ is some number…” Proof by RewritingThe intros tactic also allows us to introduce the hypothesis to current assumptions. If the hypothesis is an equality, we could replace one side of the equality with another. When writing long proofs, its desirable to use Admitted to temporarily accept a subsidiary lemma; then we can go back and fill in the proofs. Proof by Case AnalysisThe destruct tactic can be used with any inductively defined data-type; this tactic would separate the original goal into several subgoals, amounting to the number of constructors of the data-type. Using this tactic, we could annotate variable names using intro pattern, separating lists of names by | and give name to subgoal equations using the eqn: qualifier. The bullets mark the parts of the proof correspond to subgoals, preventing proofs for different subgoals from getting mixed up.","link":"/SF-LF/notes/1/"},{"title":"Chapter 2 Proof by Induction","text":"Proof by InductionThe destruct tactic could push the proof one step further, but it won’t work in some cases. Proof by induction is useful when we want to prove that some property holds for all the members of an infinite set, such natural numbers, as well as lists, trees, and other data-types. In Coq, we use induction beginning with a goal of proving the proposition $P(n)$ for all $n$ and break it down into separate subgoals, each having its own inductive hypothesis. Proofs Within ProofsSometimes a proof requires trivial facts that are too small to separate as lemmas. We could use assert tactic to list and prove these facts. This tactic also helps in complex rewriting, for example, when plus_comm applies to contents in both parentheses, we could specify which part to rewrite: Theorem plus_rearrange : ∀ n m p q : ℕ, (n + m) + (p + q) = (m + n) + (p + q). Proof. intros n m p q. assert (H: n + m = m + n). { rewrite → plus_comm. reflexivity. } rewrite → H. reflexivity. Qed. Formal vs. Informal ProofA proof of a mathematical proposition $P$ is a written or spoken text that convinces someone that $P$ is true. Coq is like a “reader” of such text (proof), and the proof guides the program to check if $P$ could be derived from certain rules. Such proofs are formal proofs. Formal proofs are explicit in some way, such as what tactics are used, but less explicit in other ways, such as the “proof state” at given point in proof.","link":"/SF-LF/notes/2/"},{"title":"Chapter 3 Working with Structured Data","text":"Pairs of NumbersIn an Inductive type definition, each constructor can take zero or more arguments. When applied to pattern matching, each constructor could be destructed back into parts. Lists of NumbersGeneralizing the definition of pairs, we notice that a list of numbers is either an empty list or a pair of a number and another list, much like a natural number is either zero or the successor of another natural number. We could tell Coq how to parenthesize expressions involving multiple uses of binary operators using Notation. For example, this statement… Notation &quot;[ x ; .. ; y ]&quot; := (cons x .. (cons y nil) ..). …gives an expression like 1 :: 2 :: 3 :: nil a clear meaning. Reasoning About ListsTo prove a proposition $P(l)$ that holds for all lists $l$, we could reason as follows: First, show $P(l)$ is true if $l$ is nil. Then show that $P(l)$ is true when $l$ is a pair of some number $n$ and some smaller list $l’$, assuming $P(l’)$ is true. This strategy works because larger lists can always be broken down into smaller ones, eventually reaching nil. We could use Search command to search for theorems, using wildcards like (_ + _ = _ + _), or using (?x + ?y = ?y + ?x) if we want a more precise search. OptionsSometimes, an operation is not valid, such as taking the first element out of an empty list; in such cases, we could create a new data-type “wrapping around” the original type T, with two constructors Some T and None, together with a function for unwrapping. Coq doesn’t have a built-in boolean type, any inductive type defined with exactly two constructors are considered a boolean; the guard is considered true if it evaluates to the first constructor and false if it evaluates to the second. Partial MapsPartial maps are constructed similar to lists, with an “empty” constructor and the other constructor taking an id, a value, and the rest of the partial map (also a partial map). Updating a partial map can be achieved by simply adding a record to the front; the new record shadows the original one.","link":"/SF-LF/notes/3/"},{"title":"Chapter 4 Polymorphism and Higher-Order Functions","text":"The new ideas in this chapter are polymorphism (abstracting functions over the types of the data they manipulate) and higher-order functions (treating functions as data). PolymorphismIn order to create data-types that build on different types but are similar in structure, for example, another list structure for booleans instead of natural numbers, we can define a data-type with types as arguments. Coq is able to do type inference to deduce types that are not explicitly stated. But don’t rely too much on this mechanism, as explicit type annotations can serve as good documentation for your code. The syntax of Coq is flexible enough that we can enable type inference with Arguments statements and disable it with a @ prefix. When using polymorphic pairs, note that the common symbol for the type of a pair (x,y) is X×Y, that is “the product type of X and Y.” Functions as DataCoq treats functions as first-class citizens, that is, functions can be passed as arguments to other functions, returned as results, stored in data structures, etc. Functions that manipulate other functions are called higher-order functions; some examples are filter, map, and fold.","link":"/SF-LF/notes/4/"},{"title":"Chapter 5 More Basic Tactics","text":"The apply TacticThe apply tactic uses implications to transform goals and hypotheses. When apply-ing a lemma to the goal, Coq will match the goal against the conclusion of the lemma, try to instantiate unknown variables, and replace the goal with the premises of the lemma. The apply with TacticSometimes apply cannot instantiate all unknown variables, we need to manually determine variables in the lemma by using apply with. The injection and discriminate TacticsThe principle of explosion states that a contradictory hypothesis entails anything, even false things. All constructors of a data-type are injective. We use injection to “undo” one application of the constructor. Any two constructors of a data-type are disjoint, and no two terms beginning with different constructors can be equal. Use discriminate on hypotheses involving such inequalities to solve the goal. Using Tactics on HypothesesMost tactics in Coq work on the goal and leave the context unchanged. However, we could perform a tactic on a statement in the context, by using the in qualifier. The informal proofs tend to use forward reasoning, while the idiomatic use of Coq favors backward reasoning. Varying the Induction HypothesisBe careful which of the universally quantified variables to introduce before starting the induction. It is crucial to leave some variables generic. Hypotheses that are too specific are weak: we may end up with a goal which the induction hypothesis is not generic enough to apply to. Use generalize dependent to put an argument back to goal. Unfolding DefinitionsCoq does definition unfolding automatically, but it is also conservative and we sometimes need to unfold the definitions manually using unfold. Using destruct on Compound ExpressionsWhen using destruct on compound expression, we need to retain the equality by adding the eqn: qualifier.","link":"/SF-LF/notes/5/"},{"title":"Chapter 6 Logic in Coq","text":"All syntactically well-formed propositions in Coq have type Prop in Coq. Propositions are not necessarily provable. Functions that return propositions are called parameterized propositions; they define properties of their arguments. Logical ConnectivesFor a conjunction, we use split to separate it and prove each of them if it appears in the goal, but use destruct if it appears in the hypothesis. For a disjunction, we use left or right to prove only one branch if it appears in the goal, but use destruct to separate them into branches and prove the goal with each branch taken as the premise. ¬ P is a representation of to P → False. Anything can follow from False; this rule is called ex falso quodlibet, or the principle of explosion. If the goal is controversial, we can use this rule by the exfalso tactic, turning the goal into False. The “if and only if” connective is reflexive, symmetric, and transitive; it is an equivalence relation. This means we can use reflexivity, symmetry, and rewrite on “↔” connected propositions, like on equations. To prove a statement containing an existential quantification, we find a value that witnesses the existential. Programming with PropositionsWe can define propositions recursively, but this method is limited by Coq’s requirements for functions, for example, “obviously terminating.” We can also define propositions inductively. Applying Theorems to ArgumentsCoq treats proofs as first-class objects. The type of a proof is the proposition which it is a proof of. We can apply theorems to statements like applying a function; they have the same inference mechanism. Coq vs. Set TheoryIn Coq, we say that a property holds for a mathematical object, not that a mathematical object belongs to some set. This is because Coq’s logical core is the Calculus of Inductive Constructions, instead of set theory (e.g. Zermelo–Fraenkel Set Theory). Coq’s equality operator is polymorphic, we can use it to claim that two functions are equal. It is common to consider two functions the same if we observe the same behavior from them: (∀ x, f x = g x) → f = g This is the principle of functional extensionality, we can define it as an axiom in Coq. Sometimes adding an axiom to Coq can break consistency, that is, we may be able to prove every proposition. Coq’s language is computational, every function it can express is computable and total. Coq doesn’t have an operation to do case analyses on propositions, since allowing such operation would allow non-computable functions. Many computable properties are easier to express using propositions rather than booleans, since recursive function definitions in Coq are subject to significant restrictions. If a boolean function gives true if and only if a proposition holds, we say that the boolean computation is reflected in the truth of the proposition. We could exploit boolean computation to prove propositions; this technique is known as proof by reflection. Logics that do not assume the excluded middle are referred to as constructive logics. Every proof of existence in such logics are constructive. Although constructive logic is useful, constructive proofs of many statements are complicated. What’s worse, some statements only have non-constructive proofs.","link":"/SF-LF/notes/6/"},{"title":"Chapter 7 Inductively Defined Propositions","text":"Inductively Defined PropositionsWe can establish propositions inductively by writing inference rules. By applying these rules we could proceed a proof by breaking the proposition down into sub-cases. Since an inference rule may contain several premises, applying inference rules is like building up a tree structure. Theorems and constructors of inductively defined propositions are evidences. The type of an evidence is the proposition it is a proof of. When a function or a proposition is defined, its type may read like ℕ → ℙ. Here, ℕ is an index or annotation, meaning it accepts a natural number as the parameter. Using Evidence in ProofsWe can use destruct on an evidence to “invert” it to reason about all the different ways it could have been derived. The inversion tactic behaves like destruct, and it automatically rejects sub-goals that are contradictory. The induction tactic behaves like destruct, and in each case, it provides an inductive hypothesis for each generated object, saying that the property holds true for it. Inductive RelationsA proposition parameterized by a single object is said to define a property of that object. A proposition parameterized by more than one parameters is thought of defining a relation between the parameters. Case Study: Regular ExpressionsIf we perform an induction over an evidence term that is not general enough, using the induction tactic on it would lose information. This is because induction doesn’t have the ability like inversion to reject contradictory goals automatically. We can use the remember tactic to make an evidence more general, and do some discriminations manually. Case Study: Improving ReflectionWe can define a relation between booleans and proposition like… Inductive reflect (P : Prop) : 𝔹 → ℙ := | ReflectT (H : P) : reflect P true | ReflectF (H : ¬ P) : reflect P false. …which says the a boolean is reflected in a proposition. When doing case analysis on a boolean, applying this relation to the boolean amounts to stating its corresponding proposition holds or not holds. Additional ExercisesAn intriguing exercise is palindrome_converse, which says l = rev l → pal l. The intuition is to perform induction on l. But the induction tactic would not suffice, since the remaining part of a palindrome taken the head away is clearly not again a palindrome, and we cannot prove pal for it. We have to define our own induction principle, taking one element from the head and tail from a list simultaneously. The principle can be defined like… ∀ X (P : list X → ℙ), P [] → (∀ x, P [x]) → (∀ x1 x2 l, P l → P (x1 :: l ++ [x2])) → ∀ l, P l. …which can be proved by showing… ∀ l (P : list X → ℙ) n, n = length l → P l. …and… ∀ (P : ℕ → ℙ), P 0 → P 1 → (∀ n, P n → P (S (S n))) → ∀ n, P n. This is like putting lists of the same length into the same “group”, and treat the groups like natural numbers. To show that a property holds for all lists, we only need to prove that it holds for all lists of any group. If we denote a “group” of lists of length $n$ as $G_n$ and the property as $P$, the latter can be showed by proving that the property hold for all lists of length $0$ or $1$, and that $$\\forall i,(\\forall l, l\\in G_i\\to P(l))\\to\\forall l, l\\in G_{i+2}\\to P(l).$$","link":"/SF-LF/notes/7/"},{"title":"Chapter 8 Total and Partial Maps","text":"The sumbool TypeObjects of the type sumbool written like {A} + {B}, is either a proof of A or a proof of B. They can be thought of “evidence-carrying booleans.” If we are able prove ∀ (a b : T), {a = b} + {a ≠ b}, we say that equality is decidable between objects of type T. Notations in CoqIn Coq, we can use Notation to modify the behavior of the parser, to provide abbreviations of terms. The notation (the string after Notation) consists of tokens separated by spaces. Tokens which are identifiers (such as “A”, “x0”) are the parameters of the notation. Each of them must occur at least once in the abbreviated term. The other elements of the string (such as “/”) are the symbols. In some cases, for example in &quot;'IF' c1 'then' c2 'else' c3”, groups of characters must be quoted to be treated as symbols. To avoid ambiguities in expressions like A ∧ B ∨ A ∨ C, we use syntax modifiers. We can fix this example by specifying precedence and associativity like (at level .., right associativity). Sometimes we need to parse expressions like x !-&gt; v ; m and to parse subexpressions (x !-&gt; v and v ; m) differently from when they are used separately. In this case, we must sometimes specify at next level like in… Notation &quot;x !-&gt; v ; m&quot; := (t_update m x v) (at level 100, v at next level, right associativity). …but currently I have no idea of what’s happening. Coq uses Camlp5 as its parser, which is an LL(1) parser. I’ll try to explain this after figuring out how LL(1) parsers work. Total Maps and Partial MapsWe can use functions rather than lists of key-value pairs to build maps. This will give us a more extensional view of maps. Since partial maps are just total maps (with None as the default value), basic lemmas about total maps can easily be lift to fit partial maps.","link":"/SF-LF/notes/8/"},{"title":"1.1 程序设计的基本元素","text":"Exercise 1.110, 12, 8, 3, 6, a, b, 19, #f, 4, 16, 6, 16 Exercise 1.2(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5))))) (* 3 (- 6 2) (- 2 7))) Exercise 1.3(define (square a) (* a a)) (define (square-sum a b) (+ (square a) (square b))) (define (square-sum-of-two-larger-numbers a b c) (cond ((not (or (&gt; a b) (&gt; a c))) (square-sum b c)) ((not (or (&gt; b a) (&gt; b c))) (square-sum a c)) (else (square-sum a b)))) Exercise 1.4若 b 为正数，求出 (+ a b) 的值，否则求出 (- a b) 的值。 Exercise 1.5正则序求值： (test 0 (p)) (if (= 0 0) 0 (p)) 0 应用序求值： (test 0 (p)) (if (= 0 0) 0 (p)) (if (= 0 0) 0 (p)) (if (= 0 0) 0 (p)) ... 应用序求值时，先要展开所有表达式。表达式 (p) 展开后仍是 (p)，所以应用序求值的方式无法对该式求值。 Exercise 1.6求不出表达式的值。new-if 不是特殊形式，意味着它是一个一般的过程，使用应用序求值。sqrt-iter 过程展开后永远包含另一个 sqrt-iter 过程，编译器会无休止地将展开重复下去。 Exercise 1.7例如 (sqrt 0.00000001) 应当算出 $0.0001$，实际得到的是 $0.031250$ 左右，但是符合 good-enough? 的条件；再比如 (sqrt 20000000000000000)，估值一直停留在 $141421356.237309$ 左右，足够精确却达不到 good-enough? 的条件。 将 good-enough? 的定义改为以下，可以改进程序： (define (good-enough? guess x) (&lt; (abs (- (square guess) x)) (* guess 0.001))) Exercise 1.8(define (cube x) (* x x x)) (define (good-enuf? guess x) (&lt; (abs (- (cube guess) x)) (* guess 0.001))) (define (improve guess x) (/ (+ (/ x (* guess guess)) (* guess 2)) 3)) (define (cbrt-iter guess x) (if (good-enuf? guess x) guess (cbrt-iter (improve guess x) x))) (define (cbrt x) (cbrt-iter 1.0 x))","link":"/SICP/exercises/1-1/"},{"title":"1.2 过程与它们所产生的计算","text":"Exercise 1.9情形一，递归计算 (+ 4 5) (inc (+ (dec 4) 5)) (inc (inc (+ (dec 3) 5))) (inc (inc (inc (+ (dec 2) 5)))) (inc (inc (inc (inc (+ (dec 1) 5))))) (inc (inc (inc (inc (+ 0 5))))) (inc (inc (inc (inc 5)))) (inc (inc (inc 6))) (inc (inc 7)) (inc 8) 9 情形二，迭代计算 (+ 4 5) (+ 3 6) (+ 2 7) (+ 1 8) (+ 0 9) 9 Exercise 1.101024, 65536, 65536 $f(n)=2n$$g(n)=2^n$$h(n)=2^{2^{2^{\\cdot^{\\cdot^\\cdot}}}}(\\text{共有}\\,n\\,\\text{个}\\,2)$ Exercise 1.11递归计算 (define (f n) (if (&lt; n 3) n (+ (f (- n 1)) (f (- n 2)) (f (- n 3))))) 迭代计算 (define (f-iter n) (define (f-impl n a b c) (if (= n 0) a (f-impl (- n 1) b c (+ a b c)))) (f-impl n 0 1 2)) Exercise 1.12(define (pascal row col) (if (or (= col 0) (= row col)) 1 (+ (pascal (- row 1) (- col 1)) (pascal (- row 1) col)))) Exercise 1.13首先，从 Fibonacci 的定义开始： $${\\rm Fib}(n)={\\rm Fib}(n-1)+{\\rm Fib}(n-2)$$ 若假设成立，则将 ${\\rm Fib}(n)=\\frac{\\phi^n-\\psi^n}{\\sqrt5}$ 代入式中，得出： $$\\begin{aligned}\\frac{\\phi^n-\\psi^n}{\\sqrt5}=\\frac{\\phi^{n-1}-\\psi^{n-1}}{\\sqrt5}+\\frac{\\phi^{n-2}-\\psi^{n-2}}{\\sqrt5}\\\\\\phi^n-\\psi^n=\\phi^n\\left(\\frac1\\phi+\\frac1{\\phi^2}\\right)-\\psi^n\\left(\\frac1\\psi+\\frac1{\\psi^2}\\right)\\end{aligned}$$ 由 $\\phi=\\frac{1+\\sqrt5}{2}$ 和 $\\psi=\\frac{1-\\sqrt5}{2}$ 可知： $$\\frac1\\phi+\\frac1{\\phi^2}=1,\\;\\frac1\\psi+\\frac1{\\psi^2}=1$$ 代回上式，算式左右两边相等，所以假设成立。接下来将其拆开： $$\\begin{aligned}{\\rm Fib}(n)=\\frac{\\phi^n-\\psi^n}{\\sqrt5}=\\frac{\\phi^n}{\\sqrt5}-\\frac{\\psi^n}{\\sqrt5}\\\\\\frac{\\phi^n}{\\sqrt5}={\\rm Fib}(n)+\\frac{\\psi^n}{\\sqrt5}\\end{aligned}$$ 要证明 ${\\rm Fib}(n)$ 是与 $\\frac{\\phi^n}{\\sqrt5}$ 最接近的整数，只需证明 $\\left|\\frac{\\psi^n}{\\sqrt5}\\right|&lt;\\frac1{2}$ 对于一切非负整数 $n$ 成立： 首先，归纳基础 $\\left|\\frac{\\psi^0}{\\sqrt5}\\right|\\approx0.447&lt;\\frac1{2}$ 成立。 假设 $\\left|\\frac{\\psi^{n-1}}{\\sqrt5}\\right|&lt;\\frac1{2}$ 成立，而 $\\left|\\frac{\\psi^n}{\\sqrt5}\\right|=\\left|\\frac{\\psi^{n-1}}{\\sqrt5}\\right|\\cdot|\\psi|$&hairsp;。因为 $|\\psi|&lt;1$，所以 $\\left|\\frac{\\psi^n}{\\sqrt5}\\right|&lt;\\left|\\frac{\\psi^{n-1}}{\\sqrt5}\\right|&lt;\\frac1{2}$&hairsp;。所以 $\\left|\\frac{\\psi^n}{\\sqrt5}\\right|&lt;\\frac1{2}$ 对于一切非负整数 $n$ 成立。 所以 ${\\rm Fib}(n)$ 是与 $\\frac{\\phi^n}{\\sqrt5}$ 最接近的整数，证毕。 Exercise 1.14递归过程中只需要记录该节点之上的节点信息，所以需要的空间与调用树的最大深度成正比。 (cc amount kinds) 节点包含着种类数不变而零钱量减少某个常数的节点，其以下部分的最大深度显然与 amount 成正比，所以空间为 $\\Theta(n)$&hairsp;。 考虑 (cc n 0) 的情况，由于是叶子节点，所需时间为 $\\Theta(1)$&hairsp;；再看 (cc n 1) 的情况，其下方有一条像链一样连接着的，从 (cc (- n 1) 1) 直至 (cc 0 1) 的 $n$ 个节点，而这些节点又额外地包含了一个形如 (cc x 0)&hairsp;、所需时间为 $\\Theta(1)$ 的节点。所以这时的所需时间为 $\\Theta(n)$&hairsp;；接下来，(cc n 2)&hairsp;、(cc n 3) 等的情况，可以仿照 (cc n 1) 的情况来分析，kinds 每增加 $1$，所需时间就得 “乘上一个 $n$”。 综上所述，有 $k$ 种货币时，时间为 $\\Theta(n^k)$&hairsp;。 Exercise 1.15a. p 被调用了 $5$ 次。b. 空间增长为 $\\Theta(\\log n)$ 阶，时间增长也为 $\\Theta(\\log n)$ 阶。 Exercide 1.16(define (fast-expt b n) (define (fast-expt-impl ans tmp m) (if (= m 0) ans (if (even? m) (fast-expt-impl ans (square tmp) (/ m 2)) (fast-expt-impl (* ans tmp) tmp (- m 1))))) (fast-expt-impl 1 b n)) Exercise 1.17(define (double x) (+ x x)) (define (halve x) (/ x 2)) (define (mul a b) (if (= b 0) 0 (if (even? b) (mul (double a) (halve b)) (+ a (mul a (- b 1)))))) Exercise 1.18(define (double x) (+ x x)) (define (halve x) (/ x 2)) (define (mul a b) (define (mul-impl ans tmp m) (if (= m 0) ans (if (even? m) (mul-impl ans (double tmp) (halve m)) (mul-impl (+ ans tmp) tmp (- m 1))))) (mul-impl 0 a b)) Exercise 1.19(define (fib n) (fib-iter 1 0 0 1 n)) (define (fib-iter a b p q count) (cond ((= count 0) b) ((even? count) (fib-iter a b (+ (* p p) (* q q)) (+ (* q q) (* p q 2)) (/ count 2))) (else (fib-iter (+ (* b q) (* a q) (* a p)) (+ (* b p) (* a q)) p q (- count 1))))) Exercise 1.20应用序求值 (gcd 206 40) (gcd 40 (remainder 206 40)) (gcd 6 (remainder 40 6)) (gcd 4 (remainder 6 4)) (gcd 2 (remainder 4 2)) (gcd 2 0) 2 remainder 一共被调用了 $4$ 次。 正则序求值 (gcd 206 40) (if (= 40 0) ...) (gcd 40 (remainder 206 40)) (if (= (remainder 206 40) 0) ...) (if (= 6 0) ...) (gcd (remainder 206 40) (remainder 40 (remainder 206 40))) (if (= (remainder 40 (remainder 206 40)) 0) ...) (if (= 4 0) ...) (gcd (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) (if (= (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) 0) ...) (if (= 2 0) ...) (gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))) (if (= (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) 0) ...) (if (= 0 0) ...) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) 2 remainder 一共被调用了 $18$ 次：$14$ 次用在条件判断中，$4$ 次用在最后的计算中。 正则序求值最后用于计算的调用次数，等于应用序求值的总调用次数。接下来只需要分析用于条件判断的调用次数。 将第 $n$ 条 if 表达式的条件部分中 remainder 的出现次数记作 $f(n)$，可以发现 $$\\begin{aligned}f(0)&amp;=0,\\;f(1)=1\\\\f(n)&amp;=f(n-1)+f(n-2)+1\\end{aligned}$$ 稍加推导，可以发现 $$\\begin{aligned}f(n)-f(n-1)&amp;={\\rm Fib}(n)\\\\f(n)&amp;=\\sum_{i=0}^n{\\rm Fib}(i)\\\\f(n)&amp;={\\rm Fib}(n+2)-1\\end{aligned}$$ 设 remainder 在应用序求值中的总调用次数为 $n$，在正则序求值中的总调用次数为 ${\\rm R}(n)$，可以得出 $$\\begin{aligned}{\\rm R}(n)&amp;=n+\\sum_{i=0}^nf(i)\\\\{\\rm R}(n)&amp;={\\rm Fib}(n+4)-3\\end{aligned}$$ 本题中 ${\\rm R}(4)=18$，由此可以看出正则序求值可能造成大量的冗余计算。 Exercise 1.21199, 1999, 7 Exercise 1.22不得不吐槽书中的程序，实在不好用，所以自己重写了一个，正好后面几题也用得到： (define (report-time start-time) (display (- (runtime) start-time)) (newline)) (define (conditional-time-report pred-proc p1) (define (timer start-time) (cond ((pred-proc p1) (report-time start-time) #t) (else #f))) (timer (runtime))) (define (search-for-primes num cnt) (if (&gt; cnt 0) (if (conditional-time-report prime? num) (search-for-primes (+ num 2) (- cnt 1)) (search-for-primes (+ num 2) cnt)))) (search-for-primes &lt;an odd number to start with&gt; &lt;how many prime numbers before stop&gt;) $n$ 每增加 $4$ 倍，运行时间大约增加 $2$ 倍，这可以粗略地验证该算法的增长阶为 $\\Theta(\\sqrt n)$&hairsp;。 Exercise 1.23时间大约是原来的一半多一些：一半因为要测试的数减少了约一半，多一些是因为一个额外的 if 语句。 Exercise 1.24增长得比预期更快。这是因为，基本操作的所需时间，会随着数字规模的增大而增加的。而这时，我们得出增长阶为 $\\Theta(\\log n)$ 的假设——基本操作需要常数时间——失效了。 Exercise 1.25对是对，但这样做会产生巨大的中间数，从而需要大量时间来处理大数。 Exercise 1.26用两次递归调用代替了原来的平方，现在的 expmod 呈现树形递归，计算树形递归的所需时间根据树高呈指数增长。这里树高为 $\\log(n)$，那么增长阶为 $\\Theta(e^{\\log n})=\\Theta(n)$&hairsp;。 Exercise 1.27(define (full-fermat-test n) (define (test-it a) (= (expmod a n n) a)) (define (test-impl m) (cond ((= m n) #t) ((test-it m) (test-impl (+ m 1))) (else #f))) (test-impl 1)) (full-fermat-test 561) (full-fermat-test 1105) (full-fermat-test 1729) ... (prime? 561) (prime? 1105) (prime? 1729) ... 用 prime? 确定它们都不是素数，但 “骗过” 了所有费马测试。 Exercise 1.28这题有些难度，用到了一个结论：若存在 $1\\lt a\\lt n-1$，使得 $a^2\\equiv 1\\;({\\rm mod}\\;n)$ 成立，则 $n$ 不是素数。 证明这个结论，需要证明若 $n$ 是素数，则 $x_1=1,x_2=n-1$ 是 $x^2\\equiv1\\;({\\rm mod}\\;n)$ 仅有的两个解： $$\\begin{aligned}\\begin{aligned}x^2&amp;\\equiv1\\;({\\rm mod}\\;n)\\\\x^2-1&amp;\\equiv0\\;({\\rm mod}\\;n)\\\\(x-1)(x+1)&amp;\\equiv0\\;({\\rm mod}\\;n)\\end{aligned}\\\\\\begin{aligned}&amp;\\therefore n\\mid(x-1)\\;\\text{或}\\;n\\mid(x+1)\\\\&amp;\\because n\\;\\text{是素数}\\;\\therefore(x-1)\\;\\text{或}\\;(x+1)\\;\\text{是}\\;n\\;\\text{的倍数}\\\\&amp;\\therefore x_1=1,x_2=n-1\\end{aligned}\\end{aligned}$$ 若 $1\\lt a\\lt n-1$ 是其解，则称 $a$ 为 $n$ 的 非平凡平方根&hairsp;$($$\\textit{nontrivial square root}$$)$&hairsp;。若 $n$ 有非平凡平方根，则其不是素数。 这题用到了另一个技巧，修改了 expmod 过程，使其在找到非平凡平方根后返回 $0$&hairsp;。这样一来，一旦过程中出现非平凡平方根，整个 expmod 的值将是 $0$，便于之后的判断。为了理解这一点，我整理了$\\text{Miller–Rabin}$素性测试的原理及实现。 (define (square x) (* x x)) (define (miller-rabin-expmod base ex n) (define (squaremod-with-check x) (define (check squaremod-x) (if (and (= squaremod-x 1) (not (= x 1)) (not (= x (- n 1)))) 0 squaremod-x)) (check (remainder (* x x) n))) (cond ((= ex 0) 1) ((even? ex) (squaremod-with-check (miller-rabin-expmod base (/ ex 2) n))) (else (remainder (* base (miller-rabin-expmod base (- ex 1) n)) n)))) (define (miller-rabin-test n rounds) (define (test-it a) (define (test-impl expmod-a) (= expmod-a 1)) (test-impl (miller-rabin-expmod a (- n 1) n))) (cond ((= rounds 0) #t) ((test-it (+ 1 (random (- n 1)))) (miller-rabin-test n (- rounds 1))) (else #f)))","link":"/SICP/exercises/1-2/"},{"title":"1.3 用高阶函数做抽象","text":"Exercise 1.29为了避免 h 被重复求值多次，我在最外层定义了一个 h-equals，也就是将已经求出的值绑定给了 h&hairsp;。这就有点像赋值操作了，而函数式编程范式一个重要的特点却是 “无状态性”。是不是偏离了原本的意图呢？有些费解。 (define (simpson f a b n) (define (h-equals h) (define (term k) (define (coef k) (cond ((or (= k 0) (= k n)) 1) ((even? k) 2) (else 4))) (* (coef k) (f (+ a (* k h))))) (define (next k) (+ k 1)) (* (sum term 0 next n) (/ h 3))) (h-equals (/ (- b a) n))) Exercise 1.30(define (sum term a next b) (define (iter a result) (if (&gt; a b) result (iter (next a) (+ result (term a))))) (iter a 0)) Exercise 1.31这里为了方便，pi-approx 将两项合并为一项来计算了，大概不算犯规吧。 (define (square x) (* x x)) (define (product term a next b) (define (iter a result) (if (&gt; a b) result (iter (next a) (* result (term a))))) (iter a 1)) (define (factorial n) (define (self x) x) (define (next x) (+ x 1)) (product self 1 next n)) (define (pi-approx n) (define (term x) (* (/ (* (+ 2 (* x 2)) (+ 4 (* x 2))) (square (+ 3 (* x 2)))) 1.0)) (define (next x) (+ x 1)) (* (product term 0 next n) 4)) Exercise 1.32(define (accumulate combiner null-value term a next b) (if (&gt; a b) null-value (combiner (term a) (accumulate combiner null-value term (next a) next b)))) (define (accumulate-iter combiner null-value term a next b) (define (iter a result) (if (&gt; a b) result (iter (next a) (combiner (term a) result)))) (iter a null-value)) Exercise 1.33(define (filtered-accumulate filter combiner null-value term a next b) (define (iter a result) (if (&gt; a b) result (if (filter a) (iter (next a) (combiner (term a) result)) (iter (next a) result)))) (iter a null-value)) (define (coprime? a b) (= (gcd a b) 1)) (define (sum-primes a b) (define (next x) (+ x 1)) (filtered-accumulate prime? + 0 square a next b)) (define (sum-coprimes n) (define (coprime-with-n? x) (coprime? n x)) (define (next x) (+ x 1)) (define (self x) x) (filtered-accumulate coprime-with-n? + 0 self 1 next (- n 1))) Exercise 1.34演变过程是这样的： (f f) (f 2) (2 2) 对 (2 2) 求值就会出错，本来应该放置过程的位置是 2，而它不是一个过程。 Exercise 1.35(define golden-ratio (fixed-point (lambda (x) (+ 1.0 (/ 1.0 x))) 1.0)) 正确地逼近了黄金分割比例的值。 Exercise 1.36(define (root-x-pow-x start-point) (fixed-point (lambda (x) (/ (log 1000) (log x))) start-point 0)) (define (root-x-pow-x-with-damp start-point) (define (damp-func x) (/ (+ x (/ (log 1000) (log x))) 2.0)) (fixed-point damp-func start-point 0)) (root-x-pow-x 3.0) (root-x-pow-x 10.0) (root-x-pow-x-with-damp 3.0) (root-x-pow-x-with-damp 10.0) 阻尼法所需的迭代步数更少。 Exercise 1.37(define (cont-frac n d k) (define (frac-transform term k) (/ (n k) (+ (d k) term))) (define (rec i) (if (&gt; i k) 0.0 (frac-transform (rec (+ i 1)) i))) (rec 1)) (define (cont-frac-iter n d k) (define (frac-transform term k) (/ (n k) (+ (d k) term))) (define (iter result k) (if (= k 0) result (iter (frac-transform result k) (- k 1)))) (iter 0.0 k)) (cont-frac (lambda (x) 1.0) (lambda (x) 1.0) 11) (cont-frac-iter (lambda (x) 1.0) (lambda (x) 1.0) 11) 为了达到 $4$ 位小数的精度，需要十几步计算。 Exercise 1.38(define (approx-e k) (define (arr n) (let ((t (+ n 1))) (if (= (remainder t 3) 0) (* (/ t 3) 2.0) 1.0))) (+ (cont-frac (lambda (x) 1.0) arr k) 2)) Exercise 1.39(define (tan-cf x k) (let ((minus-x2 (- (* x x)))) (define (n k) (if (= k 1) x minus-x2)) (define (d k) (* (- (* k 2) 1) 1.0)) (cont-frac n d k))) Exercise 1.40(define (cubic a b c) (lambda (x) (+ (* x x x) (* a x x) (* b x) c))) Exercise 1.41(define (double f) (lambda (x) (f (f x)))) (((double (double double)) inc) 5) 输出了 $21$，因为 inc 外面嵌套了 $4$ 个 double，所以一共增加了 $2^4=16$ 次。 Exercise 1.42(define (compose f g) (lambda (x) (f (g x)))) Exercise 1.43(define (repeated f times) (lambda (x) (cond ((= times 0) x) ((even? times) ((double (repeated f (/ times 2))) x)) (else ((compose f (repeated f (- times 1))) x))))) Exercise 1.44(define (n-fold f n dx) (define (smooth f) (lambda (x) (/ (+ (f (- x dx)) (f x) (f (+ x dx))) 3))) ((repeated smooth n) f)) Exercise 1.45(define (log2-ceil n) (define (iter x ord) (if (&lt; x n) (iter (* x 2) (+ ord 1)) ord)) (iter 1 0)) (define (root-find n ord) (fixed-point-of-transform (lambda (x) (/ n (expt x (- ord 1)))) (repeated average-damp (log2-ceil ord)) 1.0)) 计算 $n$ 次根号，需要将 average-damp 重复应用 $\\lceil\\log_2n\\rceil$ 次。 Exercise 1.46(define (iterative-improve good-enough? improve initial-guess) (define (iter guess) (let ((next (improve guess))) (if (good-enough? guess next) next (iter next)))) (iter initial-guess)) (define (good-enough? a b) (&lt; (abs (- a b)) 0.00001)) (define (sqrt n) (define (improve x) (/ (+ x (/ n x)) 2.0)) (iterative-improve good-enough? improve 1.0)) (define (fixed-point f guess) (iterative-improve good-enough? f guess))","link":"/SICP/exercises/1-3/"},{"title":"2.1 Introduction to Data Abstraction","text":"Exercise 2.1(define (make-rat n d) (if (negative? d) (cons (- n) (- d)) (cons n d))) Exercise 2.2(define (make-segment p1 p2) (cons p1 p2)) (define (make-point x y) (cons x y)) (define (start-segment s) (car s)) (define (end-segment s) (cdr s)) (define (x-point p) (car p)) (define (y-point p) (cdr p)) (define (midpoint-segment s) (let ((p1 (start-segment s)) (p2 (end-segment s))) (make-point (/ (+ (x-point p1) (x-point p2)) 2) (/ (+ (y-point p1) (y-point p2)) 2)))) Exercise 2.3Denote a rectangle with its size (i.e., width and height), and, in consideration for further extensibility, with its origin point and rotation. (define (make-rect width height origin rotation) (cons (make-size width height) (cons origin rotation))) (define (make-size width height) (cons width height)) (define (get-size rect) (car rect)) (define (size-width size) (car size)) (define (size-height size) (cdr size)) (define (perimeter rect) (let ((size (get-size rect))) (* (+ (size-width size) (size-height size)) 2))) (define (area rect) (let ((size (get-size rect))) (* (size-width size) (size-height size)))) Exercise 2.4(define (cdr z) (z (lambda (p q) q))) Exercise 2.5(define (factor-out n factor) (define (iter n cnt) (if (= (remainder n factor) 0) (iter (/ n factor) (+ cnt 1)) cnt)) (iter n 0)) (define (cons a b) (* (expt 2 a) (expt 3 b))) (define (car n) (factor-out n 2)) (define (cdr n) (factor-out n 3)) Exercise 2.6(define one (lambda (f) (lambda (x) (f x)))) (define two (lambda (f) (lambda (x) (f (f x))))) (define (plus m n) (lambda (f) (lambda (x) ((m f) ((n f) x))))) Exercise 2.7(define (lower-bound intv) (car intv)) (define (upper-bound intv) (cdr intv)) Exercise 2.8(define (sub-interval x y) (make-interval (- (lower-bound x) (upper-bound y)) (- (upper-bound x) (lower-bound y)))) Exercise 2.9For addition and abstraction of two intervals $I_1$ and $I_2$&hairsp;, the width of the result is a function of the widths of the input, namely $$\\begin{aligned}2\\cdot width&amp;=[H(I_1)+H(I_2)]-[L(I_1)+L(I_2)]\\\\&amp;=[H(I_1)-L(I_1)]+[H(I_2)-L(I_2)]\\\\&amp;=width_1+width_2\\,,\\end{aligned}$$ where $H(I)$ stands for (upper-bound I)&hairsp;, $L(I)$ stands for (lower-bound I)&hairsp;, and $width_1,width_2$ stands for the width of the two intervals, respectively. But the equation above doesn’t hold for a multiplication or a division. Presume that the width of the result was a function of the widths of the inputs, then multiplying different intervals with the same widths should give the same answer. But [4, 14] * [2, 4] = [8, 56] (width = 48); [5, 15] * [1, 3] = [5, 45] (width = 40). Thus, the presumption turns out to be wrong. Exercise 2.10(define (div-interval x y) (if (&lt;= (* (lower-bound y) (upper-bound y)) 0) (error &quot;zero-spanned division error&quot;) (mul-interval x (make-interval (/ 1.0 (upper-bound y)) (/ 1.0 (lower-bound y)))))) Exercise 2.11The answer is WAY longer than the original version. Ben is very mean. (define (mul-interval x y) (let ((a (lower-bound x)) (b (upper-bound x)) (c (lower-bound y)) (d (upper-bound y))) (if (&lt; a 0) (if (&lt; b 0) (if (&lt; c 0) (if (&lt; d 0) (make-interval (* b d) (* a c)) (make-interval (* a d) (* a c))) (make-interval (* a d) (* b c))) (if (&lt; c 0) (if (&lt; d 0) (make-interval (* b c) (* a c)) (make-interval (min (* b c) (* a d)) (max (* a c) (* b d)))) (make-interval (* a d) (* b d)))) (if (&lt; c 0) (if (&lt; d 0) (make-interval (* b c) (* a d)) (make-interval (* b c) (* b d))) (make-interval (* a c) (* b d)))))) Exercise 2.12(define (make-center-percent c p) (make-center-width c (* c p 0.01))) (define (percent intv) (* (/ (width intv) (center intv)) 100.0)) Exercise 2.13The actual percentage tolerance is $$\\frac{w_1w_2(p_1+p_2)}{center}\\,,\\quad\\begin{aligned}&amp;\\text{where $w$ denotes width, $p$ denotes percentage tolerance}\\\\&amp;\\text{and $center$ denotes the center of the product interval.}\\end{aligned}$$ Since the tolerance is small enough to ignore the discrepancy between $center$ and $w_1w_2$&hairsp;, the percentage tolerance is $p_1+p_2$ approximately. Thus, we have (define (prod-percent-approx a b) (+ (percent a) (percent b))) Exercises 2.14–2.16All three problems point to the difficulty to introduce “identity” to interval arithmetic. Suppose we have two numbers $A$ and $B$&hairsp;, which settles within intervals $I_A=[L_A,H_A]$ and $I_B=[L_B,H_B]$&hairsp;, respectively (assuming that all numbers are positive). Then we’ll have $$\\frac{I_A}{I_B}=\\left[\\frac{L_A}{H_B},\\frac{H_A}{L_B}\\right]$$ under the definition of interval division. But when we try to divide an interval by itself, we’ll get $$\\frac{I_A}{I_A}=\\left[\\frac{L_A}{H_A},\\frac{H_A}{L_A}\\right]$$ which is for most of the time not equal to $[1,1]$ as we might have expected. The above example illustrates that, the re-appearance of an interval in an expression may well introduce uncertainty to the evaluation. This is because, we never know whether two intervals are related to the same number. In other words, intervals don’t have “identity”. Intervals don’t have identity, but real numbers do. I have devised an approach to eliminate these uncertainties. That is, settle the numbers into their corresponding intervals randomly before evaluating the expression. After repeating the “settle-evaluate” loop for say $100,000$ times, we’ll get a decent approximation to the actual interval. My approach is inspired by the Monte Carlo methods, which rely on repeated random sampling to obtain numerical results. The approach may be time-consuming since the evaluation has to be carried out a great many times before the approximation becomes precise enough. But it will always give the right answer. My code written in Python is given below: random-sampling.py1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import randominfty = float('inf')class Interval(object): def __init__(self, lower, upper): self.lower = lower self.upper = upper def settle(self): return random.random() * (self.upper - self.lower) + self.lower @staticmethod def from_center_percent(center, percent): width = center * percent * 0.01 return Interval(center - width, center + width) def __str__(self): return 'Interval(%.3f, %.3f)' % (self.lower, self.upper)def evaluate(func, intervals, precision=100000): lower, upper = infty, -infty for _ in range(precision): val = func(*(i.settle() for i in intervals)) if val &lt; lower: lower = val if val &gt; upper: upper = val return Interval(lower, upper)if __name__ == '__main__': # These two functions accept two arguments, # which are values settled for each loop # within their corresponding interval. def func_1(a, b): return (a * b) / (a + b) def func_2(a, b): return 1.0 / (1.0 / a + 1.0 / b) I = Interval.from_center_percent intervals = [I(100, 5), I(10, 5)] print(evaluate(func_1, intervals)) print(evaluate(func_2, intervals)) We know par2 is the procedure which has its parameters appear only once in its body. So it have no issues with identity. And in the random sampling approach, both func_1 and func_2 evaluate to the same answer, which is equal to the one produced by par2&hairsp;.","link":"/SICP/exercises/2-1/"},{"title":"2.2 Hierarchical Data and the Closure Property","text":"Exercise 2.17(define (last-pair lst) (if (null? (cdr lst)) lst (last-pair (cdr lst)))) Exercise 2.18(define (reverse lst) (define (iter lst result) (if (null? lst) result (iter (cdr lst) (cons (car lst) result)))) (iter lst nil)) Exercise 2.19(define (no-more? coins) (null? coins)) (define (first-denomination coins) (car coins)) (define (except-first-denomination coins) (cdr coins)) The order of denominations doesn’t affect the result. Because both procedures compute all possible combinations. Exercise 2.20(define (same-parity f . r) (define (equiv? a b) (or (and a b) (and (not a) (not b)))) (let ((p (even? f))) (define (choose r) (cond ((null? r) nil) ((equiv? p (even? (car r))) (cons (car r) (choose (cdr r)))) (else (choose (cdr r))))) (cons f (choose r)))) Exercise 2.21(define (square-list items) (if (null? items) nil (cons (* (car items) (car items)) (square-list (cdr items))))) (define (square-list items) (map (lambda (x) (* x x)) items)) Exercise 2.22The first one will generate a reversed result because the first element of items is attached to the front of answer every iteration; The latter one doesn’t work because it will finally produce a structure like (((((() . 1) . 2) . 3) . 4) . 5)&hairsp;, which is not even a list. Exercise 2.23(define (for-each proc items) (define (iter items) (cond ((not (null? items)) (proc (car items)) (iter (cdr items))))) (iter items)) Exercise 2.24The interpreter prints (1 (2 (3 4)))&hairsp;. Exercise 2.25(car (cdr (car (cdr (cdr lst))))) (car (car lst)) (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr lst)))))))))))) Exercise 2.26(1 2 3 4 5 6) ((1 2 3) 4 5 6) ((1 2 3) (4 5 6)) Exercise 2.27(define (deep-reverse tree) (define (iter tree result) (cond ((null? tree) result) ((pair? tree) (iter (cdr tree) (cons (deep-reverse (car tree)) result))) (else tree))) (iter tree nil)) Exercise 2.28I made use of the append procedure defined previously. (define (fringe tree) (cond ((null? tree) nil) ((pair? tree) (append (fringe (car tree)) (fringe (cdr tree)))) (else (list tree)))) Exercise 2.29a. (define (left-branch mobile) (car mobile)) (define (right-branch mobile) (car (cdr mobile))) (define (branch-length mobile) (car mobile)) (define (branch-structure mobile) (car (cdr mobile))) b. (define (total-weight object) (if (number? object) object (+ (total-weight (branch-structure (left-branch object))) (total-weight (branch-structure (right-branch object)))))) c. (define (torque branch) (* (branch-length branch) (total-weight (branch-structure branch)))) (define (balanced? object) (or (number? object) (and (= (torque (left-branch object)) (torque (right-branch object))) (balanced? (branch-structure (left-branch object))) (balanced? (branch-structure (right-branch object)))))) d. (define (left-branch mobile) (car mobile)) (define (right-branch mobile) (cdr mobile)) (define (branch-length mobile) (car mobile)) (define (branch-structure mobile) (cdr mobile)) Only four procedures have to be changed. That’s the convenience abstraction barriers bring to us. Exercise 2.30(define (square-tree tree) (cond ((null? tree) nil) ((pair? tree) (cons (square-tree (car tree)) (square-tree (cdr tree)))) (else (* tree tree)))) Exercise 2.31(define (tree-map proc tree) (cond ((null? tree) nil) ((pair? tree) (cons (tree-map proc (car tree)) (tree-map proc (cdr tree)))) (else (proc tree)))) Another solution uses map&hairsp;: (define (tree-map proc tree) (map (lambda (subtree) (cond ((null? subtree) nil) ((pair? subtree) (tree-map proc subtree)) (else (proc subtree)))) tree)) Exercise 2.32(define (subset s) (if (null? s) (list nil) (let ((rest (subset (cdr s)))) (append rest (map (lambda (lst) (cons (car s) lst)) rest))))) Initially I wrongly wrote nil instead of (list nil)&hairsp;, which always generates an empty list. It works, because the set of all subsets is a union of: The set of all subsets excluding the first number; The set of all subsets excluding the first number that has the first number re-inserted into each subset. Exercise 2.33(define (map proc seq) (accumulate (lambda (x y) (cons (proc x) y)) nil seq)) (define (append seq1 seq2) (accumulate cons seq2 seq1)) (define (length seq) (accumulate (lambda (x y) (+ y 1)) 0 seq)) Exercise 2.34(define (horner-eval x coefficient-sequence) (accumulate (lambda (this-coeff higher-terms) (+ (* higher-terms x) this-coeff)) 0 coefficient-sequence)) Exercise 2.35(define (count-leaves tree) (accumulate (lambda (x y) (+ (cond ((null? x) 0) ((pair? x) (count-leaves x)) (else 1)) y)) 0 tree)) Exercise 2.36(define (accumulate-n op init seqs) (if (null? (car seqs)) nil (cons (accumulate op init (map car seqs)) (accumulate-n op init (map cdr seqs))))) Another version uses a separately defined transpose procedure: (define (transpose seqs) (if (null? (car seqs)) nil (cons (map car seqs) (transpose (map cdr seqs))))) (define (accumulate-n op init seqs) (map (lambda (x) (accumulate op init x)) (transpose seqs))) Exercise 2.37(define (matrix-*-vector m v) (map (lambda (x) (dot-product x v)) m)) (define (transpose mat) (if (null? (car mat)) nil (cons (map car mat) (transpose (map cdr mat))))) (define (matrix-*-matrix m n) (let ((cols (transpose n))) (map (lambda (x) (matrix-*-vector cols x)) m))) Exercise 2.383/2 1/6 (1 (2 (3 ()))) (((() 1) 2) 3) op should have commutativity and associativity simultaneously: Commutativity alone is not enough, such as $x\\;{\\rm op}\\;y=x^2+y^2$&hairsp;; Associativity alone is not enough, such as matrix multiplications. Exercise 2.39(define (reverse seq) (fold-right (lambda (x y) (append y (list x))) nil seq)) (define (reverse seq) (fold-left (lambda (x y) (cons y x)) nil seq)) Exercise 2.40(define (unique-pairs n) (flatmap (lambda (i) (map (lambda (j) (list i j)) (enumerate-interval 1 (- i 1)))) (enumerate-interval 1 n))) (define (prime-sum-pairs n) (map make-pair-sum (filter prime-sum? (unique-pairs n)))) Exercise 2.41(define (make-triples n s) (define (eligible? triple) (and (&lt; (cadr triple) (caddr triple)) (&lt;= (caddr triple) n))) (filter eligible? (flatmap (lambda (i) (map (lambda (j) (list j i (- s i j))) (enumerate-interval 1 (- i 1)))) (enumerate-interval 2 n)))) Exercise 2.42(define empty-board nil) (define (adjoin-position new-row k rest-of-queens) (append rest-of-queens (list (list new-row k)))) (define (safe? k positions) (define (row-of pos) (car pos)) (define (col-of pos) (cadr pos)) (let ((new-queen (car (filter (lambda (pos) (= (col-of pos) k)) positions))) (rest-of-queens (filter (lambda (pos) (not (= (col-of pos) k))) positions))) (define (examine unexamined-queens) (cond ((null? unexamined-queens) #t) ((let ((x1 (row-of (car unexamined-queens))) (y1 (col-of (car unexamined-queens))) (x2 (row-of new-queen)) (y2 (col-of new-queen))) (or (= (+ x1 y1) (+ x2 y2)) (= (+ x1 y2) (+ x2 y1)) (= x1 x2) (= y1 y2))) #f) (else (examine (cdr unexamined-queens))))) (examine rest-of-queens))) (define (queens board-size) (define (queen-cols k) (if (= k 0) (list empty-board) (filter (lambda (positions) (safe? k positions)) (flatmap (lambda (rest-of-queens) (map (lambda (new-row) (adjoin-position new-row k rest-of-queens)) (enumerate-interval 1 board-size))) (queen-cols (- k 1)))))) (queen-cols board-size)) I also wrote a more abstract version that defines (define (two-queens-safe? q1 q2) (let ((x1 (row-of q1)) (y1 (col-of q1)) (x2 (row-of q2)) (y2 (col-of q2))) (not (or (= (+ x1 y1) (+ x2 y2)) (= (+ x1 y2) (+ x2 y1)) (= x1 x2) (= y1 y2))))) to check whether two queens are safe with respect to each other. And uses (accumulate (lambda (another-queen result) (and (two-queens-safe? new-queen another-queen) result)) #t rest-of-queens) to replace the original examine procedure. I gave it up thinking that it would sacrifice the readability of my program. But this level of abstraction provides a fundamental basis for the algorithm analyses in Exercise 2.43. Exercise 2.43Exchanging the order of the mapping causes (queen-cols (- k 1)) to be invoked for every element in (enumerate-interval 1 board-size)&hairsp;. Let’s say that $A_{k,n}$ is the number of all ways to place queens in the first $k$ columns of an $n\\times n$ board. For the $8\\times8$ case, we have $$\\begin{array}{r|ccccccccc}k&amp;0&amp;1&amp;2&amp;3&amp;4&amp;5&amp;6&amp;7&amp;8\\\\A_{k,8}&amp;1&amp;8&amp;42&amp;140&amp;344&amp;568&amp;550&amp;312&amp;92\\end{array}$$ Since that two-queens-safe? defined in Exercise 2.42 takes a constant time to determine whether two queens are safe with respect to each other, we stipulate that it is the primitive operation. Let’s say $B_{k,n}$ is the number of times two-queens-safe? to be invoked when calling (queen-cols k) of the original algorithm on an $n\\times n$ board. We have the recurrence $$B_{k,n}=\\begin{cases}0\\,,&amp;\\text{if $k=0$}\\,;\\\\n(k-1)A_{k-1,n}+B_{k-1,n}\\,,&amp;\\text{if $k&gt;0$}\\,.\\end{cases}$$ In the recurrence above, multiply $A_{k-1,n}$ by $n(k-1)$ means we have to attach $n$ possible new queens to each of ways to place previous queens, and filter each of them, during which the new queen has to be examined with the other $k-1$ queens. In the original algorithm, $B_{8,8}=81696$&hairsp;. Exchanging the order of mapping causes (queen-cols (- k 1)) to be invoked $n$ times instead of once, the recurrence is simply $$B^\\prime_{k,n}=\\begin{cases}0\\,,&amp;\\text{if $k=0$}\\,;\\\\n(k-1)A_{k-1,n}+nB^\\prime_{k-1,n}\\,,&amp;\\text{if $k&gt;0$}\\,.\\end{cases}$$ In Louis’ algorithm, $B^\\prime_{8,8}=59878720$&hairsp;, about $733\\cdot B_{8,8}$&hairsp;. So the required time is about $733T$&hairsp;. Exercise 2.44(define (up-split painter n) (if (= n 0) painter (let ((smaller (up-split painter (- n 1)))) (below painter (beside smaller smaller))))) Exercise 2.45(define (split proc1 proc2) (define (impl painter n) (if (= n 0) painter (let ((smaller (impl painter (- n 1)))) (proc1 painter (proc2 smaller smaller))))) impl) Exercise 2.46(define (make-vect xcor ycor) (list xcor ycor)) (define (xcor-vect vect) (car vect)) (define (ycor-vect vect) (cadr vect)) (define (add-vect vect1 vect2) (make-vect (+ (xcor-vect vect1) (xcor-vect vect2)) (+ (ycor-vect vect1) (ycor-vect vect2)))) (define (sub-vect vect1 vect2) (make-vect (- (xcor-vect vect1) (xcor-vect vect2)) (- (ycor-vect vect1) (ycor-vect vect2)))) (define (scale-vect factor vect) (make-vect (* (xcor-vect vect) factor) (* (ycor-vect vect) factor))) Exercise 2.47(define (make-frame origin edge1 edge2) (list origin edge1 edge2)) (define (origin-frame frame) (car frame)) (define (edge1-frame frame) (cadr frame)) (define (edge2-frame frame) (caddr frame)) or (define (make-frame origin edge1 edge2) (cons origin (cons edge1 edge2))) (define (origin-frame frame) (car frame)) (define (edge1-frame frame) (cadr frame)) (define (edge2-frame frame) (cddr frame)) Exercise 2.48(define (make-segment start end) (cons start end)) (define (start-segment segment) (car segment)) (define (end-segment segment) (cdr segment)) Exercise 2.49a. (define outline (segments-&gt;painter (list (make-segment (make-vect 0.0 0.0) (make-vect 0.0 1.0)) (make-segment (make-vect 0.0 1.0) (make-vect 1.0 1.0)) (make-segment (make-vect 1.0 1.0) (make-vect 1.0 0.0)) (make-segment (make-vect 1.0 0.0) (make-vect 0.0 0.0))))) b. (define cross (segments-&gt;painter (list (make-segment (make-vect 0.0 0.0) (make-vect 1.0 1.0)) (make-segment (make-vect 0.0 1.0) (make-vect 1.0 0.0))))) c. (define diamond (segments-&gt;painter (list (make-segment (make-vect 0.5 0.0) (make-vect 1.0 0.5)) (make-segment (make-vect 1.0 0.5) (make-vect 0.5 1.0)) (make-segment (make-vect 0.5 1.0) (make-vect 0.0 0.5)) (make-segment (make-vect 0.0 0.5) (make-vect 0.5 0.0))))) d. Too many line segments to draw, I’m skipping this. Exercise 2.50(define (flip-horiz painter) (transform-painter painter (make-vect 0.0 1.0) (make-vect 1.0 1.0) (make-vect 0.0 0.0))) (define (rotate180 painter) (transform-painter painter (make-vect 1.0 1.0) (make-vect 0.0 1.0) (make-vect 1.0 0.0))) (define (rotate270 painter) (transform-painter painter (make-vect 0.0 1.0) (make-vect 0.0 0.0) (make-vect 1.0 1.0))) Exercise 2.51(define (below painter1 painter2) (let ((split-point (make-vect 0.0 0.5))) (let ((paint-bottom (transform-painter painter1 (make-vect 0.0 0.0) (make-vect 1.0 0.0) split-point)) (paint-top (transform-painter painter2 split-point (make-vect 1.0 0.5) (make-vect 0.0 1.0)))) (lambda (frame) (paint-bottom frame) (paint-top frame))))) or (define (below painter1 painter2) (rotate270 (beside (rotate90 painter2) (rotate90 painter1)))) Exercise 2.52a. (define (add-segments segment-list painter) (lambda (frame) ((segments-&gt;painter segment-list) frame) (painter frame))) (define smiley-wave (add-segments (list &lt;smiley segments&gt;) wave)) b. (define (corner-split painter n) (if (= n 0) painter (let ((up-smaller (up-split painter (- n 1)))) (below (right-split painter n) (beside up-smaller (corner-split painter (- n 1))))))) c. Made Mr. Rogers look outward. (define (compose . procs) (lambda (x) (define (impl procs) (if (null? procs) x ((car procs) (impl (cdr procs))))) (impl procs))) (define (square-limit painter n) (define (corner-split-n painter) (corner-split painter n)) ((square-of-four (compose flip-horiz corner-split-n flip-horiz) (compose corner-split-n flip-horiz) (compose flip-horiz flip-vert corner-split-n flip-horiz) (compose flip-vert corner-split-n flip-horiz)) painter))","link":"/SICP/exercises/2-2/"},{"title":"2.3 Symbolic Data","text":"Exercise 2.53(list 'a 'b 'c) -&gt; (a b c) (list (list 'george)) -&gt; ((george)) (cdr '((x1 x2) (y1 y2))) -&gt; ((y1 y2)) (cadr '((x1 x2) (y1 y2))) -&gt; (y1 y2) (pair? (car '(a short list))) -&gt; #f (memq 'red '((red shoes) (blue socks))) -&gt; #f (memq 'red '(red shoes blue socks)) -&gt; (red shoes blue socks) Exercise 2.54(define (equal? a b) (cond ((and (pair? a) (pair? b)) (and (equal? (car a) (car b)) (equal? (cdr a) (cdr b)))) ((not (or (pair? a) (pair? b))) (eq? a b)) (else #f))) Exercise 2.55''abracadabra is an abbreviation of (list 'quote 'abracadabra)&hairsp;; its first element is 'quote&hairsp;. Exercise 2.56(define (exponentiation? e) (and (pair? e) (eq? (car e) '**))) (define (base e) (cadr e)) (define (exponent e) (caddr e)) (define (make-exponentiation base exponent) (cond ((=number? exponent 0) 1) ((=number? exponent 1) base) ((and (number? base) (number? exponent)) (expt base exponent)) (else (list '** base exponent)))) (define (deriv exp var) (cond ((number? exp) 0) ((variable? exp) (if (same-variable? exp var) 1 0)) ((sum? exp) (make-sum (deriv (addend exp) var) (deriv (augend exp) var))) ((product? exp) (make-sum (make-product (multiplier exp) (deriv (multiplicand exp) var)) (make-product (deriv (multiplier exp) var) (multiplicand exp)))) ((exponentiation? exp) (make-product (exponent exp) (make-product (make-exponentiation (base exp) (make-sum (exponent exp) -1)) (deriv (base exp) var)))) (else (error &quot;unknown expression type -- DERIV&quot; exp)))) Exercise 2.57(define (augend e) (let ((rem (cddr e))) (if (null? (cdr rem)) (car rem) (cons '+ rem)))) (define (multiplicand e) (let ((rem (cddr e))) (if (null? (cdr rem)) (car rem) (cons '* rem)))) Exercise 2.58a. (define (sum? e) (and (pair? e) (eq? (cadr e) '+))) (define (addend e) (car e)) (define (augend e) (caddr e)) (define (make-sum a1 a2) (cond ((=number? a1 0) a2) ((=number? a2 0) a1) ((and (number? a1) (number? a2)) (+ a1 a2)) ((equal? a1 a2) (make-product a1 2)) (else (list a1 '+ a2)))) (define (product? e) (and (pair? e) (eq? (cadr e) '*))) (define (multiplier e) (car e)) (define (multiplicand e) (caddr e)) (define (make-product m1 m2) (cond ((or (=number? m1 0) (=number? m2 0)) 0) ((=number? m1 1) m2) ((=number? m2 1) m1) ((and (number? m1) (number? m2)) (* m1 m2)) (else (list m1 '* m2)))) b. A simple solution works under the assumption that the expression contains only additions and multiplications. An expression is a sum if it contains any '+ in its topmost “layer” , otherwise, a product. (define (sum? e) (and (pair? e) (not (null? (cdr e))) (or (eq? (cadr e) '+) (sum? (cddr e))))) (define (addend e) (if (eq? (cadr e) '+) (car e) (cons (car e) (cons (cadr e) (let ((rem (addend (cddr e)))) (if (pair? rem) rem (list rem))))))) (define (augend e) (let ((rem (cddr e))) (if (eq? (cadr e) '+) (if (null? (cdr rem)) (car rem) rem) (augend rem)))) (define (make-sum a1 a2) (cond ((=number? a1 0) a2) ((=number? a2 0) a1) ((and (number? a1) (number? a2)) (+ a1 a2)) (else (append (if (pair? a1) a1 (list a1)) (if (pair? a2) (cons '+ a2) (list '+ a2)))))) (define (product? e) (not (sum? e))) (define (multiplier e) (car e)) (define (multiplicand e) (let ((rem (cddr e))) (if (null? (cdr rem)) (car rem) rem))) (define (make-product m1 m2) (cond ((or (=number? m1 0) (=number? m2 0)) 0) ((=number? m1 1) m2) ((=number? m2 1) m1) ((and (number? m1) (number? m2)) (* m1 m2)) (else (list m1 '* m2)))) Exercise 2.59(define (union-set set1 set2) (cond ((null? set1) set2) ((element-of-set? (car set1) set2) (union-set (cdr set1) set2)) (else (adjoin-set (car set1) (union-set (cdr set1) set2))))) Exercise 2.60adjoin-set was changed to allow duplicates. adjoin-set is sufficiently more efficient, it has a time complexity of $\\Theta(1)$ compared to the original $\\Theta(n)$&hairsp;. The set allowing duplicates is suitable for situations that require frequent adjoin operations. (define (element-of-set? x set) (if (null? set) #f (or (equal? x (car set)) (element-of-set? x (cdr set))))) (define (adjoin-set x set) (cons x set)) (define (intersection-set set1 set2) (cond ((null? set1) '()) ((element-of-set? (car set1) set2) (cons (car set1) (intersection-set (cdr set1) set2))) (else (intersection-set (cdr set1) set2)))) (define (union-set set1 set2) (cond ((null? set1) set2) ((element-of-set? (car set1) set2) (union-set (cdr set1) set2)) (else (adjoin-set (car set1) (union-set (cdr set1) set2))))) Exercise 2.61Both version have the time complexity of $\\Theta(n)$&hairsp;, but the ordered version has to examine on the average half of the set instead of the entire set. (define (adjoin-set x set) (cond ((null? set) (list x)) ((= x (car set)) set) ((&lt; x (car set)) (cons x set)) (else (cons (car set) (adjoin-set x (cdr set)))))) Exercise 2.62(define (union-set set1 set2) (cond ((null? set1) set2) ((null? set2) set1) ((= (car set1) (car set2)) (cons (car set1) (union-set (cdr set1) (cdr set2)))) ((&lt; (car set1) (car set2)) (cons (car set1) (union-set (cdr set1) set2))) (else (cons (car set2) (union-set set1 (cdr set2)))))) Exercise 2.63a. Trees in Figure 2.16 can be represented as (define tree1 '(7 (3 (1 () ()) (5 () ())) (9 () (11 () ())))) (define tree2 '(3 (1 () ()) (7 (5 () ()) (9 () (11 () ()))))) (define tree3 '(5 (3 (1 () ()) ()) (9 (7 () ()) (11 () ())))) Both procedures evaluate to the same list (1 3 5 7 9 11)&hairsp;. b. tree-&gt;list2 grows slower. For tree-&gt;list1&hairsp;, $$T(n)=2\\cdot T(n/2)+\\Theta(n)\\,,$$ where $\\Theta(n)$ means that append takes linear time to combime two lists; and the recurrence has the solution $T(n)\\sim\\Theta(n\\log n)$&hairsp;. For tree-&gt;list2&hairsp;, $$T(n)=2\\cdot T(n/2)+\\Theta(1)\\,,$$ since it uses a single cons to combine the results; and the recurrence has the solution $T(n)\\sim\\Theta(n)$&hairsp;. Actually, I looked up the solutions to the recurrences, since I’m not able to solve such equations at present. I will come back to explain them once I finished reading related topics in Concrete Mathematics. Exercise 2.64a. The generated tree looks like 5 / \\ 1 9 \\ / \\ 3 7 11 The partial-tree procedure split the list into three parts and combine them into a tree. For example, the list (1 3 5 7 9 11) would be split into parts: list (1 3) of the length left-size&hairsp;, which is used to generate the left-tree&hairsp;; 5 as this-entry&hairsp;, the entry of the generated tree; list (7 9 11) of the length right-size&hairsp;, which is used to generate the right-tree&hairsp;. Then the parts would be combined like (this-entry left-tree right-tree)&hairsp;. b. Suppose we’re going to convert a list of length $n$ into a tree. The list-&gt;tree procedure depends on (partial-tree &lt;list&gt; n)&hairsp;, which generates two partial-tree of the lengths of about half of $n$&hairsp;, and combine them into a tree. The combining step uses list which requires a constant time. Then we have the recurrence $$T(n)=2\\cdot T(n/2)+\\Theta(1)\\,,$$ which has the solution $T(n)\\sim\\Theta(n)$&hairsp;. Exercise 2.65Implemented using previously defined procedures. union-set-as-list is the original union-set&hairsp;; intersection-set-as-list is the original intersection-set&hairsp;. (define (union-set set1 set2) (let ((list1 (tree-&gt;list set1)) (list2 (tree-&gt;list set2))) (list-&gt;tree (union-set-as-list list1 list2)))) (define (intersection-set set1 set2) (let ((list1 (tree-&gt;list set1)) (list2 (tree-&gt;list set2))) (list-&gt;tree (intersection-set-as-list list1 list2)))) Exercise 2.66(define (lookup given-key set-of-records) (cond ((null? set-of-records) #f) ((equal? given-key (key (entry set-of-records))) (entry set-of-records)) ((&lt; given-key (key (entry set-of-records))) (lookup x (left-branch set-of-records))) ((&gt; given-key (key (entry set-of-records))) (lookup x (right-branch set-of-records))))) Exercise 2.67The result is (A D A B B C A)&hairsp;. Exercise 2.68(define (encode-symbol symbol tree) (if (leaf? tree) '() (cond ((element-of-set? symbol (symbols (left-branch tree))) (cons 0 (encode-symbol symbol (left-branch tree)))) ((element-of-set? symbol (symbols (right-branch tree))) (cons 1 (encode-symbol symbol (right-branch tree)))) (else (error &quot;bad symbol: ENCODE-SYMBOL&quot; symbol))))) At first, I wrote a procedure with a helper procedure encode-1 instead of encode-symbol (because I carelessly skipped reading the latter part of the requirements), which is analogous to the decode sample code in the book. This version is faster than a procedure making use of append&hairsp;, since append takes linear time to combine the results instead of constant time. (define (encode message tree) (define (symbol-&gt;next-bit symbol tree) (cond ((element-of-set? symbol (symbols (left-branch tree))) 0) ((element-of-set? symbol (symbols (right-branch tree))) 1) (else (error &quot;bad symbol: SYMBOL-&gt;NEXTBIT&quot; symbol)))) (define (encode-1 symbols current-branch) (if (null? symbols) '() (let ((next-bit (symbol-&gt;next-bit (car symbols) current-branch))) (let ((next-branch (choose-branch next-bit current-branch))) (cons next-bit (if (leaf? next-branch) (encode-1 (cdr symbols) tree) (encode-1 symbols next-branch))))))) (encode-1 message tree)) Exercise 2.69(define (successive-merge set) (if (null? (cdr set)) (car set) (successive-merge (adjoin-set (make-code-tree (car set) (cadr set)) (cddr set))))) Exercise 2.70$84$ bits are needed using Huffman encoding method; $108$ bits are needed using fixed-length code. Exercise 2.71Such trees look like /\\ /\\ 2^(n-1) /\\ 2^(n-2) /\\ ... 1 2 The most frequent symbol requires one bit to represent; and the least frequent symbols require $n-1$ bits to represent. Exercise 2.72Encoding the most frequent symbol, we have to search through the entire symbol list once, which takes linear time. Thus $$T(n)\\sim\\Theta(n)\\,.$$ Encoding a least frequent symbol, we have to search through a list containing $n$ symbols, then a list containing $n-1$ symbols, then a list containing $n-2$ symbols, till we reach the bottom of the tree. Thus $$T(n)\\sim\\Theta(n^2)\\,.$$","link":"/SICP/exercises/2-3/"},{"title":"2.4 Multiple Representations for Abstract Data","text":"Exercise 2.73DrRacket as my interpreter, I added a few lines in the front to “implement” put and get&hairsp;, based on the built-in hash table structure. #lang racket (define *the-table* (make-hash)) (define (put key1 key2 value) (hash-set! *the-table* (list key1 key2) value)) (define (get key1 key2) (hash-ref *the-table* (list key1 key2) #f)) a. That’s because numbers and variables are not tagged data. b. (define (install-linear-package) (define (make-sum exp1 exp2) (cond ((=number? exp1 0) exp2) ((=number? exp2 0) exp1) ((and (number? exp1) (number? exp2)) (+ exp1 exp2)) (else (list '+ exp1 exp2)))) (define (make-product exp1 exp2) (cond ((=number? exp1 1) exp2) ((=number? exp2 1) exp1) ((and (number? exp1) (number? exp2)) (* exp1 exp2)) (else (list '* exp1 exp2)))) (define (deriv-addition operands var) (let ((addend (car operands)) (augend (cadr operands))) (make-sum (deriv addend var) (deriv augend var)))) (define (deriv-multiplication operands var) (let ((multiplier (car operands)) (multiplicand (cadr operands))) (make-sum (make-product multiplier (deriv multiplicand var)) (make-product (deriv multiplier var) multiplicand)))) (put 'make '+ make-sum) (put 'make '* make-product) (put 'deriv '+ deriv-addition) (put 'deriv '* deriv-multiplication) 'done) (define (=number? exp num) (and (number? exp) (= exp num))) (define (variable? exp) (symbol? exp)) (define (same-variable? var1 var2) (and (variable? var1) (variable? var2) (eq? var1 var2))) (define (operator exp) (car exp)) (define (operands exp) (cdr exp)) (define (deriv exp var) (cond ((number? exp) 0) ((variable? exp) (if (same-variable? exp var) 1 0)) (else (let ((proc (get 'deriv (operator exp)))) (if proc (proc (operands exp) var) (error &quot;invalid operator -- DERIV&quot; exp)))))) (install-linear-package) c. (define (install-exponentiation-package) (define make-sum (get 'make '+)) (define make-product (get 'make '*)) (define (make-exponentiation exp1 exp2) (cond ((and (not (=number? exp1 0)) (=number? exp2 0)) 1) ((=number? exp2 1) exp1) (else (list '** exp1 exp2)))) (define (deriv-exponentiation operands var) (let ((base (car operands)) (ex (cadr operands))) (make-product ex (make-exponentiation base (make-sum ex -1))))) (put 'make '** make-exponentiation) (put 'deriv '** deriv-exponentiation) 'done) (install-exponentiation-package) d. Arguments in every put call need to be reordered. Exercise 2.74Every company should provide their file in tagged-data form. Headquarters should implement (define (division file) ...) (define (records file) ...) to extract from the file its belonging division and the actual records it contains. a. (define (get-record employee file) ((get 'employee-records-&gt;record (division file)) employee (records file))) b. (define (get-salary employee file) (let ((record (get-record employee file))) ((get 'record-&gt;salary (division file)) record))) c. (define (find-employee-record employee files) (if (null? files) #f ((let ((record (get-record employee (car files)))) (if record record (find-employee-record employee (cdr files))))))) d. The new company should provide a package that includes employee-records-&gt;record and record-&gt;salary implementation. Exercise 2.75(define (make-from-mag-ang r a) (define (dispatch op) (cond ((eq? op 'real-part) (* r (cos a))) ((eq? op 'imag-part) (* r (sin a))) ((eq? op 'magnitude) r) ((eq? op 'angle) a) (else (error &quot;invalid operation -- MAKE-FROM-MAG-ANG&quot; op)))) dispatch) Exercise 2.76For generic operations with explicit dispatch, when you add a new type, you have to edit every existing operation; when you add a new operation, you have to create an operation that takes account of all types. This style is appropriate for a system in which new operations must often be added. For message-passing, when you add a new type, you have to create a new “operation dispatcher” that does all operations; when you add a new operation, you have to edit every existing “operation dispatcher.” This style is appropriate for a system in which new types must often be added. I placed data-directed style at last, because it actually eliminates the deficiencies above. In this style, operations are organized in a table. To add a new type, you can fill out a new column in the table, that is, create a package for that type, as what we’ve done in the book. To add a new operation, you can fill out a new row in the table, that is, create a package for that operation. Everything is additive no matter whether you’re adding a new type or a new operation.","link":"/SICP/exercises/2-4/"},{"title":"2.5 Systems with Generic Operations","text":"Exercise 2.","link":"/SICP/exercises/2-5/"},{"title":"3.2 The Environment Model of Evaluation","text":"Exercise 3.11Acc and acc2 share the same physical code stored in the computer; their local state variables balance’s are distinct.","link":"/SICP/exercises/3-2/"},{"title":"3.1 Assignment and Local State","text":"Exercise 3.1(define (make-accumulator value) (lambda (num) (begin (set! value (+ value num)) value))) Exercise 3.2(define (make-monitored f) (let ((counter 0)) (lambda (arg) (if (eq? arg 'how-many-calls?) counter (begin (set! counter (inc counter)) (f arg)))))) Exercise 3.3(define (make-account balance password) (lambda (given-password method) (if (eq? given-password password) (lambda (amount) (cond ((eq? method 'deposit) (begin (set! balance (+ balance amount)) balance)) ((eq? method 'withdraw) (if (&lt; balance amount) &quot;Insufficient funds&quot; (begin (set! balance (- balance amount)) balance))))) (lambda (amount) &quot;Incorrect password&quot;)))) Exercise 3.4(define (make-account balance password) (let ((incorrect-times 0)) (lambda (given-password method) (if (eq? given-password password) (lambda (amount) (cond ((eq? method 'deposit) (begin (set! balance (+ balance amount)) balance)) ((eq? method 'withdraw) (if (&lt; balance amount) &quot;Insufficient funds&quot; (begin (set! balance (- balance amount)) balance))))) (begin (set! incorrect-times (inc incorrect-times)) (if (&gt;= incorrect-times 7) (call-the-cops)) (lambda (amount) &quot;Incorrect password&quot;)))))) Exercise 3.5(define (random-in-range low high) (+ (random (- high low)) low)) (define (estimate-integral pred x1 x2 y1 y2 trials) (define (experiment) (pred (random-in-range x1 x2) (random-in-range y1 y2))) (let ((ratio (monte-carlo trials experiment))) (* ratio (- x2 x1) (- y2 y1)))) (define (in-unit-circle? x y) (&lt; (+ (* x x) (* y y)) 1.0)) (define (estimate-pi) (estimate-integral in-unit-circle? -1.0 1.0 -1.0 1.0 1000000) Exercise 3.6(define (rand action) (let ((x rand-init)) (define (rand-generate) (set! x (rand-update x)) x) (define (rand-reset new-random-init) (set! x new-rand-init)) (cond ((eq? action 'generate) (rand-generate)) ((eq? action 'reset) rand-reset)))))) Exercise 3.7Making no modifications to my solution to Exercise 3.3, I wrote make-joint as a “wrap” around the original account, and if joint-password is correct, it will provide the original password. (define (make-joint account password joint-password) (lambda (given-password method) (if (eq? given-password joint-password) (account password method) (account given-password method)))) Exercise 3.8(define (f-obj) (let ((last-x 0)) (lambda (x) (let ((result last-x)) (set! last-x x) result)))) (define f (f-obj))","link":"/SICP/exercises/3-1/"},{"title":"3.3 Modeling with Mutable Data","text":"Exercise 3.12(a b) (a b c d) Exercise 3.13The programs will be caught in an infinite recursion. Exercise 3.14v (a) w (d c b a) Exercise 3.16p1-&gt;p2-&gt;p3 (count-pairs p1) 3 p1-&gt;p2=&gt;p3 (count-pairs p1) 4 p1=&gt;p2=&gt;p3 (count-pairs p1) 7 in which a-&gt;b means (define a (cons 'non-pair b)) and a=&gt;b means (define a (cons b b)). Exercise 3.17Maintain a local list of encountered pairs; only count a pair if it hasn’t been encountered. (define (count-pairs x) (let ((encountered-pairs '())) (define (encountered? p remaining-pairs) (if (null? remaining-pairs) false (if (eq? p (car remaining-pairs)) true (encountered? p (cdr remaining-pairs))))) (define (count-unencountered-pairs y) (if (not (pair? y)) 0 (+ (count-unencountered-pairs (car y)) (count-unencountered-pairs (cdr y)) (if (encountered? y encountered-pairs) 0 (begin (set! encountered-pairs (cons y encountered-pairs)) 1))))) (count-unencountered-pairs x))) Exercises 3.18–3.19I came up with this solution during a post-shower daze time, when creativity peaks (x. The idea is to have two sentinels running through the linked list at different speeds, for example, one takes one cdr at a time while the other takes two cdr’s. If one sentinel reaches the end, the linked list cannot have a loop; otherwise a sentinel chases the other inside a loop and will eventually “catch” the other. The program is given below. (define (has-loop? l) (define (scdr l) (if (pair? l) (cdr l) '())) (define (iter s1 s2) (cond ((or (null? s1) (null? s2)) false) ((eq? s1 s2) true) (else (iter (scdr s1) (scdr (scdr s2)))))) (iter l (scdr l))) Exercise 3.21(define (print-queue queue) (display (front-ptr queue))) Exercise 3.22(define (make-queue) (let ((front-ptr '()) (rear-ptr '())) (define (empty?) (null? front-ptr)) (define (insert! item) (if (empty?) (let ((new-pair (list item))) (set! front-ptr new-pair) (set! rear-ptr new-pair)) (let ((new-pair (list item))) (set-cdr! rear-ptr new-pair) (set! rear-ptr new-pair)))) (define (get) (if (empty?) (error &quot;ERROR&quot;) (car front-ptr))) (define (delete!) (let ((result (get))) (begin (set! front-ptr (cdr front-ptr))))) (define (dispatch m) (cond ((eq? m 'empty?) empty?) ((eq? m 'insert!) insert!) ((eq? m 'delete!) delete!) ((eq? m 'get) get))) dispatch)) Exercise 3.23In order to delete the rear element of a deque and to be able to move the rear pointer backwards, I created a bi-directed structure node which, in contrast to ordinary list structure, also keep a record of its preceding node. (define (node prev item next) (cons item (cons prev next))) (define (prev-node node) (cadr node)) (define (next-node node) (cddr node)) (define (make-deque) (cons '() '())) (define (deque-empty? dq) (null? (car dq))) (define (deque-front dq) (if (deque-empty? dq) (error &quot;ERROR - Accessing a member of an empty deque&quot;) (caar dq))) (define (deque-rear dq) (if (deque-empty? dq) (error &quot;ERROR - Accessing a member of an empty deque&quot;) (cadr dq))) (define (deque-delete-front! dq) (if (deque-empty? dq) (error &quot;ERROR - Deleting a member of an empty deque&quot;) (set-car! dq (next-node (car dq))))) (define (deque-delete-rear! dq) (if (deque-empty? dq) (error &quot;ERROR - Deleting a member of an empty deque&quot;) (set-cdr! dq (prev-node (cdr dq))))) (define (deque-insert-front! dq item) (if (deque-empty? dq) (let ((new-node (node '() item '()))) (set-car! dq new-node) (set-cdr! dq new-node)) (let ((original-node (car dq))) (set-car! dq (node '() item original-node)) (set-cdr! (cdar dq) original-node)))) (define (deque-insert-rear! dq item) (if (deque-empty? dq) (let ((new-node (node '() item '()))) (set-car! dq new-node) (set-cdr! dq new-node)) (let ((original-node (cdr dq))) (set-cdr! dq (node original-node item '())) (set-car! (cddr dq) original-node)))) Exercise 3.24(define (same-key? k1 k2) (cond ((and (number? k1) (number? k2)) (&lt; (abs (- k1 k2)) 0.00001)) ((and (symbol? k1) (symbol? k2)) (equal? k1 k2)) (else false))) Exercise 3.25To simplify the problem, I made the assumption that the users only index the table with key sequences of the same length. (define (make-table) (let ((local-table (list '*table*))) (define (lookup keys) (define (iter keys table) (if (null? keys) table (let ((subtable (assoc (car keys) table))) (if subtable (iter (cdr keys) (cdr subtable)) false)))) (iter keys (cdr local-table))) (define (insert! keys value) (define (new-record keys value) (if (null? keys) value (list (cons (car keys) (new-record (cdr keys) value))))) (define (iter keys table) (let ((subtable (assoc (car keys) table))) (if subtable (if (null? (cdr keys)) (set-cdr! subtable (cons (cons (car keys) value) (cdr subtable))) (iter (cdr keys) (cdr subtable))) (set-cdr! table (cons (car (new-record keys value)) (cdr table)))))) (if (null? (cdr local-table)) (set-cdr! local-table (new-record keys value)) (iter keys (cdr local-table)))) (define (dispatch m) (cond ((eq? m 'lookup-proc) lookup) ((eq? m 'insert-proc!) insert!) (else (error &quot;Unknown operation -- TABLE&quot; m)))) dispatch)) A simple example of using the table: (define t (make-table)) ((t 'insert-proc!) '(1 3 5 7) 'odd) ((t 'insert-proc!) '(2 4 6 8) 'even) ((t 'lookup-proc) '(1 3 5 7)) odd ((t 'lookup-proc) '(4 3 2 1)) #f Exercise 3.26Replace the lists of indices with binary trees of indices and assoc with binary trees’ lookup. In addition, create a procedure for comparing key sequences, like this one below. (define (key-less-than k1 k2) (cond ((null? k1) true) ((&lt; (car k1) (car k2)) true) (else (key-less-than (cdr k1) (cdr k2))))) Exercise 3.27Each memo-fib first calculates the first branch, then the second branch. When (memo-fib n) is called, it will calculate (memo-fib n-1), then (memo-fib n-2)… until with (memo-fib 1); after which, all memo-fib starts to calculate the second branch, that is, (memo-fib 0) until (memo-fib n-2); each of them uses values that are already memorized and takes a constant number of steps; since there are $n$ memo-fib calls, (memo-fib n) runs in a number of steps proportional to $n$. (define memo-fib (memorize fib)) won’t work. In the call of (memo-fib n), it calls the non-memorized version fib, which takes exponential time to evaluate. Exercise 3.28(define (or-gate a1 a2 output) (define (or-action-procedure) (let ((new-value (logical-or (get-signal a1) (get-signal a2)))) (after-delay or-gate-delay (lambda () (set-signal! output new-value))))) (add-action! a1 or-action-procedure) (add-action! a2 or-action-procedure) 'ok) Exercise 3.29(define (or-gate a1 a2 output) (let ((s1 (make-wire)) (s2 (make-wire)) (s3 (make-wire))) (inverter a1 s1) (inverter a2 s2) (and-gate s1 s2 s3) (inverter s3 output) 'ok)) Exercise 3.30(define (ripple-carry-adder a b c-out sum) (let ((c-in (make-wire))) (if (null? a) (set-signal! c-out 0) (begin (ripple-carry-adder (cdr a) (cdr b) c-in (cdr sum)) (full-adder (car a) (car b) c-in (car sum) c)))) 'ok) TODO Exercise 3.31If the procedures are not immediately run, all wires will have $0$ as their signal-value, which would fail on the encounter of an inverter, which have different signal values on both ends. Take the half-adder in figure 1 as an example, when A changes from $0$ to $1$ while B keeps $0$ unchanged, the and-gate before S would produce $0$ rather than the expected result $1$, due to a failure of the inverter. Exercise 3.32If the result of a logical gate depends on its inputs, it cannot produce the correct value before its inputs are correctly produced. Exercise 3.33(define (averager a b c) (define (process-new-value) (cond ((and (has-value? a) (has-value? b)) (set-value! c (/ (+ (get-value a) (get-value b)) 2) me)) ((and (has-value? a) (has-value? c)) (set-value! b (- (* (get-value c) 2) (get-value a)) me)) ((and (has-value? b) (has-value? c)) (set-value! a (- (* (get-value c) 2) (get-value b)) me)))) (define (process-forget-value) (forget-value! a me) (forget-value! b me) (forget-value! c me) (process-new-value)) (define (me request) (cond ((eq? request 'I-have-a-value) (process-new-value)) ((eq? request 'I-lost-my-value) (process-forget-value)) (else (error &quot;Unknown request -- AVERAGER&quot; request)))) (connect a me) (connect b me) (connect c me) me) Exercise 3.34The multiplier requires values of two connectors to infer the value of the thrid connector. When connector b is set, the multiplier cannot infer the value of a from b. Exercise 3.35Assume that if the connector a has a value, it is always non-negative. (define (squarer a b) (define (process-new-value) (if (has-value? b) (if (&lt; (get-value b) 0) (error &quot;square less than 0 -- SQUARER&quot; (get-value b)) (set-value! a (sqrt b) me)) (if (has-value? a) (set-value! b (square a) me)))) (define (process-forget-value) (forget-value! a me) (forget-value! b me)) (define (me request) (cond ((eq? request 'I-have-a-value) (process-new-value)) ((eq? request 'I-lost-my-value) (process-forget-value)) (else (error &quot;Unknown request -- SQUARER&quot; request)))) (connect a me) (connect b me) me) Exercise 3.37(define (c- x y) (let ((z (make-connector))) (adder x z y) z)) (define (c* x y) (let ((z (make-connector))) (multiplier x y z) z)) (define (c/ x y) (let ((z (make-connector))) (multiplier x z y) z)) (define (cv value) (let ((z (make-connector))) (constant value z) z))","link":"/SICP/exercises/3-3/"},{"title":"第一章 构造抽象过程","text":"1.1 程序设计的基本元素 为了让我们能通过程序语言组织自己有关计算过程的思想，每一种强有力的语言都提供了三种机制，使我们能够将简单的认识组合起来形成更复杂的认识： 基本表达式，指语言中最基本的实体 组合的方法，通过它们可以用简单元素构成复合元素 抽象的方法，通过它们可以给复合元素命名，并将其视为单元操作 组合式求值有以下步骤： 对组合式的各个子表达式求值 将运算符的值应用于其它子表达式的值 对子表达式求值时也必须遵循这样的步骤，这意味着求值步骤本身就是递归的。 define 是我们给值命名的方式，也是最简单的抽象方式，形如 (define x 3)&hairsp;。这样做会导致名字 x 与值 3 相关联。将名字与值相关联，又能根据名字提取出值，解释器需要存储空间来维护名字-值关联，这存储空间被称为环境。 过程定义形如 (define (&lt;name&gt; &lt;formal parameters&gt;) &lt;body&gt;)，将用对应的实际参数替换形式参数，再求值的这一过程，在环境中绑定给一个名字，便于以后的调用。 应用序求值与正则序求值是表达式求值的两种方式。应用序求值时，解释器首先对运算符和各个对象求值，之后将得到的过程应用于得到的实际参数。而正则序求值时，先不求出运算对象的值，直到需要它们时再去求。 应用序，概括为 “先求值而后应用” 正则序，概括为 “完全展开后规约” Lisp 采用应用序求值，部分原因在于这样做能避免对于表达式的重复求值，从而可以提高一些效率。更重要的是，在超出了可以采用代换方式模拟过程的范围后，正则序的处理将变得复杂得多。 条件表达式和谓词，形如 (cond (&lt;p1&gt; &lt;e1&gt;) (&lt;p2&gt; &lt;e2&gt;) ... (&lt;pn&gt; &lt;en&gt;)) (if &lt;predicate&gt; &lt;consequent&gt; &lt;alternative&gt;) cond 之后跟随着形如 (&lt;p&gt; &lt;e&gt;) 的表达式，称为从句。从句中的 &lt;p&gt; 是谓词，与结果表达式 &lt;e&gt; 相对应。整个 cond 表达式的值是从左到右第一个谓词为真的从句的结果表达式，其中 else 是一个永远为真的谓词。 要对一个 if 表达式求值，首先对 &lt;predicate&gt; 求值。如果其为真，求出 &lt;consequent&gt; 的值，否则求出 &lt;alternative&gt; 的值作为整个 if 表达式的值。 由于 cond 和 if 不一定对其所有子表达式求值，它们不是一般的过程，而是特殊形式。 形式参数叫什么名字，其实无所谓，这样的名字称为约束变量。如果一个变量不是被约束的，我们就称它为自由的。名字在其中被约束的表达式的集合称为名字的作用域。约束变量在将其作为形式参数的过程中的作用域是这个过程的过程体。 词法作用域是作用域的一种工作模型。内层过程中的自由变量，实际上是外围过程定义中的约束变量。 嵌套定义的过程，称为块结构。块结构的好处是，可以省去将某些变量在内层过程中传递的过程。 1.2 过程与它们所产生的计算 能够遇见所作所为的后果，是一种很重要的能力。 过程规定了计算状态如何从之前的计算状态演变而来。计算的具体行为很难捉摸，但我们可以找到演变的一般模式。从全局的角度判断计算状态的演变方式，这就是这一节所需要学习的内容。 递归过程与递归计算是不同的概念：递归过程是指一个过程的定义中，包含了引用自身的表达式。而递归计算，指的是递归实际的演变方式。 线性递归与线性迭代是计算的两种演变方式： 线性递归：计算过程中不断展开表达式，随之构建起一条延迟操作的链，并在这些运算实际进行时收缩。当需要保存的信息量（正如延迟操作的步数）与问题规模的增长成正比时，称为线性递归。 线性迭代：没有增长和收缩过程，需要保存的信息是一定数量的状态变量，并且用一套规则来指定状态变量的更新方式。当计算步数与问题规模的增长成正比时，称为线性迭代。 迭代过程中，状态变量完全描述了当前的状态，只要提供这些状态变量，计算就能随时进行下去；而递归过程就不同了，递归过程中记录了变量以外的额外信息，用于告诉解释器 “我们在延迟操作链上的什么位置”。 树形递归是指递归过程中多次引用自身，使 “延迟操作链” 分叉为树形结构。树形递归往往需要极多运算资源，但它不是无用的。处理有层级结构的数据时，树形递归是个自然而强大的工具；处理数字时，树形递归方式更容易理解。 对于树形递归的计算过程中的每一个节点，只需保存树中在其之上的节点的信息。一般来说，树形递归的计算所需的步骤数正比于树中的节点数，所需空间正比于树的最大深度。 树形递归可以使用记忆化的方法进行优化，如练习 3.27，在计算斐波那契数列时虽然使用了树形递归的形式，但由于可以利用之前计算得出的值，生成的整个递归树只有一条链；整个程序可以在线性时间内计算出结果。 增长阶为计算所需要的资源量，提供了粗略的估计。设 ${\\rm R}(n)$ 为问题规模为 $n$ 时所需的计算资源量。当 $$\\exists k_1,k_2,N\\;\\forall n&gt;N\\,(k_1f(n)\\leq{\\rm R}(n)\\leq k_2f(n))$$ 成立时，我们称 ${\\rm R}(n)$ 有 $\\Theta(f(n))$ 的增长阶，记作 ${\\rm R}(n)\\sim\\Theta(f(n))$&hairsp;。 Lamé定理：如果用欧几里德算法计算一对数的 GCD 需要执行 $k$ 步，那么更小的那个数一定不小于第 $k$ 个斐波那契数。 运用这个定理，可以很方便地分析欧几里德算法的增长阶。设更小的数为 $n$，则一定有 $n\\geq{\\rm Fib}(k)\\approx\\frac{\\phi^k}{\\sqrt5}$&hairsp;。从此可以看出，$k$ 正比于 $\\log_\\phi(n)$ 增长，所以欧几里德算法的增长阶为 $\\Theta(\\log n)$&hairsp;。 费马小定理：若 $n$ 是素数，则对于任意 $a$ 不是 $n$ 的倍数，都有 $a^n\\equiv a\\;({\\rm mod}\\;n)$，它的另一个形式是 $a^{n-1}\\equiv1\\;({\\rm mod}\\;n)$，在$\\text{Miller–Rabin}$素性测试中得以应用。 1.3 用高阶函数做抽象 为了增加描述能力，一门强大的语言需要：将共有的模式命名并建立抽象，而后直接在抽象的层次上工作。 这就需要引入高阶过程，它们以过程为参数，或者以过程为返回值。 将过程作为参数，或者将过程作为其值，以便用过程来处理过程，这样的过程称作高阶过程。 匿名过程形如 (lambda (&lt;formal-parameters&gt;) &lt;body&gt;)&hairsp;。lambda 像 define 一样创造过程，但是不为它们绑定名称。 局部变量使用以下语法进行绑定，它们的作用域是 &lt;body&gt; 部分： (let ((&lt;var1&gt; &lt;exp1&gt;) (&lt;var2&gt; &lt;exp2&gt;) ... (&lt;varn&gt; &lt;expn&gt;)) &lt;body&gt;) let 也是一种特殊形式，和调用过程时，将表达式的值绑定给形式参数的原理一样，它并没有引入新的机制。 “$\\mapsto$” 这个符号叫做映射&hairsp;$($$\\textit{maps to}$$)$，是 lambda 在数学中的表达。例如 $y\\mapsto x/y$ 可以被表达为 (lambda (y) (/ x y))&hairsp;。 一般来说，程序语言会对计算元素的可操作方式作出限制。而带有最少限制的元素被称为拥有第一级状态，这些元素有这些特点： 可以被绑定给一个变量 可以作为参数传递给一个过程 可以被一个过程作为返回值 可以存储在数据结构中 Lisp 语言为过程赋予了完全的第一级状态，由此获得的描述能力是惊人的。 这样做是有代价的，也为解释器的实现提出了挑战：实现第一级状态的过程需要为过程中的自由变量预留存储空间，即使某个过程并没有被调用。","link":"/SICP/notes/1/"},{"title":"Chapter 2 Building Abstractions with Data","text":"2.1 Introduction to Data Abstraction Similar to procedural abstraction, data abstraction is a methodology that enables us to isolate how a compound data object is used from the details of how it is constructed from more primitive data objects. Selectors and constructors are sets of procedures used as the interface between the construction of data and the use of data, through which programs are as if operating on “abstract data.” A pair is a compound structure, whose behavior could be specified as (car (cons a b)) -&gt; a (cdr (cons a b)) -&gt; b Abstraction barriers isolate different “levels” of the system. Identify for each of type of data object a set of operations, and use only those operations in manipulating data objects. 2.2 Hierarchical Data and the Closure Property The ability to create pairs whose elements are pairs is the essence of list structure which benefits from the closure property of cons&hairsp;. Closure is the key to power in any means of combination because it permits us to create hierarchical structures — structures made up of parts, which themselves are made up of parts, and so on. The use of the word “closure” here comes from abstract algebra, where a set of elements is said to be closed under an operation if applying the operation to elements in the set produces an element that is again an element of the set. A sequence is an ordered collection of data objects. There are many ways to represent sequences. In our language, a sequence produced by (list &lt;a1&gt; &lt;a2&gt; ... &lt;an&gt;) is equivalent to (cons &lt;a1&gt; (cons &lt;a2&gt; (cons ... (cons &lt;an&gt; nil) ...)))&hairsp;. Such a sequence is called a list. Sequences serve as a conventional interface that permits us to combine processing modules (e.g. maps, filters, and accumulations). Trees are sequences whose elements are sequences. They can be dealt naturally with recursions. The approach of stratified design helps make programs robust, that is, it makes it likely that small changes in a specification will require correspondingly small changes in the program. 2.3 Symbolic Data To extend the representational capability of our language, we introduce the ability to quote a data object, that is, to work with arbitrary symbols as data. Prefix code is a way of coding such that no complete code of any symbol is the prefix of the code for another symbol. One particular scheme uses Huffman encoding tree. 2.4 Multiple Representations for Abstract Data This section introduces a new kind of data-abstraction barriers that isolate different representations of data from each other. Generic procedures are procedures that can operate on data that has multiple representations. We’ll need the help of type tags that specify how the data are to be processed. As systems evolve over time, we need conventions to incorporate new modules into systems additively, that is, without having to re-implement the modules. Two styles of organizing system with generic operations are introduced, they are: Data-directed style. In this style, we handle generic operations by dealing explicitly with operation-and-type tables. Message-passing style. In this style, we create data objects as dispatching procedures. Such a procedure takes as argument the name of an operation to be performed. …………","link":"/SICP/notes/2/"},{"title":"Chapter 3 Modularity, Objects, and State","text":"3.1 Assignment and Local StateIntroducing assignment leads to difficult conceptual issues, such as the difficulty of defining sameness. But, viewing systems as collections of objects with local state is a powerful technique for maintaining a modular design, separating the internal logic of a sub-procedure from the enclosing procedure. A concrete example is the random number generator. 3.2 The Environment Model of EvaluationOnce we admit assignment into our programming language, the substitution model introduced is no longer adequate; and this is the motivation of introducing the environment model. During the evaluation of procedures, new environments are created containing a frame that binds the parameter to the values of arguments; each environment has a pointer leading to the enclosing environment. 3.3 Modeling with Mutable DataScheme provides us with mutators of pairs, thus we could build powerful mutable list structure upon them. A pair could serve as a “wrap” around an object, behaving similar to a head pointer of a linked list. For example, if we want a mutable list and use it like this… (define ml (make-mutable-list)) (insert! 'new-value ml) …we could make make-mutable-list returning a pair with a “dummy record” and insert! operating on the cdr of the mutable list… (define (make-mutable-list) (cons '*mutable-list* '())) (define (insert! value ml) (set-cdr! ml (cons value (cdr ml)))) …thus avoiding the need to return the mutated list itself when inserting a new value. The presence of local state is critical in the implementation of the digital circuit simulator and the constraint system described in the book; both of the two examples store values in “wires” and use a event-driven simulation technique, keeping a listener list in each wire and inform them on value changes. …………","link":"/SICP/notes/3/"}],"posts":[{"title":"区间最小公倍数","text":"题目链接：Codeforces Hello 2015 (Div.2) - LCM Query 求出某个序列所有给定长度的连续子序列的最小公倍数中的最小值。考虑到有大量询问、无需进行修改，故采用 稀疏表 + 离线处理 的方法。 题目描述出题人喜欢最小公倍数&hairsp;$({\\rm lcm})$，他提供了一个数列 $a_1,a_2,\\ldots,a_n$，并给出了一些 $x$，希望你对每个 $x$ 都求出以下式子的值： $$\\min_{i=1}^{n-x+1}{\\rm lcm}(a_i,a_{i+1},\\ldots,a_{i+x-1})$$ 简单来说求出这个数列所有长度为 $x$ 的连续子序列的最小公倍数中的最小值（简单来说？ 数列 ${a_i}$ 的长度为 $n$，一个 $x$ 就是一次询问，共有 $m$ 次询问，并有以下限制： $1\\leq n\\leq2\\times10^4$$1\\leq m\\leq10^6$$1\\leq a_i\\leq60$$1\\leq x\\leq n$ 题解对于一个数 $x$，可以将其分解质因数：$x=p_1^{b_1}\\times p_2^{b_2}\\times\\ldots\\times p_k^{b_k}$，其中 $p_i$ 指第 $i$ 个素数。于是 $x$ 就可以表示为一个数列 $b$&hairsp;。用这种表示方法，可以很方便地表示最小公倍数。假设有两个数 $x=p_1^{b_1}\\times p_2^{b_2}\\times\\ldots\\times p_k^{b_k}$ 和 $y=p_1^{c_1}\\times p_2^{c_2}\\times\\ldots\\times p_k^{c_k}$，那么就有： $${\\rm lcm}(x,y)=p_1^{\\max(b_1,c_1)}\\times p_2^{\\max(b_2,c_2)}\\times\\ldots\\times p_k^{\\max(b_k,c_k)}$$ 由于题目要求让结果对 $10^9 + 7$ 取模，算出的结果不能直接比较大小。所以利用对数的性质，取对数后再比较对数的大小： $$\\begin{aligned}\\log(x)&amp;=b_1\\log(p_1)+b_2\\log(p_2)+\\ldots+b_k\\log(p_k)\\\\\\log(y)&amp;=c_1\\log(p_1)+c_2\\log(p_2)+\\ldots+c_k\\log(p_k)\\\\\\log(x)&amp;\\lt\\log(y)\\implies x\\lt y\\end{aligned}$$ 最后是查询，对于每一个 $x$ 都重新遍历一遍数列是肯定会 TLE 的，所以要先将每一个区间长度的结果处理出来。大概过程是这样的：创建两个 “指针” $l$ 和 $r$&hairsp;。一开始，$l$ 和 $r$ 都指向第一个元素，之后让 $r$ 不断向后移动，直至指向第一个 ${\\rm lcm}$ 值$ {\\rm lcm}(a_l,a_{l+1},\\ldots,a_r)$ 与之前的 ${\\rm lcm}$ 值不同的元素，并用之前的 ${\\rm lcm}$ 值更新 $ans_{r-l}$ 的值。再向右移动 $r$ 并如此更新，直至数列尾后元素。之后 $l$ 和 $r$ 同时指向第二个元素，重复上述操作，再同时指向第三个元素…… 直至同时指向数列的尾部元素。 以数列 $12,3,6,25,5,7$ 举例： $l=0,r=3$，用 ${\\rm lcm}(12,3,6)=12$ 更新 $ans_3$ $l=0,r=5$，用 ${\\rm lcm}(12,3,6,25,5)=300$ 更新 $ans_5$ $l=0,r=6$，用 ${\\rm lcm}(12,3,6,25,5,7)=2100$ 更新 $ans_6$ $l=1,r=3$，用 ${\\rm lcm}(3,6)=6$ 更新 $ans_2$ …… 这部分比较难搞懂，代码中已经用 $64$ 道反斜杠划出了重点。 参考代码lcm-query.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;using namespace std;typedef vector&lt;int&gt; vi;typedef long long ll;const int maxn = 2e4 + 1;const int lg2maxn = 15;const ll mod = 1e9 + 7;int lg2[maxn], pw2[lg2maxn], ansi[maxn];vi rmq[maxn][lg2maxn], ans[maxn], p;vector&lt;double&gt; lnp;void init(){ for (int i = 2; i != maxn; ++i) lg2[i] = lg2[i &gt;&gt; 1] + 1; for (int i = 0; i != lg2maxn; ++i) pw2[i] = 1 &lt;&lt; i; for (int i = 2; i &lt;= 60; ++i) { bool prime = true; for (int j = 2; prime &amp;&amp; j * j &lt;= i; ++j) if (!(i % j)) prime = false; if (prime) p.push_back(i), lnp.push_back(log((double)i)); } fill(ans, ans + maxn, vi(p.size(), 7));}vi lcm(const vi&amp; a, const vi&amp; b){ vi res(p.size()); for (int i = 0, i_ = p.size(); i != i_; ++i) res[i] = max(a[i], b[i]); return res;}vi intvlcm(int l, int r){ int s = lg2[r - l]; return lcm(rmq[l][s], rmq[r - pw2[s]][s]);}vi itov(int x){ vi res(p.size(), 0); for (int i = 0, i_ = p.size(); i != i_; ++i) while (!(x % p[i])) ++res[i], x /= p[i]; return res;}int vtoi(const vi&amp; x){ ll res = 1ll; for (int i = 0, i_ = p.size(); i != i_; ++i) for (int j = x[i]; j--;) res = (res * p[i]) % mod; return res;}bool cmp(const vi&amp; a, const vi&amp; b){ double x = 0.0, y = 0.0; for (int i = 0, i_ = p.size(); i != i_; ++i) x += lnp[i] * a[i], y += lnp[i] * b[i]; return x &lt; y;}int main(){ init(); int n, q; scanf(&quot;%d%d&quot;, &amp;n, &amp;q); for (int i = 0, t; i != n; ++i) scanf(&quot;%d&quot;, &amp;t), rmq[i][0] = itov(t); for (int j = 1; j &lt;= lg2[n]; ++j) for (int i = n - pw2[j]; i != -1; --i) rmq[i][j] = lcm(rmq[i][j - 1], rmq[i + pw2[j - 1]][j - 1]); //////////////////////////////// for (int l = 0; l != n; ++l) { vi cur = rmq[l][0]; for (int r = l; r != n;) { cur = lcm(cur, rmq[r][0]); for (int k = lg2[n - r]; k != -1; --k) if (r + pw2[k] &lt;= n &amp;&amp; lcm(cur, rmq[r][k]) == cur) r += pw2[k]; ans[r - l] = min(ans[r - l], cur, cmp); } } //////////////////////////////// for (int x; q--;) { scanf(&quot;%d&quot;, &amp;x); printf(&quot;%d\\n&quot;, ansi[x] ? ansi[x] : (ansi[x] = vtoi(ans[x]))); }}","link":"/posts/codeforces-gym-100571-c/"},{"title":"初等数论习题","text":"最近学校在教“信息安全数学基础”这门课程, 目前讲到了数论的基础知识. 我选择了 Kenneth H. Rosen 著作的《初等数论及其应用》作为辅助教材, 阅读过程中理解了一些有趣的结论, 证明和习题. 目录1.&nbsp;“如果 $a,b$ 和 $c$ 为整数, 且 $c\\mid ab,$ 则 $c\\mid(a,c)(b,c)$”2.&nbsp;多元线性同余方程解的个数 “如果 $a,b$ 和 $c$ 为整数, 且 $c\\mid ab,$ 则 $c\\mid(a,c)(b,c)$”对于课后习题中的这个命题, 参考书[1]中所给的证明过程有误, 用到了 “若 $p^\\alpha\\mid c,p^\\beta\\mid c,$ 则 $p^{\\max(\\alpha,\\beta)}\\mid c$” 这样的错误结论. 接下来我将给出一种正确的证明过程. 定义. 设 $p$ 为素数, $n$ 为正整数. 如果 $p^a\\mid n$ 但是 $p^{a+1}\\nmid n,$ 我们称 $p^a$ 恰整除(exactly divides) $n,$ 记为 $p\\,\\|\\,n.$ 由此定义, 还可以给出恰整除的另一种表示法: $p^a$ 恰整除 $n$ 当且仅当 $n=p^aQ,$ 其中 $Q$ 是不能被 $p$ 整除的整数. 引理 1. 设 $p$ 为素数, $a,b$ 为整数. 如果 $p^a\\,\\|\\,m,p^b\\,\\|\\,n,$ 则 $p^{a+b}\\,\\|\\,mn.$证明. 由恰整除的定义知, $m=p^aQ,n=p^bR,$ 其中 $Q,R$ 为不能被 $p$ 整除的整数. 而 $mn=p^{a+b}QR,$ 其中 $p\\nmid QR.$ 再次利用恰整除的定义得 $p^{a+b}\\,\\|\\,mn.$ $\\square$ 引理 2. 设 $p$ 为素数, $a,b,m,n$ 为整数. 如果 $p^a\\,\\|\\,m,p^b\\,\\|\\,n,$ 则 $p^{\\min(a,b)}\\,\\|\\,(m,n).$证明. 设 $p_1,p_2,\\ldots,p_n$ 是出现在 $m$ 和 $n$ 的素幂因子分解中的素数. 则 $m,n$ 可表示为 $m=p_1^{\\alpha_1}p_2^{\\alpha_2}\\cdots p_r^{\\alpha_r}$ 和 $n=p_1^{\\beta_1}p_2^{\\beta_2}\\cdots p_r^{\\beta_r}.$ 不失一般性地以素因子 $p_1$ 为例, 由恰整除的定义得 $p_1^{\\alpha_1}\\,\\|\\,m$ 和 $p_1^{\\beta_1}\\,\\|\\,n.$ 再由 $(m,n)=p_1^{\\min(\\alpha_1,\\beta_1)}p_2^{\\min(\\alpha_2,\\beta_2)}\\cdots p_r^{\\min(\\alpha_r,\\beta_r)}$ 观察到 $p_1^{\\min(\\alpha_1,\\beta_1)}\\,\\|\\,(m,n).$ $\\square$ 引理 3. 若 $r,s,t$ 为非负整数, 且 $r\\leq s+t,$ 则 $r\\leq\\min(r,s)+\\min(r,t).$证明. 分为以下四种情况讨论: 1) 若 $r\\leq s$ 且 $r\\leq t,$ 则有 $r\\leq 2r$ 成立. 2) 若 $r\\gt s$ 且 $r\\leq t,$ 则有 $r\\leq s+r$ 成立. 3) 若 $r\\leq s$ 且 $r\\gt t,$ 则有 $r\\leq r+t$ 成立. 4) 若 $r\\gt s$ 且 $r\\gt t,$ 则有 $r\\leq s+t$ 成立. $\\square$ 有了以上定义和引理, 我们可以开始证明原命题. 定理. 如果 $a,b$ 和 $c$ 为整数, 且 $c\\mid ab,$ 则 $c\\mid(a,c)(b,c).$证明. 设 $p^r\\,\\|\\,c,p^s\\,\\|\\,a$ 和 $p^t\\,\\|\\,b.$ 由 $p^r\\,\\|\\,c$ 和 $c\\mid ab$ 得 $p^r\\mid ab.$ 由 $p^s\\,\\|\\,a,p^t\\,\\|\\,b$ 和引理 1 得 $p^{s+t}\\,\\|\\,ab.$ 故 $r\\leq s+t.$ 由引理 2 得 $p^{\\min(r,s)}\\,\\|\\,(a,c)$ 和 $p^{\\min(r,t)}\\,\\|\\,(b,c).$ 再由引理 1 得 $p^{\\min(r,s)+\\min(r,t)}\\,\\|\\,(a,c)(b,c).$ 由引理 3 得 $r\\leq\\min(r,s)+\\min(r,t),$ 故 $p^r\\mid(a,c)(b,c).$ 通过上述推理, 如果 $c=p_1^{\\alpha_1}p_2^{\\alpha_2}\\cdots p_n^{\\alpha_n}$ 是 $c$ 的素幂因子分解, 那么 $p_j^{\\alpha_j}\\mid(a,c)(b,c),\\;j=1,2,\\ldots,n.$ 我们想证明 $p_1^{\\alpha_1}p_2^{\\alpha_2}\\cdots p_i^{\\alpha_i}\\mid(a,c)(b,c)$ 成立. 利用数学归纳法, 当 $i=1$ 时, 有归纳基础 $p_1^{\\alpha_1}\\mid(a,c)(b,c)$ 成立. 假设对于 $i=k-1,$ 有 $p_1^{\\alpha_1}p_2^{\\alpha_2}\\cdots p_{k-1}^{\\alpha_{k-1}}\\mid(a,c)(b,c)$ 成立. 已知 $p_k^{\\alpha_k}\\mid(a,c)(b,c),$ 则由 $(p_k^{\\alpha_k},p_1^{\\alpha_1}p_2^{\\alpha_2}\\cdots p_{k-1}^{\\alpha_{k-1}})=1,$ 可得出 $p_k^{\\alpha_k}\\cdot p_1^{\\alpha_1}p_2^{\\alpha_2}\\cdots p_{k-1}^{\\alpha_{k-1}}=p_1^{\\alpha_1}p_2^{\\alpha_2}\\cdots p_k^{\\alpha_k}\\mid(a,c)(b,c),$ 即 $i=k$ 时命题成立. 从而 $i=n$ 时有 $p_1^{\\alpha_1}p_2^{\\alpha_2}\\cdots p_n^{\\alpha_n}=c\\mid(a,c)(b,c)$ 成立. $\\square$ 多元线性同余方程解的个数定理. 设 $a,b,c$ 和 $m$ 是整数, $m&gt;0$ 且 $d=(a,b,m).$ 那么二元线性同余方程 $ax+by\\equiv c\\pmod m$ 在 $d\\mid c$ 时恰有 $dm$ 个不同余的解, 其他情形无解.证明. 若 $ax+by\\equiv c\\pmod m,$ 那么存在整数 $k,$ 使得 $ax+by-mk=c.$ 因为 $d$ 是 $a,b,m$ 的公因数, 故 $d\\mid ax+by-mk,$ 进而 $d\\mid c.$ 所以若 $d\\nmid c,$ 那么该同余式无解. 现在假设同余式有解, 即 $d\\mid c.$ 令 $a=da^\\prime,b=db^\\prime,c=dc^\\prime,e=de^\\prime.$ 那么 $(a^\\prime,b^\\prime,m^\\prime)=1,$ 我们可以将同余式除以 $m^\\prime,$ 得到 $a^\\prime x+b^\\prime y\\equiv c^\\prime\\pmod{m^\\prime},$ 或者 $$a^\\prime x\\equiv c^\\prime-b^\\prime y\\pmod{m^\\prime}.\\tag{$*$}$$ 该同余式有解, 当且仅当 $g=(a^\\prime,m^\\prime)\\mid c^\\prime-b^\\prime y,$ 这相当于同余式 $b^\\prime y\\equiv c^\\prime\\pmod g$ 有解. 这必然成立, 因为 $(b^\\prime,g)=(b^\\prime,a^\\prime,m^\\prime)=1,$ 表示该同余式恰有一个解, 我们将其记作 $y_0.$ 注意到, 数列 $y_0,y_0+g,y_0+2g,\\ldots,y_0+(m^\\prime/g-1)g$ 中的元素关于 $g$ 都同余, 但是关于 $m^\\prime$ 都不同余, 也就是说这 $m^\\prime/g$ 个数中的的每一个都会在 $(*)$ 式中得到模 $m^\\prime$ 不同余的 $c^\\prime-b^\\prime y.$ 而这每个不同余的 $c^\\prime-b^\\prime y$ 都可以得出 $(*)$ 式的 $g$ 个不同余的解. 所以 $(*)$ 式共有 $(m^\\prime/g)g=m^\\prime$ 个不同余的解. 现在假设 $(x_1,y_1)$ 是原同余式的一个解. 类似地, 注意到数列 $x_1,x_1+m^\\prime,x_1+2m^\\prime,\\ldots,x_1+(d-1)m^\\prime$ 中的 $d$ 个数关于 $m^\\prime$ 都同余, 关于 $m$ 都不同余; 数列 $y_1,y_1+m^\\prime,y_1+2m^\\prime,\\ldots,y_1+(d-1)m^\\prime$ 中的 $d$ 个数关于 $m^\\prime$ 都同余, 关于 $m$ 都不同余. 所以对于 $(*)$ 式中的每一个解, 都能在原同余式中生成 $d^2$ 个解. 由于 $(*)$ 式共有 $m^\\prime$ 个解, 我们得出原同余式共有 $d^2m^\\prime=dm$ 个解. $\\square$ 如上述各命题的证明过程有误, 或者有表述含糊的地方, 请不吝在评论区指出. 如有更好的证明方法, 欢迎分享. 参考资料 [1] Kenneth H. Rosen, Instructor's Solutions Manual for Elementary Number Theory and Its Applications, 6th ed, p. 57, 3.5.40, 2011, https://epdf.pub/instructors-solutions-manual-for-elementary-number-theory-and-its-applications-6.html.","link":"/posts/elementary-number-theory-exercises/"},{"title":"Miller–Rabin 素性测试","text":"整理了 Miller–Rabin 素性测试的原理及实现方法. 为了探究一奇数 $n&gt;1$ 是否为素数, 将其用 $e$ 和 $k$ 来表示, 使得 $n-1=2^ek$, 其中 $k$ 为奇数. 根据 Keith Conrad[1] 的推导, 多项式 $x^{n-1}-1=x^{2^ek}-1$ 可以被分解, 直到指数不是 $2$ 的倍数： $$\\begin{aligned}x^{n-1}-1&amp;=x^{2^ek}-1\\\\&amp;=(x^{2^{e-1}k}-1)(x^{2^{e-1}k}+1)\\\\&amp;=(x^{2^{e-2}k}-1)(x^{2^{e-2}k}+1)(x^{2^{e-1}k}+1)\\\\&amp;\\;\\;\\vdots\\\\&amp;=(x^k-1)(x^k+1)(x^{2k}+1)(x^{4k}+1)\\cdots(x^{2^{e-1}k}+1).\\end{aligned}$$ 若 $n$ 为素数, 且 $1\\leq a\\leq n-1$, 那么根据费马小定理, 可知 $a^{n-1}-1\\equiv0\\;({\\rm mod}\\;n)$, 再根据上式的分解过程, 可以得出 $$(a^k-1)(a^k+1)(a^{2k}+1)(a^{4k}+1)\\cdots(a^{2^{e-1}k}+1)\\equiv0\\;({\\rm mod}\\;n).$$ 所以上式中的某一项必须等于 $0\\;({\\rm mod}\\;n)$, 也就是 $$a^k\\equiv1\\;({\\rm mod}\\;n)\\;\\text{or}\\;a^{2^ik}\\equiv-1\\;({\\rm mod}\\;n)\\;\\text{for some}\\;i\\in\\{0,\\ldots,n-1\\}.$$ 像 Fermat test、Miller–Rabin test 等基于概率的素性测试算法, 目的是找出能够证明 $n$ 是合数的证据. 若找不到这样的证据, 那么 $n$ 很可能是素数. 用这类方法找出的素数称为伪素数(pseudo prime). 对于一个奇数 $n&gt;1$, 在 $\\{1,\\ldots,n-1\\}$ 中取一整数 $a$, 如果某个 $a$ 使上式不成立, 也就是 $$a^k\\not\\equiv1\\;({\\rm mod}\\;n)\\;\\text{and}\\;a^{2^ik}\\not\\equiv-1\\;({\\rm mod}\\;n)\\;\\text{for all}\\;i\\in\\{0,\\ldots,n-1\\},\\quad(*)$$ 那么称这个 $a$ 为一个 Miller–Rabin witness, 在素性测试中, 术语 “witness” 意为某个能够证明 $n$ 为合数的数. 可以证明[1], 若一奇数是合数, 那么 $\\{2,\\ldots,n-2\\}$ 中超过 $75\\%$ 的数都是 Miller–Rabin witness. 所以, 若该算法对一个数进行 $k$ 轮检测, 并判定其为素数, 那么该数确实是素数的可能性至少有 $1-4^{-k}$. 我在 SICP 的 练习 1.28 中用 Scheme 实现了该素性测试, 其中用非平凡平方根(nontrivial square root) 的概念巧妙地找出了 Miller–Rabin witness, 关键点是修改后的 expmod 过程, 在本来执行 square 的地方加入了检测非平凡平方根的过程. 我也用 C++ 实现了一遍, 当然不再是递归版的, 思考方式变化极大, 不过更加直接地体现了 $(*)$ 式. Miller-Rabin.cpp12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll expmod(ll base, ll ex, ll mod){ ll ans = 1, x = base; while (ex) { if (ex &amp; 1) ans = (ans * x) % mod; x = (x * x) % mod; ex &gt;&gt;= 1; } return ans;}bool miller_rabin(ll n, int rounds){ ll k = n - 1, e = 0; while (!(k &amp; 1)) k &gt;&gt;= 1, ++e; while (rounds--) { ll a = (rand() % (n - 1)) + 1, b = expmod(a, k, n); if (b == 1 || b == n - 1) continue; bool composite = true; for (int i = 1; composite &amp;&amp; i &lt; e; ++i) if ((b = (b * b) % n) == n - 1) composite = false; if (composite) return false; } return true;} 参考资料 [1] Keith Conrad, “The Miller–Rabin Test,” https://kconrad.math.uconn.edu/blurbs/ugradnumthy/millerrabin.pdf.","link":"/posts/miller-rabin/"},{"title":"My Impression of Hexo","text":"Struggled for hours tweaking themes and preferences, I finally end up with this. Hexo was amazing, that simple and elegant writing experience really captivates me.","link":"/posts/my-impression-of-hexo/"},{"title":"2020牛客寒假算法基础集训营5","text":"解题报告 ( ABCDEFGHIJ ) 比赛链接：2020牛客寒假算法基础集训营5 A. 模板题目描述牛牛，牛可乐和牛能组成了一只队伍参加ACM系列赛事，他们起了一个优雅的队名叫~“牛牛战队”。 牛牛战队在没有比赛的时候，会把各种板子放在密码柜里，防止弄丢。这一个密码由整个队伍掌管。其中牛牛和牛能有两个密钥，各自有一个仅由大写字母构成的字符串。牛可乐则掌握着解密方法。一天，你用一瓶可乐贿赂牛可乐，得到了解密的办法： 牛可乐将试图通过以下操作用尽可能少的步骤把一个密钥转换为另一个： 将其中任意一个字母替换为另一个 把最后一个字母删除 在尾部添加一个字母 得到的转化步数就是最后的密码。 一天，你和他们队员一起聚餐，你用可乐把他们灌倒了，从牛牛和牛能口中套出了两个密钥。你要趁他们醒之前拿到模板并复印一份再放回去。你能尽快的算出密码吗？ 输入描述输入数据共 $3$ 行，第一行包括两个整数 $n,m\\,(1\\leq n,m\\leq10^5)$ 表示两个密钥的长度 第二行包含一个长度为 $n$ 的字符串 $s_1$ 表示第一个密钥。 第三行包含一个长度为 $m$ 的字符串 $s_2$ 表示第二个密钥。 输出描述在一行内输出一个整数，表示密码。 示例输入1234 3WXYZWXY 输出11 题解由于插入和删除操作只能在字符串末尾进行，这题简单了很多。 $$\\text{转化步数}=\\max\\{m,n\\}\\,-\\,\\text{重合的字符个数}$$ 参考代码A.cpp1234567891011121314#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = l, i##_ = r; i &lt; i##_; ++i)using namespace std;int main(){ int n, m, ans = 0; string a, b; cin &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b; rep(i, 0, min(a.length(), b.length())) if (a[i] == b[i]) ++ans; cout &lt;&lt; max(m, n) - ans &lt;&lt; endl;} B. 牛牛战队的比赛地题目描述由于牛牛战队经常要外出比赛，因此在全国各地建立了很多训练基地，每一个基地都有一个坐标 $(x,y)$&hairsp;。这周末，牛牛队又要出去比赛了，各个比赛的赛点都在 $x$ 轴上。牛牛战队为了方便比赛，想找一个到达训练基地最大距离最小的地方作为比赛地。这个问题对于牛牛战队太简单了，它就交给了你，你来帮他算一下~ 输入描述输入数据第一行包含一个整数 $N\\, (1\\leq N\\leq100,000)$，表示牛牛战队训练基地的数量。 接下来 $N$ 行，每行包括 $2$ 个整数 $x,y\\, (-10,000\\leq x,y\\leq10,000)$，表示每一个训练基地的坐标。 输出描述输出一个小数，表示选择的比赛地距离各训练基地最大距离的最小值。 如果你的答案是 $a$，标准答案是 $b$，当 $|a-b|\\leq10^{-4}$ 时，你的答案将被判定为正确。 示例输入123430 02 00 2 输出12 说明当在 $(0,0)$ 比赛时，到三个训练基地的最大距离是 $2$&hairsp;。可以证明这是最小值。 题解这道题需要对半径使用二分法，判断一个半径是否合法，合法则缩小半径，不合法则扩大半径。 如何判断一个半径是否合法（即 “这个半径的圆是否有可能囊括所有点”）呢？ 若一个半径合法，一定存在一个区间（或一点），使以区间上任一点为圆心的圆，都能囊括所有的点。我们只需记录下这个区间的左端点和右端点即可。判断时需遍历所有点，遍历时使用 $(x[i]-k,x[i]+k)$ 与原区间的交集更新区间（如图）。 若最终区间存在，则半径合法，否则不合法。 参考代码B.cpp1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int MAX_N = 1e5 + 7;double xs[MAX_N], ys[MAX_N];int n;bool check(double rad){ double l = -10010.0, r = 10010.0, rsqr = rad * rad; for (int i = 0; i != n; ++i) { if (abs(ys[i]) &gt; rad) return false; double k = sqrt(rsqr - ys[i] * ys[i]); if ((l = max(l, xs[i] - k)) &gt; (r = min(r, xs[i] + k))) return false; } return true;}int main(){ scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i != n; ++i) scanf(&quot;%lf%lf&quot;, &amp;xs[i], &amp;ys[i]); double l = 0, r = 10010.0, m; while (r - l &gt; 1e-9) { m = (l + r) / 2.0; (check(m) ? r : l) = m; } printf(&quot;%.9f\\n&quot;, m);} C. C语言IDED. 牛牛与牛妹的约会题目描述牛牛在辛苦的一天的比赛之后，要去找牛妹玩，其实牛妹那天也在比赛。他为了找到牛妹，要尽快的从自己的比赛地到她的比赛地。 还记得吗，比赛地都是只在 $x$ 轴上的，所以两个人的坐标都满足 $y=0$&hairsp;。牛牛除了可以以 $1$ 单位距离/单位时间的速度移动任意时间以外，还可以花费 $1$ 单位时间进行闪现。每次闪现时，如果当前他的坐标是 $x=k$，他将闪现到 $x=\\sqrt[3]{k}$ 的位置。 请帮他算算，最短需要多少时间，他可以找到牛妹~ 输入描述输入数据包括多组用例，输入第一行包含一个数字 $T\\,(1\\leq T\\leq5\\times10^5)$，表示数据组数。 接下来 $T$ 行，每行包括两个整数 $a,b\\,(|a|,|b|\\leq10^6)$，表示牛牛所在的位置和牛妹所在的位置。 输出描述输出共 $T$ 行，每行包括一个实数，表示牛牛所花费的最短时间。 如果你的答案是 $a$，标准答案是 $b$，当 $|a-b|\\leq10^{-6}$ 时，你的答案将被判定为正确。 示例输入12323 -11 2 输出123.4422495701.000000000 题解为了使时间尽量短，一定是闪现在前，移动在后。不停闪现，直到闪现能够缩短的距离小于 $1$，之后用移动来补全剩下的距离。 参考代码D.cpp12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int T, _a, _b; double ans, a, b, t; cin &gt;&gt; T; while (T--) { cin &gt;&gt; _a &gt;&gt; _b; a = _a, b = _b; ans = 0.0; while (true) { t = cbrt(a); if (1.0 + abs(t - b) &lt; abs(a - b)) { ans += 1.0; a = t; } else { ans += abs(a - b); break; } } printf(&quot;%.9f\\n&quot;, ans); }} E. Enjoy the game题目描述牛牛战队的三个队员在训练之余会自己口胡了一些题当做平时的益智游戏。有一天牛可乐想出了一个小游戏给另外两名队员玩，游戏规则如下： 初始一共有 $n$ 张卡牌 先手第一步最少要拿 $1$ 张牌，最多要拿 $n−1$ 张牌。 接下来每一步，双方最少要拿 $1$ 张牌，最多拿等同于上一步对方拿的牌数的牌。 拿走最后一张牌的人将取得游戏的胜利。 你作为旁观者，看着他们玩得很开心，想参与到这场游戏中来，赌一赌谁会能赢。 输入描述输入数据包含一个整数 $n\\,(2\\leq n\\leq10^{18})$，表示初始卡牌张数。 输出描述如果先手有必胜策略，输出 Bob，否则输出 Alice&hairsp;。 示例输入12 输出1Alice 说明先手必须拿走一张牌，然后后手拿走了另一张牌，游戏结束。 题解这题是我比较喜欢的一题，考察了你的思维方式。拿到这题的第一想法是在纸上模拟一下，找找规律，模拟的过程中，我发现： 若纸牌张数为奇数，是一定有必胜策略的，只要一开始只拿一张牌，两人轮流拿牌后一定是自己拿到最后一张牌。 若纸牌张数为偶数，那么为了不输，拿牌的一方一定是拿偶数张牌的，否则接下来对方会只拿一张牌，并在轮流拿牌后拿到最后一张牌。既然双方为了不输都会拿偶数张牌，我们就可以将牌两两合并，将相邻的两张牌看作一张，从而将问题转化为只有半数牌的情况。 找到了如上规律，我们就可以解决这个问题了。以 $12$ 张牌的情况举例，我们可以将其等同为 $6$ 张牌的情况，进而等同为 $3$ 张牌的情况。$3$ 为非 $1$ 的奇数，所以是有必胜策略的。事实上，只有当牌数为 $ 2^n (n\\in\\mathbf{N}^{*})$ 时，是没有必胜策略的。 参考代码E.cpp12345678#include &lt;bits/stdc++.h&gt;int main(){ long long n; scanf(&quot;%lld&quot;, &amp;n); puts((n &amp; (-n)) == n ? &quot;Alice&quot; : &quot;Bob&quot;);} 未完待续……","link":"/posts/nowcoder-2020-winter-camp-5/"},{"title":"2020牛客寒假算法基础集训营6","text":"解题报告 ( ABCDEFGHIJ ) 2020-02-18 增加H题题解 比赛链接：2020牛客寒假算法基础集训营6 A. 配对题目描述现在有正整数集合 $A$ 和 $B$，每个集合里有 $N$ 个数，你要建立他们间的一一映射将每对配对的数字相加可以得到 $N$ 个和，你要做的就是最大化第 $K$ 大的和$1\\leq K\\leq N\\leq100,000$ 输入的所有数字不超过 $10^8$ 输入描述第一行 $2$ 个数字 $N,K$接下来两行，每行 $N$ 个正整数，分别表示 $A$ 和 $B$ 中的元素 输出描述一行，表示第 $K$ 大的和的最大值 示例输入1233 21 2 31 2 3 输出15 题解为了使相加后第 $K$ 大的数最大，应该将 $A$ 序列前 $K$ 大的数，与 $B$ 序列前 $K$ 大的数相配对。 如此看来，可以只保留 $A$ 序列和 $B$ 序列前 $K$ 大的项，而直接舍弃所有后面的项。此时题目便转化为了：将 $A$ 序列和 $B$ 序列前 $K$ 大的项配对求和，求和后序列的最小值最大是多少？ 为了使最小值尽量大，可以将 $A$ 序列由大到小排序，$B$ 序列由小到大排序，并逐项相加。最后求出序列的最小值，就是答案。 参考代码A.cpp1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = l, i##_ = r; i &lt; i##_; ++i)using namespace std;constexpr int MAX_N = 1e5 + 7;int A[MAX_N], B[MAX_N];int main(){ int n, k; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); rep(i, 0, n) scanf(&quot;%d&quot;, &amp;A[i]); rep(i, 0, n) scanf(&quot;%d&quot;, &amp;B[i]); sort(A, A + n, greater&lt;int&gt;()); sort(B, B + n); for (int i = 0; i != k; ++i) A[i] += B[i + n - k]; int ans = A[0]; rep(i, 1, k) if (A[i] &lt; ans) ans = A[i]; printf(&quot;%d\\n&quot;, ans);} B. 图题目描述现在有一个 $N$ 个点的有向图，每个点仅有一条出边（有可能出现自环）你需要求出图中最长的简单路径包含点的数量$(1\\leq N\\leq1,000,000)$ 输入描述第一行，一个数字 $N$接下来 $N$ 行，每行一个正整数，第 $i+1$ 行的数字表示第 $i$ 个点出边终点的编号（点从 $1$ 开始标号） 输出描述一行一个数字，最长的简单路径的长度 示例输入12343232 输出13 题解简单路径即不重复经过同一点的路径，这题考察了深度优先搜索技巧。记录下某一点所指向的点&hairsp;$(to_i)$，该点是否已被访问过&hairsp;$(vis_i)$，以及以该点为起点最多经过多少点&hairsp;$(len_i)$&hairsp;。 具体实现方法见代码。 参考代码B.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int MAXN = 1e6 + 7;bool vis[MAXN];int len[MAXN], to[MAXN];int ans;void dfs(int x){ vis[x] = true; if (vis[to[x]]) { if (len[to[x]]) { len[x] = len[to[x]] + 1; } else { int curr = to[x], cnt = 1; while (curr != x) { ++cnt; curr = to[curr]; } curr = to[x]; while (curr != x) { len[curr] = cnt; curr = to[curr]; } len[x] = cnt; } } else { dfs(to[x]); if (!len[x]) len[x] = len[to[x]] + 1; } if (len[x] &gt; ans) ans = len[x];}int main(){ int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;to[i]); for (int i = 1; i &lt;= n; ++i) if (!vis[i]) dfs(i); printf(&quot;%d\\n&quot;, ans);} C. 汉诺塔题目描述现在你有 $N$ 块矩形木板，第 $i$ 块木板的尺寸是 $X_i\\times Y_i$，你想用这些木板来玩汉诺塔的游戏。我们知道玩汉诺塔游戏需要把若干木板按照上小下大的顺序堆叠在一起，但因为木板是矩形，所以有一个问题：第 $i$ 块木板能放在第 $j$ 块木板上方当且仅当 $X_i &lt; X_j$ 且 $Y_i &lt; Y_j$，于是你很可能没法把所有的木板按照一定的次序叠放起来。你想把这些木板分为尽可能少的组，使得每组内的木板都能按照一定的次序叠放。你需要给出任意一种合理的分组方案。提醒：“任意” 意味着你的答案不必和标准输出完全一致，只要正确即可。 输入描述第一行，一个正整数 $N$接下来 $N$ 行，每行两个正整数表示 $X_i$ 和 $Y_i$对于所有的数据 $1\\leq N\\leq100,000$ 且 $1\\leq X_i,Y_i\\leq N$，$X_i$ 互不相等且 $Y_i$ 互不相等 输出描述输出文件包含两行，第一行一个正整数，表示最少组数第二行 $N$ 个正整数，依次表示你的方案中每块木板分在了哪一组组的编号必须是从 $1$ 开始的连续整数 示例输入123431 12 33 2 输出1221 1 2 题解待补充 参考代码C.cpp1 D. 重排列题目描述一个序列的重排列是指对这个序列中的元素进行若干次（包括 $0$ 次）交换操作后得到的新序列在本题中，序列中可能出现重复的数字，他们被视作不同的元素例如，序列 $1\\quad1$ 的重排列有两种现在有两个长度为 $N$ 的非负整数序列 $A$ 和 $B$，问有多少种 $A$ 的重排列满足对于所有的 $1\\leq i\\leq N$，有 $A_i\\leq B_i$由于答案可能很大，你只需要输出答案对 $10^9+7$ 取模的结果 输入描述输入第一行，包含一个正整数 $N$接下来一行，$N$ 个非负整数表示序列 $A$再接下来一行，$N$ 个非负整数表示序列 $B$$1\\leq N\\leq100,000$ 且 $0\\leq A_i,B_i\\leq10^9$ 输出描述一行一个整数，表示答案 示例输入12341 1 2 31 2 3 4 输出18 题解首先将 $A$ 序列和 $B$ 序列分别由小到大排序。对于 $B$ 序列的每一项，$A$ 序列中小于这一项的项数可以求出，这项数代表可选的排列方案数。 还要注意的是，已选择的数不能重复选择，需要从方案数里减去已选数的个数。最后将这些方案数相乘即可得出答案： $$Answer =\\prod_{i=1}^{N}(A\\,\\text{序列中不大于}\\,B_i\\,\\text{的项数} - (i-1))$$ 参考代码D.cpp1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = l, i##_ = r; i &lt; i##_; ++i)using namespace std;using ll = long long;constexpr ll MAXN = 1e5 + 7;constexpr ll MOD = 1e9 + 7;ll A[MAXN], B[MAXN];int main(){ int n; ll ans = 1; scanf(&quot;%d&quot;, &amp;n); rep(i, 0, n) scanf(&quot;%lld&quot;, &amp;A[i]); rep(i, 0, n) scanf(&quot;%lld&quot;, &amp;B[i]); sort(A, A + n); sort(B, B + n); rep(i, 0, n) ans = (ans * (upper_bound(A, A + n, B[i]) - A - i)) % MOD; printf(&quot;%lld\\n&quot;, ans);} E. 立方数题目描述对于给定的正整数 $N$，求最大的正整数 $A$，使得存在正整数 $B$，满足 $A^3B=N$输入包含 $T$ 组数据，$1\\leq T\\leq10,000$ 且 $1\\leq N\\leq10^{18}$ 输入描述第一行数字 $T$ 表示数据组数接下来一行，$T$ 个正整数 $N$ 输出描述$T$ 行，每行一个数字表示答案 示例输入12427 24 7 54 输出12343213 题解待补充 参考代码E.cpp1 F. 十字阵列题目描述小Q 新学会了一种魔法，可以对一个 $N$ 行 $M$ 列 的网格上的敌人造成伤害第 $i$ 次使用魔法可以对网格上的一个十字形区域（即第 $x_i$ 行和第 $y_i$ 列的合并）中的每个格子上的敌人造成 $z_i$ 点伤害现在小Q 一共使用了 $H$ 次魔法，你需要在所有的施法完成之后统计造成伤害的情况，详见输出描述提醒：本题输入规模较大，请使用高效的输入方式$1\\leq H\\leq500,000$ 且 $1\\leq x_i,y_i,z_i,N,M\\leq2000$ 且 $1\\leq x_i\\leq N$ 且 $1\\leq y_i\\leq M$ 输入描述第一行 $3$ 个数字 $N,M,H$接下来 $H$ 行，每行 $3$ 个正整数 $x_i，y_i，z_i$ 输出描述为了避免大量的输出，假设第 $i$ 行第 $j$ 列受到的总伤害是 $w_{ij}$你只需要输出 $\\sum{(w_{ij}\\times(i+j))}$ 对 $10^9+7$ 取模的结果即可 示例输入1234565 5 51 1 12 2 23 3 34 4 45 5 5 输出1890 题解加权求和。每个方块的权值是已知的&hairsp;$(i+j)$，一个点对总伤害的贡献，等于该行和该列所有权值的和，乘以伤害。 参考代码F.cpp123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (ll i = l, i##_ = r; i &lt; i##_; ++i)using namespace std;using ll = long long;constexpr ll MOD = 1e9 + 7;void read(ll&amp;a, ll&amp;b, ll&amp;c){ char ch; a = b = c = 0; while ((ch = getchar()) &gt;= '0' &amp;&amp; ch &lt;= '9') a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (ch &amp; 0xf); while ((ch = getchar()) &gt;= '0' &amp;&amp; ch &lt;= '9') b = (b &lt;&lt; 3) + (b &lt;&lt; 1) + (ch &amp; 0xf); while ((ch = getchar()) &gt;= '0' &amp;&amp; ch &lt;= '9') c = (c &lt;&lt; 3) + (c &lt;&lt; 1) + (ch &amp; 0xf);}int main(){ ll n, m, h, x, y, z; read(n, m, h); ll ans = 0, mn = ((m + 1) * m + (n + 1) * n) &gt;&gt; 1; rep(i, 0, h) { read(x, y, z); ans = (ans + (mn + x * m + y * n - x - y) * z) % MOD; } printf(&quot;%lld\\n&quot;, ans);} G. 括号序列题目描述合法括号序列的定义是： 空序列是合法括号序列 如果 $S$ 是一个合法括号序列,那么 $(S)$ 是合法括号序列 如果 $A$ 和 $B$ 都是合法括号序列,那么 $AB$ 是一个合法括号序列 现在给定一个括号序列，求最少删去几个括号能得到一个合法的括号序列输入包含 $T$ 组数据，每组数据中，设括号序列的长度为 $N$$1\\leq T,\\sum^T{(N)}\\leq1,000,000$（由于空串是合法的括号序列，所以答案可以是 $N$） 输入描述第一行一个数字 $T$接下来 $T$ 组数据共 $2T$ 行，每组数据第一行是 $N$第二行则是一个长度为 $N$ 的括号序列 输出描述$T$ 行 $T$ 个数字，表示输入的括号序列最少删去几个括号能得到一个合法的括号序列 示例输入1234526())(()9()(()())) 输出1221 题解记录未封闭的左括号数量。若没有未封闭括号却又出现了右括号，删去；若读取到末尾仍有未封闭括号，说明之前有相同数量的左括号需要删去。 参考代码G.cpp12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;int main(){ int T; scanf(&quot;%d&quot;, &amp;T); while (T--) { int n, cnt = 0, ans = 0; scanf(&quot;%d &quot;, &amp;n); for (int i = 0; i != n; ++i) { if (getchar() == '(') { ++cnt; } else { if (cnt) --cnt; else ++ans; } } printf(&quot;%d\\n&quot;, ans + cnt); }} H. 云题目描述现在天空（可视为二维平面）中有 $N$ 朵 ${\\rm A}$ 类云，$M$ 朵 ${\\rm B}$ 类云，每朵云的形状都可以用边平行于坐标轴的矩形来描述。一开始，${\\rm A}$ 类云在第三象限，${\\rm B}$ 类云在第一象限，没有任何云和坐标轴有交点。随着风的吹拂，${\\rm A}$ 类云以每秒一个单位的速度向右移动，${\\rm B}$ 类云以每秒一个单位的速度向下移动，当一朵 ${\\rm A}$ 类云和一朵 ${\\rm B}$ 类云在某一个时刻有了至少一个公共点，它们就相遇了。现在请你告诉小R，有多少对 ${\\rm A}$ 类云和 ${\\rm B}$ 类云能够相遇。$1\\leq N,M\\leq100,000$ 且 $1\\leq|X_i|,|Y_i|,|P_i|,|Q_i|\\leq10^9$ 注： 本题输入规模较大，请注意输入的效率 输入的云的形状可能为退化的矩形（直线或点） 输入描述输入第一行，包含两个正整数 $N$ 和 $M$接下来 $N$ 行，每行描述一朵 ${\\rm A}$ 类云再接下来 $M$ 行，每行描述一朵 ${\\rm B}$ 类云一朵云的位置用一行四个数 $A_i,B_i,C_i,D_i$ 表示，意为这朵云左上角在 $(A_i,B_i)$，右下角在&hairsp;$(C_i,D_i)$ 输出描述一行一个整数，表示答案 示例输入1231 1-2 -1 -1 -21 2 2 1 输出11 题解这题需要换个角度思考：${\\rm A}$ 类云向右运动，${\\rm B}$ 类云向下运动。只是粗略想想的话，会觉得是个很复杂的运动。 但如果我们在坐标系中添加这样一条辅助线&hairsp;$(x+y=0)$呢？ 如图所示，上述运动便可描述为 “云朵们面对辅助线，向对面的云靠近，并同时向右下角移动”。 我们甚至可以忽略 “并同时向右下角移动”，因为这样并不会影响云彩相遇与否。 如此一来，若两朵云会相遇，它们一定会在辅助线上扫过一个共同的区域。例如，图中红色线段与黑色线段有重合部分，它们一定会相遇。 所以可以采用投影的方法，将云彩投影到辅助线上，得到一条线段，其在辅助线上的覆盖范围是 $[a-b,c-d]$&hairsp;。最后清点有重合部分的线段对数，即可得到答案。 清点前需记录下覆盖范围的端点&hairsp;$(node)$，包括其坐标&hairsp;$(pos)$&hairsp;、左端点还是右端点&hairsp;$(lr)$&hairsp;、${\\rm A}$ 类云还是 ${\\rm B}$ 类云&hairsp;$(type)$&hairsp;。 具体实现见参考代码，参考了牛客上某些大神的已通过代码，一开始看得很懵，不过领悟了这投影的方法就很好理解了。 参考代码H.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int MAXN = 4e5 + 7;struct node { int pos; int lr; int type; bool operator&lt;(const node&amp; rhs) const { if (pos == rhs.pos) return lr &gt; rhs.lr; return pos &lt; rhs.pos; }} nodes[MAXN];int main(){ int n, m, k = 0; int a, b, c, d; long long cnt[2] = {}, ans = 0; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); while (n--) { scanf(&quot;%d%d%d%d&quot;, &amp;a, &amp;b, &amp;c, &amp;d); nodes[k++] = { a - b, 1, 0 }; nodes[k++] = { c - d, -1, 0 }; } while (m--) { scanf(&quot;%d%d%d%d&quot;, &amp;a, &amp;b, &amp;c, &amp;d); nodes[k++] = { a - b, 1, 1 }; nodes[k++] = { c - d, -1, 1 }; } sort(nodes, nodes + k); for (int i = 0; i != k; ++i) { cnt[nodes[i].type] += nodes[i].lr; if (nodes[i].lr == 1) ans += cnt[nodes[i].type ^ 1]; } printf(&quot;%lld\\n&quot;, ans);} I. 导航系统题目描述小Q 所在的国家有 $N$ 个城市，城市间由 $N-1$ 条双向道路连接，任意一对城市都是互通的。每条道路有一个长度，自然，小Q 的导航系统能显示每对城市间的最短距离。但是小Q 对这个系统并不太放心，于是他向你求助：给定每对城市间的最短距离，你要判断距离表是否一定有误。如果这张距离表是自洽的，那么请你按升序依次给出每条道路的长度。对于全部的数据，$1\\leq N\\leq500$，输入的所有数字都是不超过 $10^9$ 的非负整数。 输入描述第一行一个数字 $N$接下来 $N$ 行，每行 $N$ 个正整数第 $i$ 行第 $j$ 列的数字表示城市 $i$ 和城市 $j$ 间的最短距离保证第 $i$ 行第 $i$ 列的数字为 $0$ 输出描述第一行，一个字符串如果距离表没有问题，输出 Yes并在接下来的 $N-1$ 行从小到大给出每条道路的长度否则输出 No 即可 示例1输入123430 1 21 0 12 1 0 输出123Yes11 示例2输入123430 1 11 0 11 1 0 输出1No 题解待补充 参考代码I.cpp1 J. 签到题题目描述现有一个边长为正整数的三角形，问能否以其三个顶点为圆心画三个圆，使三个圆两两外切三边长均不超过 $10^8$ 输入描述三个正整数，表示三角形的边长 输出描述如果三条边不能构成三角形，输出 wtnl如果三条边能构成三角形但不能画出符合要求的圆，输出 No否则输出一行 Yes然后在第二行输出一组方案，按升序给出三个圆的半径，保留两位小数 示例输入12 3 3 输出12Yes1.00 1.00 2.00 题解初中数学？ 参考代码J.cpp12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;int main(){ ll a, b, c; scanf(&quot;%lld%lld%lld&quot;, &amp;a, &amp;b, &amp;c); if (a &gt; b) swap(a, b); if (b &gt; c) swap(b, c); if (a &gt; b) swap(a, b); if (a + b &lt;= c) puts(&quot;wtnl&quot;), exit(0); printf(&quot;Yes\\n%.2f %.2f %.2f\\n&quot;, (double)(b + a - c) / 2.0, (double)(a + c - b) / 2.0, (double)(b + c - a) / 2.0);}","link":"/posts/nowcoder-2020-winter-camp-6/"},{"title":"牛客练习赛58","text":"解题报告 ( ABCDEF ) 这两天为了把E题搞懂，还接触了一些线段树、离线处理的相关知识。虽然这里没有用到线段树，不过它在解决区间问题时是个重要的数据结构，这几天会相应地更新一些探究线段树的文章。 比赛链接：牛客练习赛58 这次练习赛 AB 两题都是签到题，不必多说。 C. 矩阵消除游戏题目描述牛妹在玩一个名为矩阵消除的游戏，矩阵的大小是 $m$ 行 $n$ 列，第 $i$ 行第 $j$ 列的单元格的权值为 $a_{i,j}$​ ，牛妹可以进行 $k$ 个回合的游戏，在每个回合，牛妹可以选择一行或者选择一列，然后将这一行或者这一列的所有单元格中的权值变为 $0$，同时牛妹的分数会加上这一行或者这一列中的所有单元格的权值的和。 求出得分的最大值。 输入描述第一行三个整数 $m,n,k$接下来 $m$ 行每行 $n$ 个整数表示矩阵中各个单元格的权值。 $1\\leq m,n\\leq15$$1\\leq a_{i,j}\\leq10^6$$1\\leq k\\leq m\\times n$ 输出描述输出一个整数表示牛妹能获得的最大分数。 示例输入12343 3 2101 1 1021 202 1100 8 100 输出1414 题解这题尝试了不少策略，都是贪心策略，不过都是错的。还没有想到什么更好的办法，那就暴力搜索吧…… 一共取 $k$ 行 / 列，那么就先试着取 $0$ 行 $k$ 列，再试着取 $1$ 行 $k-1$ 列…… 逐次枚举。 参考代码C.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int maxn = 1e6 + 7;int m, n, k;int mat[20][20];int ans;int cols_max(int num){ int sum[20] {}, res = 0; for (int i = 0; i != n; ++i) for (int j = 0; j != m; ++j) sum[i] += mat[j][i]; sort(sum, sum + n, greater&lt;int&gt;()); for (int i = 0; i != num; ++i) res += sum[i]; return res;}void dfs(int row, int num = 1, int sum = 0){ if (num == k + 1) return; int rec[20], rsum = 0, tmp; for (int i = 0; i != n; ++i) { rec[i] = mat[row][i]; rsum += rec[i]; mat[row][i] = 0; } if ((tmp = sum + rsum + cols_max(k - num)) &gt; ans) ans = tmp; for (int i = row + 1; i != m; ++i) dfs(i, num + 1, sum + rsum); for (int i = 0; i != n; ++i) mat[row][i] = rec[i];}int main(){ scanf(&quot;%d%d%d&quot;, &amp;m, &amp;n, &amp;k); int sum = 0; for (int i = 0; i != m; ++i) for (int j = 0; j != n; ++j) { scanf(&quot;%d&quot;, &amp;mat[i][j]); sum += mat[i][j]; } if (k &gt;= min(m, n)) printf(&quot;%d\\n&quot;, sum), exit(0); ans = cols_max(k); for (int i = 0; i != m; ++i) dfs(i); printf(&quot;%d\\n&quot;, ans);} D. 迷宫题目描述有一个 $m\\times n$ 的迷宫，迷宫中每个格子用 $0$ 或 $1$ 表示，$0$ 表示该格子可以通过，$1$ 表示该格子是个障碍物，牛妹站在格子 $(1,1)$，出口在格子 $(m,n)$，牛妹想要走出迷宫，但牛妹只会按以下策略走： 牛妹当前所在的格子称为当前格子 如果当前格子右边没有障碍物，牛妹就向右走，否则转到2 如果当前格子下方没有障碍物，牛妹就向下走，否则转到3 如果当前格子左边没有障碍物，牛妹就向左走，否则转到4 如果当前格子上方没有障碍物，牛妹就向上走，否则转到5 牛妹站在原地不动 由于牛妹按这样的策略可能会无法走到出口，牛妹的好朋友牛牛决定在牛妹离开格子 $(1,1)$ 前把迷宫中的一些非障碍格子变成障碍，帮助牛妹走出迷宫，但是牛牛比较懒，他想要最小化变成障碍的非障碍格子的数量。 输入描述第一行两个整数 $m,n$ 表示迷宫的大小接下来 $m$ 行每行一个长度为 $n$ 的 $01$ 串表示迷宫的格局 $1\\leq n,m\\leq1000$ 输出描述输出一个整数表示牛牛最少需要转换成障碍格子的非障碍格子的数量，如果无法帮助牛妹走出迷宫，输出 -1&hairsp;。 示例输入123454 40000011001100000 输出10 题解这题给出的五条行走策略，有点吓唬人，实际上可以缩减为这两条： 若右边没有障碍物，向右走一格，否则转到2 若下边没有障碍物，向下走一格 这两条都不符合的话，则无法到达终点。如果在某个位置可以向左走一格，下一步一定又得回到右边，从而左右来回移动，无法到达终点。 有了这两条，即只能向右或者向下走，这个问题就可以用记忆化搜索，或者动态规划来解决了。使用一个表格&hairsp;$(dp)$来记录结果。其中 $dp[i][j]$ 的含义是 “从 $(1,1)$ 位置走到 $(i,j)$ 位置总共放置的障碍物的最少个数”。那么，$(i,j)$ 取终点位置时，表中的便是这题的结果。 $$dp[i][j]=\\begin{cases}0&amp;,i=1,j=1\\\\dp[i][j-1]&amp;,i=1,j&gt;1\\\\dp[i-1][j]&amp;,i&gt;1,j=1\\\\\\min\\{dp[i][j-1],dp[i-1][j]+1\\}&amp;,(i-1,j+1)\\text{处没有障碍物}\\\\\\min\\{dp[i][j-1],dp[i-1][j]\\}&amp;,\\text{否则}\\end{cases}$$ 仅当右边和下边都没有障碍物，却坚持要向下走时，需要在右边加一个障碍物。这就是上式第四条的含义。 我写了两个版本的代码，最终发现，动态规划比记忆化搜索快了近十倍。 统计数组访问（存 / 取）次数后大概分析了一下，这大概是因为动态规划只需要记忆化搜索一半不到的访问量，加之没有函数递归调用的开销。 参考代码 (Memory Searching)D_MS.cpp1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int maxn = 1007;int m, n;char mat[maxn][maxn];int dp[maxn][maxn], vis[maxn][maxn];int dfs(int x, int y){ if (vis[x][y]) return dp[x][y]; vis[x][y] = 1; if (y != n - 1 &amp;&amp; mat[x][y + 1] == '0') dp[x][y] = min(dp[x][y], dfs(x, y + 1)); if (x != m - 1 &amp;&amp; mat[x + 1][y] == '0') { if (y != n - 1 &amp;&amp; mat[x][y + 1] == '0') dp[x][y] = min(dp[x][y], dfs(x + 1, y) + 1); else dp[x][y] = min(dp[x][y], dfs(x + 1, y)); } return dp[x][y];}int main(){ scanf(&quot;%d%d&quot;, &amp;m, &amp;n); memset(dp, 0x3f, sizeof(dp)); dp[m - 1][n - 1] = 0; for (int i = 0; i != m; ++i) scanf(&quot;%s&quot;, mat[i]); if (dfs(0, 0) == 0x3f3f3f3f) puts(&quot;-1&quot;), exit(0); printf(&quot;%d\\n&quot;, dp[0][0]);} 参考代码 (Dynamic Programming)D_DP.cpp1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int maxn = 1007;int m, n;char mat[maxn][maxn];int dp[maxn][maxn];int main(){ scanf(&quot;%d%d&quot;, &amp;m, &amp;n); for (int i = 1; i &lt;= m; ++i) scanf(&quot;%s&quot;, mat[i] + 1); memset(dp, 0x3f, sizeof(dp)); dp[1][1] = 0, mat[1][1] = '1'; for (int i = 1; i &lt;= m; ++i) for (int j = 1; j &lt;= n; ++j) { if (mat[i][j] == '1') continue; dp[i][j] = min(dp[i][j - 1], dp[i - 1][j] + (mat[i - 1][j + 1] == '0' ? 1 : 0)); } if (dp[m][n] == 0x3f3f3f3f) puts(&quot;-1&quot;), exit(0); printf(&quot;%d\\n&quot;, dp[m][n]);} E. 最大GCD题目描述给出长度为 $n$ 的序列，序列中有 $n$ 个元素 $a_1,a_2,\\ldots a_n$​，你需要进行 $q$ 次查询，每次查询形如以下格式： $l\\;r\\;x$：你需要选择两个整数 $s,t$ 满足 $l\\leq s\\leq t\\leq r$，使得 $\\gcd(a[s],a[s+1],\\ldots,a[t−1],a[t],x)$ 最大化。 输入描述第一行两个整数 $n,q$第二行 $n$ 个整数 $a_1,a_2,\\ldots a_n$​接下来 $q$ 行每行三个整数表示一个查询 $1\\leq l\\leq r\\leq n,q,x,a_i​\\leq10^5$ 输出描述对于每个查询输出一个整数表示 $\\gcd(a[s],a[s+1],\\ldots,a[t−1],a[t],x)$ 的最大值。 示例输入12344 22 4 3 61 3 61 4 10 输出1232 题解看到这题，我懵圈了好久。查询时 “使得 $\\gcd(a[s],a[s+1],\\ldots,a[t−1],a[t],x)$ 最大化” 的这个步骤怎么解决？ 实际上是出题人在吓唬人，由于 $\\gcd$ 的特殊性质，选取的数越多只会让结果越小。所以查询的实际步骤是 “在 $\\{a[l],a[l+1],\\ldots,a[r]\\}$ 里取一个数 $a_i$，使得 $\\gcd(a_i,x)$ 最大化”。 首先想到的是最朴素的做法： 对于每一次查询，都将 $[l,r]$ 区间里的每一个数与 $x$ 求最大公约数，途中记录下最大的一个。 但是这样做的时间复杂度大致是 $O(nq\\log(x))$，最坏情况下能达到 $10^{10}$ 数量级，不可行。 涉及到最大公因数的问题，如果朴素的算法不能解决，那么从因子的角度去考虑无疑是一个有益的尝试： 首先将所有数的所有因子预存起来 对于每一次查询，从大到小枚举 $x$ 的因子，对 $[l,r]$ 区间里的每一个数，判断其是否有这个因子。如果枚举过程中出现了共有的因子，这个因子就是要查询的最大值。 可以给所有数建一个 vector&lt;int&gt;，存储其所有的因子。因子的大小是有序的，这样对于 $x$ 的每个因子，使用二分查找就能在 $O(\\log n)$ 的时间复杂度下判断一个数是否有这个因子。 这样做的时间复杂度大致是 $O(nq\\log(F)),F$ 为某个数的因子个数。由于 $[1,10^5]$ 范围内每个数的因子最多也就 $128$ 个，二分查找因子的速度很快。虽然速度比一开始快了一些，最坏情况下还是达到了 $10^{10}$ 数量级，仍然不可行。 所以接下来，要引进离线处理的方法，什么是离线处理？离线处理即不考虑对查询进行立即答复，而是将问题集中起来，最后统一答复。等到所有问题都聚集起来的时候，我们对其分析，往往可以发现各个查询之间有某些关联，利用这些关联得以更有效地解决问题。 具体到这一题，我们采用离线处理的方法，将查询全部读入后，按照区间右端点的顺序排序 (为什么是按右端点的顺序排序？往下看)。 之前，查询每个因子，都要重新枚举一次区间里的每一个数，这样效率明显太低。于是可以创建一个数组 $rec$，其中 $rec_i$ 的值表示因子 $i$ 出现的最右位置。每次查询前，需要将 $rec$ 数组更新到右端点 (具体见下方的 update 函数)。之后，对于 $x$ 的某个因子 $i$，只需判断其出现的最后位置是否在查询的左端点之后，即 $rec_i\\geq l$ 是否成立，就可以得知其是否在 $[l,r]$ 区间里出现过。 所以，按照右端点排序的理由就明确了，这样排序的话，可以确保 $rec$ 数组中存储的最右位置不超过当前查询的右端点。 这样做，需要更新的次数是所有查询右端点的最大值 (最大是 $n$&hairsp;)，每次查询需要 $F$ 次访问 $rec$ 数组 ($F$ 为某个 $x$ 的因子个数)。所以最坏情况下的时间复杂度是 $O(nF+qF)$，大约是 $10^6$ 数量级，符合要求。 参考代码E.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int maxn = 1e5 + 7;struct query { int l, r, x, idx;} Q[maxn];int n, q;int a[maxn], rec[maxn], ans[maxn];vector&lt;int&gt; fact[maxn];void init(){ memset(rec, -1, sizeof(rec)); for (int i = 1; i &lt; maxn; ++i) for (int j = i; j &lt; maxn; j += i) fact[j].push_back(i);}void update(int x, int pos){ for (int&amp; val : fact[x]) rec[val] = pos;}int main(){ init(); scanf(&quot;%d%d&quot;, &amp;n, &amp;q); for (int i = 0; i != n; ++i) scanf(&quot;%d&quot;, &amp;a[i]); for (int i = 0; i != q; ++i) scanf(&quot;%d%d%d&quot;, &amp;Q[i].l, &amp;Q[i].r, &amp;Q[i].x), Q[i].idx = i; sort(Q, Q + q, [](const query&amp; a, const query&amp; b) -&gt; bool { return a.r &lt; b.r; }); int pos = 0; for (int i = 0; i != q; ++i) { int l = Q[i].l - 1, r = Q[i].r - 1, &amp;x = Q[i].x, &amp;idx = Q[i].idx; while (pos &lt;= r) update(a[pos], pos), ++pos; for (auto it = fact[x].rbegin(), it_ = fact[x].rend(); it != it_; ++it) if (rec[*it] &gt;= l) { ans[idx] = *it; break; } } for (int i = 0; i != q; ++i) printf(&quot;%d\\n&quot;, ans[i]);} F. XOR TREE","link":"/posts/nowcoder-practice-58/"},{"title":"Secretary Problem","text":"“Imagine there are eight roses in your garden; you inspect them one-by-one randomly. Take the first three roses you encounter as sample and go on. Once you encounter a rose more beautiful than any of the first three roses, you pick it up and stop. How likely is it that the one you picked up is the most beautiful one?” At the first sight of the problem, I thought that I could solve it using the methods learned from the second chapter of Concrete Mathematics, and I did managed to. In this post, I will generalize the problem above into the case of $N$ roses and $K$ worth of sample size, then show you how to derive the probability in a closed form, using combination and summation strategies. Let’s say that these roses have “beauty index” from $1$ through $N$, respectively, without duplication, and that $a_n$ is such index of the $n$-th rose you encounter. In this setup, ‘$N$’ is the most beautiful rose; if we will successfully pick up the most beautiful rose, the roses must follow $$\\overbrace{a_1\\;a_2\\;\\ldots\\;a_K}^{\\text{$K$ terms}}\\;\\overbrace{a_{K+1}\\;\\ldots\\;a_j}^{\\text{$(j-K)$ terms}}\\;N\\;\\overbrace{a_{j+2}\\;\\ldots\\;a_N}^{\\text{$(N-j-1)$ terms}},\\quad\\text{for $K\\leq j\\lt N$,}$$ where you pick up the $(j+1)$-th rose you inspect, which is also the most beautiful rose. In order for this to happen, all terms from $a_{K+1}$ through $a_j$ must be less than $k=\\max(a_1,a_2,\\ldots,a_K)$; there are $k$ such terms, but $K$ of them are already in $a_1\\,a_2\\,\\ldots\\,a_K$. So, at most $(k-K)$ terms are available to settle between ‘$a_K$’ and ‘$N$’, hence $j$ is at most $k$. That means, if $k=\\max(a_1,a_2,\\ldots,a_K)$, the probability that you pick up the right rose is $\\sum_{j=K}^k\\frac{(N-j-1)!(k-K)^{\\underline{j-K}}}{(N-K)!}$. (Note that $n^{\\underline k}$ can denote the number of permutations of $k$ elements out of $n$ elements.) (This refers to the notation of falling factorial powers, defined by the rule $n^{\\underline k}=n(n-1)\\cdots(n-k+1)$. More of its properties are described in Concrete Mathematics Chapter 2, partially available in my notes.) Alright, we will readily be able to evaluate the probability if we know how often $\\max(a_1,a_2,\\ldots,a_K)$ equals to a specific $k$; let the probability be $Q(k)$. What we do is randomly choosing $K$ roses out of $N$ roses, and the largest of them is $k$. In other words, one of the choices must be the rose $k$, and the rest $(K-1)$ choices are made within $(k-1)$ roses that are less beautiful than the rose $k$. It’s now easy to see that $$\\begin{aligned}Q(k)&amp;=\\frac{\\binom{k-1}{K-1}}{\\binom NK}\\\\&amp;=\\frac K{N^{\\underline K}}(k-1)^{\\underline{K-1}},\\quad\\text{for $k\\geq K$.}\\end{aligned}$$ To sum up all what was said above, let $P_{N,K}$ be the ultimate probability we’ve been pursuing. We have $$\\begin{aligned}P_{N,K}&amp;=\\sum_{k=K}^{N-1}Q(k)\\sum_{j=K}^k\\frac{(N-j-1)!(k-K)^{\\underline{j-K}}}{(N-K)!}\\\\&amp;=\\sum_{k=K}^{N-1}\\frac K{N^{\\underline K}}(k-1)^{\\underline{K-1}}\\sum_{j=K}^k\\frac{(N-j-1)!(k-K)^{\\underline{j-K}}}{(N-K)!}\\\\&amp;=\\frac K{N^{\\underline K}(N-K)!}\\sum_{k=K}^{N-1}\\sum_{j=K}^k(N-j-1)!(k-1)^{\\underline{K-1}}(k-K)^{\\underline{j-K}}\\\\&amp;=\\frac K{N!}\\sum_{k=K}^{N-1}\\sum_{j=K}^k(N-j-1)!(k-1)^{\\underline{K-1}}(k-K)^{\\underline{j-K}}\\\\&amp;=\\frac K{N!}\\sum_{k=K}^{N-1}\\sum_{j=K}^k(N-j-1)!(k-1)^{\\underline{j-1}}\\\\&amp;=\\frac K{N!}\\sum_{K\\leq k\\lt N}\\sum_{K\\leq j\\leq k}(N-j-1)!(k-1)^{\\underline{j-1}}\\\\&amp;=\\frac K{N!}\\sum_{K\\leq j\\lt N}\\sum_{j\\leq k\\lt N}(N-j-1)!(k-1)^{\\underline{j-1}}\\\\&amp;=\\frac K{N!}\\sum_{K\\leq j\\lt N}(N-j-1)!\\sum_{j\\leq k\\lt N}(k-1)^{\\underline{j-1}}\\\\&amp;=\\frac K{N!}\\sum_{K\\leq j\\lt N}(N-j-1)!\\frac{(N-1)^{\\underline j}-(j-1)^{\\underline j}}j\\\\&amp;=\\frac K{N!}\\sum_{K\\leq j\\lt N}\\frac{(N-j-1)!(N-1)^{\\underline j}}j\\\\&amp;=\\frac K{N!}\\sum_{K\\leq j\\lt N}\\frac{(N-1)!}j\\\\&amp;=\\frac{K(N-1)!}{N!}(H_{N-1}-H_{K-1})\\\\&amp;=\\frac KN(H_{N-1}-H_{K-1}),\\end{aligned}$$ where $H_k$ is the $k$-th harmonic number, $H_k=1+\\frac12+\\cdots+\\frac1k$. Here are some critical observations about the steps above: From line 6 to line 7, I interchanged the order of summation, such that $(N-j-1)!$ could be factored out. From line 8 to line 9, I used the rule $$\\sum_{a\\leq n\\lt b}x^{\\underline m}=\\frac{b^{\\underline{m+1}}-a^{\\underline{m+1}}}{m+1},\\quad\\text{for $m\\neq-1$.}$$ In line 9, $(j-1)^{\\underline j}=0$, by the definition of falling factorial powers. Back to our initial problem, we have $N=8$ and $K=3$; thus $$\\begin{aligned}P_{8,3}&amp;=\\frac38(H_7-H_2)\\\\&amp;=\\frac38\\left(\\frac13+\\frac14+\\frac15+\\frac16+\\frac17\\right)\\\\&amp;=\\frac{459}{1120}.\\end{aligned}$$ RemarksSo far, I have derived means of evaluating the probability given $N$ and $K$. Further derivations such as methods of optimizing the probability are still under investigation.","link":"/posts/secretary-problem/"},{"title":"线段树之懒惰标记","text":"最近在学习线段树的有关知识，期间遇到的重要的知识点和不错的习题，我会总结并记录下来，本系列将持续更新。当前的索引如下： [x]-基本概念[x]-懒惰标记[ ]-&hellip;&hellip; 为什么引入懒惰标记？懒惰标记的用处，就是更快地实现实现区间修改、区间查询。 考虑之前讲到的线段树。如果用线段树的单点修改，我们需要先改变叶子节点的值，然后不断地向上递归修改祖先节点直至到达根节点，时间复杂度最高可以到达 $O(n\\log n)$ 的级别，这还只是单次操作，更别说有 $10^5$ 次指令的情况了。 该怎么实现？其实就是用一个暂时不处理，等到需要用到的时候再进行处理的思想。 我们想，如果已经到达了属于答案区间范围内的节点，我们就直接对该节点进行一系列的操作，然后直接返回。这样，一定能保证本次区间更新的正确性。然而，区间更新不只一次，如果照刚刚那样更新而不进行任何后处理的话，那么该节点的子节点都未更新，势必会导致答案错误。于是，我们需要一种东西来记录下节点的更新信息，以便下次更新时处理。 所以引入一个名叫懒惰标记(lazytag) 的东西。之所以称其为 lazytag，是因为当我们引入懒惰标记后，我们不会去更新已经覆盖答案区间的子节点，只有在接下来的操作中我们才可能会用到该区间的子区间。所以这次操作就无需更新。区间更新的期望复杂度就降到了 $O(\\log n)$ 的级别。 之前遇到的，只有单次修改、查询的情况，都是子区间向父区间传递信息，称之为 pushup。而这次将懒惰标记向下传递，不就是反过来，是父区间向子区间传递信息吗？我们将向下传递操作称为 pushdown。 线段树使用分治法，用递归进行实现。显然，子区间向父区间传递信息，应该在递归地操作子区间之后。而我们为了保证子区间的数据在操作其之前已被更新，就需要在递归操作之前，从父区间向子区间传递消息。 于是，以区间整体加上一个数的操作为例，就可以如此标记： 1234567891011121314151617181920212223242526272829303132333435363738/** * ls[p] p节点的左端点 * rs[p] p节点的右端点 * sum[p] p节点的区间和 * lazy[p] p节点的懒惰标记 */#define chl (p * 2 + 1)#define chr (p * 2 + 2)void pushdown(int p){ // 子区间和 += (子区间的元素个数) * 父区间的懒标记 sum[chl] += (rs[chl] - ls[chl]) * lazy[p]; sum[chr] += (rs[chr] - ls[chr]) * lazy[p]; // 父区间的懒标记传递给子区间 lazy[chl] += lazy[p]; lazy[chr] += lazy[p]; // 清零父区间的懒惰标记 lazy[p] = 0;}void modify(int x, int y, int val, int p = 0){ if (x &lt;= ls[p] &amp;&amp; rs[p] &lt;= y) { sum[p] += (rs[p] - ls[p]) * val; lazy[p] += val; return; } pushdown(p); int mid = (ls[p] + rs[p]) &gt;&gt; 1; if (rs[p] &lt;= mid) return modify(x, y, val, chl); if (ls[p] &gt;= mid) return modify(x, y, val, chr); modify(x, mid, val, chl); modify(mid, y, val, chr);} 我认为懒惰标记的使用，最重要的就是如何 pushdown 了，下面的几道题目很能说明问题。 【习题】线段树 2提供一个序列，要求你维护三种操作： 将某区间每一个数乘上 $x$ 将某区间每一个数加上 $x$ 求出某区间每一个数的和 题解在洛谷中作为一道模板题，这道题实在是太虐心了。不过不得不承认，做完以后对线段树和懒惰标记的理解深入了许多。 看了这题讨论区的题解，很多人说什么先乘后加，我也是想了挺久才弄懂。 于是考虑这样一个区间 $0$，和它的两个子区间 $1$ 和 $2$，如图： 接着，我们记区间 $i$ 的区间的元素个数为 $span_i$&hairsp;、区间和为 $sum_i$&hairsp;、修改前的初始区间和为 $sum^\\prime_i$&hairsp;、区间延迟加法的懒标记为 $lazyadd_i$&hairsp;、区间延迟乘法的懒标记为 $lazymul_i$&hairsp;。于是有以下初始情况，初始情况下，$lazyadd_i=0,lazymul_i=1$： $$sum^\\prime_0=sum^\\prime_0\\times\\overbrace{1}^{lazymul_0} +\\overbrace{0}^{lazyadd_0}\\times span_0$$ 考虑将 $0$ 区间，先整体加上 $3$，再整体乘以 $4$，于是有： $$\\begin{aligned}sum_0=&amp;\\,(sum^\\prime_0\\times\\overbrace{1}^{lazymul_0} +\\overbrace{0}^{lazyadd_0}\\times span_0+3\\times span_0)\\times4\\\\=&amp;\\,(sum^\\prime_0\\times\\overbrace{1}^{lazymul_0} +\\overbrace{3}^{lazyadd_0}\\times span_0)\\times4\\\\=&amp;\\,sum^\\prime_0\\times\\overbrace{4}^{lazymul_0}+\\overbrace{12}^{lazyadd_0}\\times span_0\\end{aligned}$$ 上式中转换的两步，分别对应了递归更新区间 “懒惰加法” 和 “懒惰乘法” 的代码（rs[p] - ls[p] 即 $span_p$）： 1234567// 加法sum[p] += val * (rs[p] - ls[p]);lazyadd[p] += val;// 乘法sum[p] *= val;lazyadd[p] *= val;lazymul[p] *= val; 接下来考虑父区间将信息传递给子区间的 pushdown 操作。以子区间 $1$ 为例，将父区间加上 $3$ 和乘以 $4$ 的信息传入。假设该区间本身就有懒惰标记，其初始值分别为 $lazyadd^\\prime_1$ 和 $lazymul^\\prime_1$，于是有： $$\\begin{aligned}sum_1&amp;=\\,(sum^\\prime_1\\times\\overbrace{lazymul^\\prime_1}^{lazymul_1}+\\overbrace{lazyadd^\\prime_1}^{lazyadd_1}\\times span_1+3\\times span_1)\\times4\\\\&amp;=\\,[sum^\\prime_1\\times\\overbrace{lazymul^\\prime_1}^{lazymul_1} +\\overbrace{(lazyadd^\\prime_1+3)}^{lazyadd_1}\\times span_1]\\times4\\\\&amp;=\\, sum^\\prime_1\\times\\overbrace{lazymul^\\prime_1\\times4}^{lazymul_1}+\\overbrace{(lazyadd^\\prime_1\\times4+12)}^{lazyadd_1}\\times span_1\\\\&amp;=\\, sum^\\prime_1\\times\\overbrace{lazymul^\\prime_1\\times lazymul_0}^{lazymul_1} +\\overbrace{(lazyadd^\\prime_1\\times lazymul_0+lazyadd_0)}^{lazyadd_1}\\times span_1\\end{aligned}$$ 上式最后一步的转换比较关键，这样就和父区间建立起了联系。这对应了父区间向下传递的代码： 123456789101112131415#define chl (p * 2 + 1)#define chr (p * 2 + 2)void pushdown(int p) { // 更新子区间的区间和与懒惰标记 sum[chl] = sum[chl] * lazymul[p] + lazyadd[p] * (rs[chl] - ls[chl]); sum[chr] = sum[chr] * lazymul[p] + lazyadd[p] * (rs[chr] - ls[chr]); lazyadd[chl] = lazyadd[chl] * lazymul[p] + lazyadd[p]; lazyadd[chr] = lazyadd[chr] * lazymul[p] + lazyadd[p]; lazymul[chl] *= lazymul[p]; lazymul[chr] *= lazymul[p]; // 最后别忘了清零父区间的懒惰标记 lazyadd[p] = 0; lazymul[p] = 1;} 有了这些思路，代码自然就有了。 参考代码P3373.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;bits/stdc++.h&gt;#define chl (p * 2 + 1)#define chr (p * 2 + 2)using namespace std;using ll = long long;constexpr int maxn = 1e5;constexpr int maxt = 1 &lt;&lt; 18;ll a[maxn], mod;int n, m;struct segtree { ll ls[maxt], rs[maxt]; ll sum[maxt], lazyadd[maxt], lazymul[maxt]; void build(int l, int r, int p = 0) { ls[p] = l, rs[p] = r, lazyadd[p] = 0, lazymul[p] = 1; if (r - l == 1) { sum[p] = a[l] % mod; return; } int mid = (l + r) &gt;&gt; 1; build(l, mid, chl); build(mid, r, chr); sum[p] = (sum[chl] + sum[chr]) % mod; } void pushdown(int p) { sum[chl] = (sum[chl] * lazymul[p] + lazyadd[p] * (rs[chl] - ls[chl])) % mod; sum[chr] = (sum[chr] * lazymul[p] + lazyadd[p] * (rs[chr] - ls[chr])) % mod; lazyadd[chl] = (lazyadd[chl] * lazymul[p] + lazyadd[p]) % mod; lazyadd[chr] = (lazyadd[chr] * lazymul[p] + lazyadd[p]) % mod; lazymul[chl] = (lazymul[chl] * lazymul[p]) % mod; lazymul[chr] = (lazymul[chr] * lazymul[p]) % mod; lazyadd[p] = 0, lazymul[p] = 1; } void add(int x, int y, ll val, int p = 0) { if (x &lt;= ls[p] &amp;&amp; rs[p] &lt;= y) { sum[p] = (sum[p] + val * (rs[p] - ls[p])) % mod; lazyadd[p] = (lazyadd[p] + val) % mod; return; } pushdown(p); int mid = (ls[p] + rs[p]) &gt;&gt; 1; if (x &lt; mid) add(x, y, val, chl); if (y &gt; mid) add(x, y, val, chr); sum[p] = (sum[chl] + sum[chr]) % mod; } void mul(int x, int y, ll val, int p = 0) { if (x &lt;= ls[p] &amp;&amp; rs[p] &lt;= y) { sum[p] = (sum[p] * val) % mod; lazyadd[p] = (lazyadd[p] * val) % mod; lazymul[p] = (lazymul[p] * val) % mod; return; } pushdown(p); int mid = (ls[p] + rs[p]) &gt;&gt; 1; if (x &lt; mid) mul(x, y, val, chl); if (y &gt; mid) mul(x, y, val, chr); sum[p] = (sum[chl] + sum[chr]) % mod; } ll query(int x, int y, int p = 0) { if (ls[p] == x &amp;&amp; rs[p] == y) return sum[p]; pushdown(p); int mid = (ls[p] + rs[p]) &gt;&gt; 1; if (y &lt;= mid) return query(x, y, chl); if (x &gt;= mid) return query(x, y, chr); return (query(x, mid, chl) + query(mid, y, chr)) % mod; }} seg;int main(){ scanf(&quot;%d%d%lld&quot;, &amp;n, &amp;m, &amp;mod); for (int i = 0; i != n; ++i) scanf(&quot;%lld&quot;, &amp;a[i]); seg.build(0, n); int op, x, y; ll k; while (m--) { scanf(&quot;%d%d%d&quot;, &amp;op, &amp;x, &amp;y), --x; if (op == 3) printf(&quot;%lld\\n&quot;, seg.query(x, y)); else { scanf(&quot;%lld&quot;, &amp;k); if (op == 1) seg.mul(x, y, k); else seg.add(x, y, k); } }} 【习题】市场提供一个序列，要求你维护四种操作： 区间整体加上 $x$ 区间的每一个数除以 $x$，并向下取整 查询区间最小值 查询区间和 题解这题让我深刻地体会到了，自己是个大常数选手。同一段代码别人用 $2500{\\rm ms}$，我的要用 $3300{\\rm ms}$&hairsp;。代码常数的差别，不是一两处修改就能赶上来的，有些习惯让大常数的代码无处不在… 说了一些废话。 这四种操作，我认为第二种是最重要的，其它都只是摆设罢了。 除以一个数容易想，维护两个懒惰标记，一个对应加法、一个对应除法就行了。可对于整除来说，这方法完全行不通。于是想到，很接近的数，比如 $9$ 和 $10$，在除以 $5$ 并向下取整后将变为 $1$ 和 $2$&hairsp;。相当于给两个数都减去了 $8$&hairsp;。于是，区间整除就变成了区间减法。 判断整个区间的数是否具备将整除转为区间减法的条件，需要记录下区间的最大值和最小值。一般来说只有最大值等于最小值，也就是区间数字都相同时符合条件。但比如说刚才 $9$ 和 $10$ 的例子，比较大的数能够被除数整除，则最小值可以比最大值小 $1$&hairsp;。 参考代码LOJ6029.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include &lt;bits/stdc++.h&gt;#define chl (p * 2 + 1)#define chr (p * 2 + 2)using namespace std;typedef long long ll;const int maxn = 1e5;const int maxt = 1 &lt;&lt; 18;ll floor(ll a, ll b){ if ((a &lt; 0) ^ (b &lt; 0) &amp;&amp; a % b) return a / b - 1; return a / b;}ll a[maxn];struct segtree { int ls[maxt], rs[maxt]; ll mn[maxt], mx[maxt], sum[maxt], lazy[maxt]; void pushup(int p) { sum[p] = sum[chl] + sum[chr]; mx[p] = max(mx[chl], mx[chr]); mn[p] = min(mn[chl], mn[chr]); } void pushdown(int p) { if (lazy[p]) { sum[chl] += lazy[p] * (rs[chl] - ls[chl]); sum[chr] += lazy[p] * (rs[chr] - ls[chr]); mn[chl] += lazy[p]; mn[chr] += lazy[p]; mx[chl] += lazy[p]; mx[chr] += lazy[p]; lazy[chl] += lazy[p]; lazy[chr] += lazy[p]; lazy[p] = 0; } } void build(int l, int r, int p = 0) { ls[p] = l, rs[p] = r, lazy[p] = 0; if (r - l == 1) { sum[p] = mn[p] = mx[p] = a[l]; return; } int mid = (l + r) &gt;&gt; 1; build(l, mid, chl); build(mid, r, chr); pushup(p); } void intv_add(int x, int y, ll val, int p = 0) { if (x &lt;= ls[p] &amp;&amp; rs[p] &lt;= y) { sum[p] += val * (rs[p] - ls[p]); lazy[p] += val; mn[p] += val; mx[p] += val; return; } pushdown(p); int mid = (ls[p] + rs[p]) &gt;&gt; 1; if (x &lt; mid) intv_add(x, y, val, chl); if (y &gt; mid) intv_add(x, y, val, chr); pushup(p); } void intv_div(int x, int y, ll val, int p = 0) { if (x &lt;= ls[p] &amp;&amp; rs[p] &lt;= y) { if (mn[p] == mx[p] || (mx[p] - mn[p] == 1 &amp;&amp; !(mx[p] % val))) { val = floor(mn[p], val) - mn[p]; sum[p] += val * (rs[p] - ls[p]); lazy[p] += val; mn[p] += val; mx[p] += val; return; } } pushdown(p); int mid = (ls[p] + rs[p]) &gt;&gt; 1; if (x &lt; mid) intv_div(x, y, val, chl); if (y &gt; mid) intv_div(x, y, val, chr); pushup(p); } ll query_min(int x, int y, int p = 0) { if (ls[p] == x &amp;&amp; rs[p] == y) return mn[p]; pushdown(p); int mid = (ls[p] + rs[p]) &gt;&gt; 1; if (y &lt;= mid) return query_min(x, y, chl); if (x &gt;= mid) return query_min(x, y, chr); return min(query_min(x, mid, chl), query_min(mid, y, chr)); } ll query_sum(int x, int y, int p = 0) { if (ls[p] == x &amp;&amp; rs[p] == y) return sum[p]; pushdown(p); int mid = (ls[p] + rs[p]) &gt;&gt; 1; if (y &lt;= mid) return query_sum(x, y, chl); if (x &gt;= mid) return query_sum(x, y, chr); return query_sum(x, mid, chl) + query_sum(mid, y, chr); }} seg;int main(){ int n, q; scanf(&quot;%d%d&quot;, &amp;n, &amp;q); for (int i = 0; i != n; ++i) scanf(&quot;%lld&quot;, &amp;a[i]); seg.build(0, n); int op, x, y; ll k; while (q--) { scanf(&quot;%d%d%d&quot;, &amp;op, &amp;x, &amp;y), ++y; if (op == 1) { scanf(&quot;%lld&quot;, &amp;k); seg.intv_add(x, y, k); } else if (op == 2) { scanf(&quot;%lld&quot;, &amp;k); seg.intv_div(x, y, k); } else if (op == 3) { printf(&quot;%lld\\n&quot;, seg.query_min(x, y)); } else { printf(&quot;%lld\\n&quot;, seg.query_sum(x, y)); } }}","link":"/posts/segment-tree-lazytag/"},{"title":"线段树之基本概念","text":"本文介绍了线段树的基础知识，辅之以相关例题。 基本概念部分，因为是初学，理解没有那么深入，自己总结出来可能质量不高，所以本文的前半部分基本照搬了 $\\text{SilentEAG}$ 大佬的 这篇文章（有修改），自己着重写了习题部分。 什么是线段树？首先，你得有树的基本知识。 然后。 线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树的一个结点。 百度百科线段树 很懵？没关系，我们继续。 其实，线段树(Segment Tree)是一种基于分治思想的二叉树结构，如果你学过树状数组，你会清楚地知道两者的差异性，并且随着学习的深入，你会发现线段树是一种更为通用的数据结构。 可以说，只要是能满足区间可加性（也就是大区间的信息能由它的两个子区间整理得到）的操作，大都可以用线段树解决。 最基本的线段树包含以下几个概念： 线段树每个节点表示一个区间； 线段树的唯一根节点表示整个区间统计范围，如 $[1,N]$&hairsp;； 线段树的每个叶节点表示一个长度为 $1$ 的元区间，如 $[x,x]$&hairsp;； 线段树上的每个节点 $[l,r]$，它的左子节点是 $[l,mid]$，右子节点是 $[mid+1,r]$，其中 $mid=(l+r)/2$ (这是线段树最常见的写法，也会有适用于不同问题的其它写法，不过这用于理解线段树的要义足矣）。 如图，这就是一棵线段树。我们可以发现，当整个区间统计长度为 $2$ 的整数次幂时，整棵线段树一定是一棵完全二叉树，那我们就可以用堆的编号方法来给线段树来编号啊（其实图中已经编好了）。 如果根节点编号为 $1$&hairsp;。编号为 $x$ 的节点，它的左儿子编号为 $2x$，右儿子编号为 $2x+1$&hairsp;。 这样，我们就可以用一个数组来存所有节点的编号了！ 诶等等，那万一整个区间长度不是 $2$ 的整数次幂呢？ 可以惊讶地发现，我们同样可以使用 “父子二倍标记法”。正确性显然，只不过，正是因为这种情况，所以树的最后一层节点编号在数组中的位置可能不是连续的。 如果区间长度为 $N$，在最理想的状况下，即 $N$ 是 $2$ 的整数次幂时，$N$ 个叶节点的满二叉树有 $N+N/2+N/4+\\ldots+1=2N−1$ 个节点。只要不是这种情况，那就还有一层，所以我们保存线段树节点编号的数组的长度 $T$ 要足够。实际应用时将 $N$ 补至 $2$ 的整数次幂，再乘以 $2$ 即可，实际使用时就是这样： $$\\begin{aligned}N=10^4\\to T=2^{15}\\\\N=10^5\\to T=2^{18}\\\\N=10^6\\to T=2^{21}\\end{aligned}$$ 当然，不想麻烦的话，可以直接 $T=4N$，也没有问题。 于是线段树信息储存如下： 1234struct node { int l, r; // 每个区间左右端点 int sum; // 其它区间数据，这里是区间和的例子} seg[maxn * 4]; 当然，线段树的写法多种多样，这是最稳的一种，还有一种是记录左右儿子编号的，据说叫做zkw线段树，我以后遇到了可能会补充。 建树我们需要从根节点 “$1$” 出发，向下递归建树，并把每个节点所代表的区间赋给它。当到达了根节点，便传值，再向上维护信息。 以维护区间和为例，我们可以这样建树： 12345678910111213void build(int l, int r, int p = 1){ node&amp; par = seg[p]; par.l = l, par.r = r; if (l == r) { // 叶节点赋值 par.val = par.prel = par.prer = par.sum = a[l]; return; } int mid = (l + r) / 2; build(l, mid, p * 2); // 递归建左子树 build(mid + 1, r, p * 2 + 1); // 递归建右子树 par.sum = seg[p * 2].sum + seg[p * 2 + 1].sum; // 向上传递区间和的信息} 单点修改显然，每次操作，我们都需要从根节点开始遍历，递归找到需要修改的叶子节点，然后修改，然后向上传递信息。 1234567891011121314void modify(int x, int val, int p = 1){ node&amp; par = seg[p]; if (par.l == par.r) { // 找到了要修改的位置 par.val = par.prel = par.prer = par.sum = val; return; } int mid = (par.l + par.r) / 2; if (x &lt;= mid) modify(x, val, p * 2); else modify(x, val, p * 2 + 1); par.sum = seg[p * 2].sum + seg[p * 2 + 1].sum; // 向上传递区间和的信息} 因为整棵树的深度是 $\\lceil\\log N\\rceil$，所以单次修改的时间复杂度为 $O(\\log N)$&hairsp;。 区间查询这里直接给出算法过程，正确性显然。 若当前节点所表示的区间已经被询问区间所完全覆盖，则立即回溯，并传回该点的信息； 若当前节点的左儿子所表示的区间已经被询问区间所完全覆盖，就递归访问它的左儿子； 若当前节点的右儿子所表示的区间已经被询问区间所完全覆盖，就递归访问它的右儿子。 以返回区间和为例： 12345678910111213int query(int x, int y, int p = 1){ node&amp; par = seg[p]; if (x &lt;= par.l &amp;&amp; par.r &lt;= y) return par.sum; // 对应操作1 int sum = 0; int mid = (par.l + par.r) / 2; if (mid &gt;= y) sum += query(x, y, p * 2); // 对应操作2 if (mid &lt; x) sum += query(x, y, p * 2 + 1); // 对应操作3 return sum;} 为什么使用线段树？先来对比一下普通数组和线段树，看看它们各种操作的时间复杂度。 ​ 初始化 区间查询 单节点修改 普通数组 $O(n)$ $O(n)$ $O(1)$ 线段树 $O(n)$ $O(\\log n)$ $O(\\log n)$ 可见，线段树主要是在区间查询上有速度优势，能够应对更多、范围更大的查询。但是相应地，单节点修改需要耗费很多时间。 然而，线段树很懒，懒得一个个地处理节点修改的请求。为了应对需要修改多个节点的情况，线段树有它自己的策略——“懒惰标记”，接下来会学到。 不过在这之前，先做几道练习题。 【习题】Can you answer these queries III需要你提供一种数据结构使之能够查询区间最大连续子段和，并且支持单点修改。 题解首先考虑区间的最大子段的这些情况： 连续最大和的区间只在左儿子所对应的区间上； 连续最大和的区间只在右儿子所对应的区间上； 连续最大和的区间横跨左右儿子的区间。 第 $1$ 和第 $2$ 种情况，答案就是左边部分（右边部分）的最大子段和。第 $3$ 种情况复杂一点，答案等于 左边部分从其右端开始的最大子段和 加上 右边部分从其左端开始的最大子段和。 当然，为了维护区间从其端点开始的最大子段和，还需维护区间和&hairsp;$(sum)$&hairsp;。如此，一个区间从其左端开始的最大子段和，假设左右儿子的位置分别为 $chl$ 和 $chr$，便可以如此维护： $$prel_p =\\max\\{prel_{chl} , sum_{chl} + prel_{chr}\\}$$ 从右端开始的最大子段和同理。 总的来说，我们要维护这几种区间信息： 区间的最大连续子段和&hairsp;$(val)$ 区间和&hairsp;$(sum)$ 区间从其左端开始的最大子段和&hairsp;$(prel)$ 区间从其左端开始的最大子段和&hairsp;$(prer)$ 接下来是查询部分，一开始当然是在根节点查询所给的区间。在每个节点处的查询又可以分为三种情况处理： 所查询的区间刚好是该节点的区间，则直接返回该区间； 所查询的区间全部在该节点区间的左半部分，则返回该节点左儿子查询该区间的结果； 所查询的区间全部在该节点区间的右半部分，则返回该节点右儿子查询该区间的结果； 所查询的区间横跨该节点区间的中间，则将所查询的区间根据该节点区间的中点分为左右两部分，分别让该节点的左儿子和右儿子查询这两个区间，并将查询结果 “合并” 后返回。 所谓 “合并” 的操作其实就是建树时，子节点向上传播信息的操作，我们可以复用这段代码，也就是下方参考代码中的 pushup 函数。 参考代码can-you-answer-these-queries.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;constexpr int maxn = 50007;struct node { int l, r; ll prel, prer, val, sum;} seg[maxn * 4];ll a[maxn];void pushup(node&amp; par, const node&amp; lson, const node&amp; rson){ par.prel = max(lson.prel, lson.sum + rson.prel); par.prer = max(rson.prer, rson.sum + lson.prer); par.val = max(max(lson.val, rson.val), lson.prer + rson.prel); par.sum = lson.sum + rson.sum;}void build(int l, int r, int p = 1){ node&amp; par = seg[p]; par.l = l, par.r = r; if (l == r) { par.val = par.prel = par.prer = par.sum = a[l]; return; } int mid = (l + r) / 2; build(l, mid, p * 2); build(mid + 1, r, p * 2 + 1); pushup(par, seg[p * 2], seg[p * 2 + 1]);}void modify(int x, int val, int p = 1){ node&amp; par = seg[p]; if (par.l == par.r) { par.val = par.prel = par.prer = par.sum = val; return; } int mid = (par.l + par.r) / 2; if (x &lt;= mid) modify(x, val, p * 2); else modify(x, val, p * 2 + 1); pushup(par, seg[p * 2], seg[p * 2 + 1]);}node query(int x, int y, int p = 1){ node&amp; par = seg[p]; if (x == par.l &amp;&amp; y == par.r) return par; int mid = (par.l + par.r) / 2; if (mid &gt;= y) return query(x, y, p * 2); if (mid &lt; x) return query(x, y, p * 2 + 1); node res; pushup(res, query(x, mid, p * 2), query(mid + 1, y, p * 2 + 1)); return res;}int main(){ int n, q, op, x, y; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%lld&quot;, &amp;a[i]); build(1, n); for (scanf(&quot;%d&quot;, &amp;q); q--;) { scanf(&quot;%d%d%d&quot;, &amp;op, &amp;x, &amp;y); if (op) printf(&quot;%lld\\n&quot;, query(x, y).val); else modify(x, y); }} 【习题】Crane有一台起重机。起重机可以看成由 $N$ 条线段首尾相接而成。第 $i$ 条线段的长度是 $L_i$&hairsp;。最开始，所有的线段都笔直连接，指向上方。 有 $C$ 条操纵起重机的指令。指令 $i$ 给出两个整数 $S_i$ 和 $A_i$，效果是使线段 $S_i$ 和 $S_{i+1}$ 之间的角度变成 $A_i$ 度。其中角度指的是从线段 $S_i$ 开始沿逆时针方向旋转到 $S_{i+1}$ 所经过的角度。最开始所有的角度都是 $180$ 度。 按顺序执行这 $C$ 条指令，在每条执行后，输出起重机末端（第 $N$ 条线段的端点）的坐标。假设起重机支点的坐标是 $(0,0)$&hairsp;。 题解这是在白书上看到的题目，思维难度比较高。花了两天时间才搞懂，我还是太菜了。思路是运用分治的思想，将整个起重机逐次二分为小区间，用线段树解决。每个节点代表一段连续的线段的集合，并维护这两个值： 将节点左子节点的向量所指的方向作为竖直向上的正方向后，从该节点左子节点的向量起点指向该节点右子节点的向量终点的向量； 将节点的左右子节点的向量拼接后，右子节点的向量需要旋转的角度。 第一个值容易维护，如果节点 $p$ 表示的向量是 $(x_p,y_p)$，角度是 $ang_p$，两个儿子节点分别是 $chl$ 和 $chr$，则有： $$\\begin{aligned}x_p=x_{chl}+(\\cos(ang_p)\\times x_{chr}-\\sin(ang_p)\\times y_{chr})\\\\y_p=y_{chl}+(\\sin(ang_p)\\times x_{chr}+\\cos(ang_p)\\times y_{chr})\\end{aligned}$$ 比较难维护的是第二个值，旋转角度。我随手画了个图方便理解。 这张图是 $N=8$ 时的两种情况，左图是将第 $5$ 节变为 $90$ 度，右图是将 $2$ 节变为 $90$ 度。每个带方向的箭头都是某个节点所对应的向量。其中标记黑点的代表需要更新角度值，标记圆圈的代表需要更新向量值。 可以发现： 区间长度为 $1$ 的节点不需要更新角度值和向量值； 若某个节点所对应的区间包含要改变角度的位置 $(l_p &lt; pos &lt; r_p)$，则需要更新其向量值； 若某个节点需要更新向量值，且其右子节点没有更新角度值，则需要更新其角度值。 这样，每次更新便可以在 $O(\\log n)$ 时间内完成，而根节点所对应向量的值就是要输出的结果。 参考代码crane.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;cmath&gt;#include &lt;cstdio&gt;#define chl (p * 2 + 1)#define chr (p * 2 + 2)const int maxn = 10007;const double pi = acos(-1.0);struct node { int l, r; double x, y, ang;} seg[maxn * 4];double prv[maxn], len[maxn];void build(int l, int r, int p = 0){ node&amp; par = seg[p]; par.l = l, par.r = r, par.x = par.ang = 0.0; if (r - l == 1) { par.y = len[l]; return; } int mid = (l + r) / 2; build(l, mid, chl); build(mid, r, chr); // 默认方向是朝上，只需更新纵坐标 par.y = seg[chl].y + seg[chr].y;}void modify(int pos, double delta, int p = 0){ node&amp; par = seg[p]; if (pos &lt;= par.l || pos &gt;= par.r) return; // 若要旋转的位置是该节点区间的端点，甚至不在节点区间内，则没有任何影响 modify(pos, delta, chl); modify(pos, delta, chr); if (pos &lt;= (par.l + par.r) / 2) par.ang += delta; // 若右子节点没有被更新，需要将其向量旋转 double s = sin(par.ang), c = cos(par.ang); // 将左右子节点的向量拼接，更新本节点 par.x = seg[chl].x + (c * seg[chr].x - s * seg[chr].y); par.y = seg[chl].y + (s * seg[chr].x + c * seg[chr].y);}int main(){ int m, n, cnt = 0; while (scanf(&quot;%d%d&quot;, &amp;m, &amp;n) != EOF) { if (cnt++) puts(&quot;&quot;); for (int i = 1; i != m; ++i) prv[i] = pi; // 初始方向为上方 for (int i = 0; i != m; ++i) scanf(&quot;%lf&quot;, &amp;len[i]); build(0, m); for (int pos, deg; n--;) { scanf(&quot;%d%d&quot;, &amp;pos, &amp;deg); // 利用prv数组，算出角度的变化值，单位是弧度 double rad = (double)deg / 180.0 * pi; modify(pos, rad - prv[pos]); prv[pos] = rad; printf(&quot;%.2f %.2f\\n&quot;, seg[0].x, seg[0].y); } }}","link":"/posts/segment-tree/"},{"title":"“滑动窗口” 的优先队列解法","text":"题目链接：POJ2823 - Sliding Window 按顺序输出一个序列中每个固定大小的区间里的最值。这题可以用线段树解决，但不如用单调队列效率高。 题目描述给你一个长度为 $n\\leq10^6$ 的序列。有一个大小为 $k$ 的窗口正从序列的最左边滑向最右边，你只能看到窗口中的 $k$ 个数。每过单位时间，窗口就向右平移一个单位。这里举一个序列为 [1 3 -1 -3 5 3 6 7]，$k=3$ 的例子。 窗口位置 最小值 最大值 [$1$&nbsp;&nbsp;$3$&nbsp;&nbsp;$-1$]&nbsp;$-3$&nbsp;&nbsp;$5$&nbsp;&nbsp;$3$&nbsp;&nbsp;$6$&nbsp;&nbsp;$7$&nbsp; $-1$ $3$ &nbsp;$1$&nbsp;[$3$&nbsp;&nbsp;$-1$&nbsp;&nbsp;$-3$]&nbsp;$5$&nbsp;&nbsp;$3$&nbsp;&nbsp;$6$&nbsp;&nbsp;$7$&nbsp; $-3$ $3$ &nbsp;$1$&nbsp;&nbsp;$3$&nbsp;[$-1$&nbsp;&nbsp;$-3$&nbsp;&nbsp;$5$]&nbsp;$3$&nbsp;&nbsp;$6$&nbsp;&nbsp;$7$&nbsp; $-3$ $5$ &nbsp;$1$&nbsp;&nbsp;$3$&nbsp;&nbsp;$-1$&nbsp;[$-3$&nbsp;&nbsp;$5$&nbsp;&nbsp;$3$]&nbsp;$6$&nbsp;&nbsp;$7$&nbsp; $-3$ $5$ &nbsp;$1$&nbsp;&nbsp;$3$&nbsp;&nbsp;$-1$&nbsp;&nbsp;$-3$&nbsp;[$5$&nbsp;&nbsp;$3$&nbsp;&nbsp;$6$]&nbsp;$7$&nbsp; $3$ $6$ &nbsp;$1$&nbsp;&nbsp;$3$&nbsp;&nbsp;$-1$&nbsp;&nbsp;$-3$&nbsp;&nbsp;$5$&nbsp;[$3$&nbsp;&nbsp;$6$&nbsp;&nbsp;$7$] $3$ $7$ 你需要找出每一个位置时，窗口中的最大数和最小数，并按顺序输出。 题解这道题，图省事的话，套个线段树的板子就好（没看出来哪里省事了）。建两棵线段树，一棵用于查询区间最小值，另一棵用于查询区间最大值。 分析一下线段树的效率，建树时间为 $O(n)$，单次查询时间为 $O(\\log n)$&hairsp;；又一共有 $2(n-k+1)$ 次查询，所以总体时间复杂度大约为 $O(n\\log n)$&hairsp;。这对于所给数据来说很可能会超时，所以考虑使用单调队列来解决。 单调队列具有队列内所有元素单调递增或者单调递减的性质，所以队列中的最小（最大）值一定出现在队首。 为了维护单调队列，在插入元素 $a_i$ 时需要进行以下操作（以队首为最大值举例）： 判断队首元素是否超出窗口范围，若是，将其弹出队列； 将队尾所有小于 $a_i$ 的元素全部弹出队列； 将 $a_i$ 从队尾入队。 解决这道题，先将前 $k$ 个元素按规则入队，之后每插入一个元素前都输出队首，便得到了题目要求的结果。 需要注意，为了判断队首元素是否在窗口范围内，需要保存元素在序列中的位置（代码中的 $pos$ 数组）。 最后，记得这个，创建并维护一个单调队列并不一定真的得用标准库的 deque&lt;int&gt;，并且用其 push_back 等方法进行操作（大常数选手飘过）。我试过，大概有一个 $2$ 的常数在它前面，在解决这题时效率甚至不及线段树解法。 完全可以用一个数组模拟双向队列，用 $l$ 和 $r$ 记录队列在数组中的范围。这样，例如弹出队尾元素的操作，仅仅用 --r 就可以完成了。只要确保数组开得足够大，并且操作过程中 $l$ 不会小于 $0$ 即可。 参考代码 (Monotonic Queue)MQ.cpp123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#define maxn 1000007int val[maxn], pos[maxn], a[maxn];int n, k;inline bool greater(int a, int b) { return a &gt; b; }inline bool less(int a, int b) { return a &lt; b; }void solve(bool (*func)(int, int)){ int l = 0, r = 0; for (int i = 0; i != k; ++i) { while (l != r &amp;&amp; func(a[i], val[r - 1])) --r; val[r] = a[i], pos[r++] = i; } for (int i = k; i != n; ++i) { printf(&quot;%d &quot;, val[l]); if (l != r &amp;&amp; pos[l] + k &lt;= i) ++l; while (l != r &amp;&amp; func(a[i], val[r - 1])) --r; val[r] = a[i], pos[r++] = i; } printf(&quot;%d\\n&quot;, val[l]);}int main(){ scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for (int i = 0; i != n; ++i) scanf(&quot;%d&quot;, &amp;a[i]); solve(less); solve(greater);} 参考代码 (Segment Tree)线段树版本的代码过于丑陋了，所以把它放在了后面。 ST.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;algorithm&gt;#include &lt;cstdio&gt;#define maxn 1000007#define chl (p * 2 + 1)#define chr (p * 2 + 2)int a[maxn];int m_max[maxn * 4], m_min[maxn * 4];void build(int l, int r, int p = 0){ if (r - l == 1) { m_max[p] = m_min[p] = a[l]; return; } int mid = (l + r) / 2; build(l, mid, chl); build(mid, r, chr); m_max[p] = std::max(m_max[chl], m_max[chr]); m_min[p] = std::min(m_min[chl], m_min[chr]);}int query_min(int x, int y, int l, int r, int p = 0){ if (l == x &amp;&amp; r == y) return m_min[p]; int mid = (l + r) / 2; if (y &lt;= mid) return query_min(x, y, l, mid, chl); if (x &gt;= mid) return query_min(x, y, mid, r, chr); return std::min(query_min(x, mid, l, mid, chl), query_min(mid, y, mid, r, chr));}int query_max(int x, int y, int l, int r, int p = 0){ if (l == x &amp;&amp; r == y) return m_max[p]; int mid = (l + r) / 2; if (y &lt;= mid) return query_max(x, y, l, mid, chl); if (x &gt;= mid) return query_max(x, y, mid, r, chr); return std::max(query_max(x, mid, l, mid, chl), query_max(mid, y, mid, r, chr));}int main(){ int n, k; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for (int i = 0; i != n; ++i) scanf(&quot;%d&quot;, &amp;a[i]); build(0, n); for (int i = 0; i + k &lt;= n; ++i) printf(&quot;%d &quot;, query_min(i, i + k, 0, n)); puts(&quot;&quot;); for (int i = 0; i + k &lt;= n; ++i) printf(&quot;%d &quot;, query_max(i, i + k, 0, n)); puts(&quot;&quot;);}","link":"/posts/sliding-window/"},{"title":"稀疏表及其应用","text":"本文介绍了稀疏表的基本用法，以及如何在相关习题中应用它。 本文的简介部分主要参照了 $\\text{OI WiKi}$ 的这篇文章。$\\text{OI WiKi}$ 整合了各类有关编程竞赛的实用知识，感谢贡献者们！ 为什么使用稀疏表？稀疏表是用于解决 “可重复贡献问题” 的数据结构，什么是 “可重复贡献问题”？ 若一个运算 ${\\rm op}$ 满足 $x\\,{\\rm op}\\,x=x$，则其对应的区间查询就是 “可重复贡献问题”。例如，最大值有 $\\max(x,x)=x$，所以 RMQ 是这类问题；最大公约数有 $\\gcd(x,x)=x$，区间最大公约数也是这类问题。区间和就不具备这个性质，如果求区间和所采用的区间有重叠，重叠部分就会被计算两次，这是我们不希望看到的。 另外，除了 RMQ、区间最大公约数以外，区间按位与、区间按位或等问题，都能够用稀疏表高效解决。这些问题都有着某种相似之处，例如区间按位与，就是每一位都取最小值；区间按位或，就是每一位都取最大值。 类似的解决这类问题的工具还有线段树。虽然稀疏表不支持修改操作，但是其查询时间被降至常数，在处理有大量询问的问题时十分有效。 ​ 初始化 区间查询 单节点修改 线段树 $O(n)$ $O(\\log n)$ $O(\\log n)$ 稀疏表 $O(n\\log n)$ $O(1)$ 不可 如何使用稀疏表？稀疏表使用 $O(n\\log n)$ 的时间，预处理出一张二维的表格 $f(i,j)$&hairsp;。接下来以区间最大值为例，$f(i,j)$ 的含义为 “区间 $[i,i+2^j)$ 上的最大值”。 假设原数列为 $a$，显然有 $f(i,0)=a_i$&hairsp;。之后使用状态转移方程 $f(i,j)=\\max\\{f(i,j-1),f(i+2^{j-1},j-1)\\}$ 填充完整张表格即可完成预处理。 若要查询区间 $[l,r)$ 上的最大值，返回 $\\max\\{f(l,s),f(r-2^s,s)\\}$ 即可，其中 $s=\\lfloor\\log_2(r-l)\\rfloor$&hairsp;。 【习题】Balanced Lineup给出一个序列，每次询问要求回答出某个区间中最大值和最小值之差。 题解模板题，需要维护两张稀疏表，一张用于查询区间最大值，另一张用于查询区间最小值。查询后相减得到答案。 参考代码P2880.cpp123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 50001;const int lg2maxn = 16;int f[maxn][lg2maxn][2], lg2[maxn];int main(){ int n, q, l, r; scanf(&quot;%d%d&quot;, &amp;n, &amp;q); for (int i = 2; i &lt;= n; ++i) lg2[i] = lg2[i &gt;&gt; 1] + 1; for (int i = 0; i != n; ++i) scanf(&quot;%d&quot;, &amp;f[i][0][0]), f[i][0][1] = f[i][0][0]; for (int j = 1; j &lt;= lg2[n]; ++j) for (int i = n - (1 &lt;&lt; j); i != -1; --i) f[i][j][0] = min(f[i][j - 1][0], f[i + (1 &lt;&lt; (j - 1))][j - 1][0]); for (int j = 1; j &lt;= lg2[n]; ++j) for (int i = n - (1 &lt;&lt; j); i != -1; --i) f[i][j][1] = max(f[i][j - 1][1], f[i + (1 &lt;&lt; (j - 1))][j - 1][1]); while (q--) { scanf(&quot;%d%d&quot;, &amp;l, &amp;r), --l; int s = lg2[r - l]; printf(&quot;%d\\n&quot;, max(f[l][s][1], f[r - (1 &lt;&lt; s)][s][1]) - min(f[l][s][0], f[r - (1 &lt;&lt; s)][s][0])); }} 【习题】降雨量“$X$ 年是自 $Y$ 年以来降雨量最多的”，它的含义是 $X$ 年的降雨量不超过 $Y$ 年，且对于任意 $Y\\lt Z\\lt X$，$Z$ 年的降雨量严格小于 $X$ 年。给出两个年份，判断 “$X$ 年是自 $Y$ 年以来降雨量最多的” 这句话是否正确。由于有些年份的降雨量未知，有的说法是可能正确也可以不正确的。 题解这题中稀疏表的地位很明确——只是个小工具，用于查询 $X$ 和 $Y$ 年之间的最大降雨量。这题的重头戏在于有些年份的降雨量是未知的，所以回答可能是 “无法判断”。 代码中的关键点、我曾经忘记考虑的点，都补上了注释，便于查看。 参考代码LOJ2279.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 50001;const int lg2maxn = 16;int n, q;int key[maxn], val[maxn], f[maxn][lg2maxn], lg2[maxn];int intvmax(int x, int y){ if (x &gt;= y) return -1; int s = lg2[y - x]; return max(f[x][s], f[y - (1 &lt;&lt; s)][s]);}int judge(int x, int y){ int ix = lower_bound(key, key + n, x) - key, iy = lower_bound(key, key + n, y) - key; if (key[ix] == x) { // x年的降雨量有记录 int q = intvmax(ix + 1, iy); if (key[iy] == y) { // y年的降雨量有记录 if (val[iy] &gt; val[ix]) return -1; // y年的降雨量多于x年，则至少得 “自(x-1)年以来……” 才正确 if (val[iy] &gt; q) { if (iy - ix == y - x) // 之间所有年份的降雨量都已知 return 1; return 0; } return -1; } if (val[ix] &gt; q) // x年的降雨量至少要比中间多才可能正确 return 0; return -1; } if (key[iy] == y) { if (iy &lt;= ix) // 之间所有年份的降雨量都未知 return 0; int q = intvmax(ix, iy); if (val[iy] &gt; q) return 0; return -1; } return 0;}int main(){ scanf(&quot;%d&quot;, &amp;n); for (int i = 2; i &lt;= n; ++i) lg2[i] = lg2[i &gt;&gt; 1] + 1; for (int i = 0; i != n; ++i) scanf(&quot;%d%d&quot;, &amp;key[i], &amp;val[i]), f[i][0] = val[i]; for (int j = 1; j &lt;= lg2[n]; ++j) for (int i = n - (1 &lt;&lt; j); i != -1; --i) f[i][j] = max(f[i][j - 1], f[i + (1 &lt;&lt; (j - 1))][j - 1]); scanf(&quot;%d&quot;, &amp;q); int x, y; while (q--) { scanf(&quot;%d%d&quot;, &amp;x, &amp;y); int flag = judge(x, y); if (flag == 1) puts(&quot;true&quot;); else if (flag == 0) puts(&quot;maybe&quot;); else puts(&quot;false&quot;); }}","link":"/posts/sparse-table/"},{"title":"“十字翻转棋问题” 的解法","text":"十字翻转棋问题有更巧妙的解法吗？线性代数带给我们不少启发。 题目描述“传火” 这个游戏，需要点燃 $16$ 个火堆。每个火堆可以处于以下两种状态之一：点燃或熄灭。这 $16$ 个火堆可以表示为一个 $4\\times4$ 的方阵，可以对任何一个位置上的火堆进行 “切换”。例如，对 $[i,j]$ 位置的火堆进行切换，会使得第 $i$ 行和第 $j$ 列上的所有火堆的状态也随着改变。要求最终所有的火堆都被点亮。 输入格式输入一共包含 $4$ 行，每行包含 $4$ 个火堆的初始状态。符号 “+” 表示火堆处于熄灭状态，而符号 “-” 表示火堆处于燃烧状态。输入数据保证至少一个火堆的初始状态是熄灭的。 输出格式第一行输出一个整数 $N$，表示所需的最少切换次数。接下来 $N$ 行描述切换顺序，每行输入两个整数，代表被切换状态的火堆的行号和列号，数字之间用空格隔开。切换动作按照整体从上到下、同行从左到右的顺序输出。 样例输入样例 1234+++-+--++--+-+++ 输出样例 12321 14 4 思路与题解最直接的思路当然是递归枚举所有可能的切换方式了。先枚举只切换一次的 $16$ 种情况，再枚举切换两次的 $15\\times15$ 种情况，以此类推。 由此看来，这样做效率十分低下。假设最少切换次数是 $12$，运算量也可以达到 $10^9$ 数量级，根本无法应对需要更多切换次数的情况。 所以我们引入如下方法，首先给这 $16$ 个火堆编号： $$\\begin{array}{|c|c|c|c|}\\hline1&amp;2&amp;3&amp;4\\\\\\hline5&amp;6&amp;7&amp;8\\\\\\hline9&amp;10&amp;11&amp;12\\\\\\hline13&amp;14&amp;15&amp;16\\\\\\hline\\end{array}$$ 用 $b_i$ 表示第 $i$ 个火堆的状态，$b_i$ 取值 $1$ 为熄灭状态，取值 $0$ 为燃烧状态。样例中，$b$ 就可以如此表示为如下的 “状态向量”： $$b=(1,1,1,0,1,0,0,1,1,0,0,1,0,1,1,1)^{\\rm T}$$ 接下来定义向量 $x$，用 $x_i$ 表示是否需要对第 $i$ 个火堆进行切换，是为 $1$，不是为 $0$&hairsp;。我们发现，火堆状态的切换可以用异或运算来表示；又由于火堆最终都将处于熄灭状态，我们可以对第一个火堆列出方程，并化简： $$b_1\\oplus x_1\\oplus x_2\\oplus x_3\\oplus x_4\\oplus x_5\\oplus x_9\\oplus x_{13} = 0$$ $$x_1\\oplus x_2\\oplus x_3\\oplus x_4\\oplus x_5\\oplus x_9\\oplus x_{13} = b_1$$ 类似地，可以对第 $2,3,\\ldots,16$ 个火堆列出方程，并组成方程组： $$\\begin{cases}x_1\\oplus x_2\\oplus x_3\\oplus x_4\\oplus x_5\\oplus x_9\\oplus x_{13}&amp;=&amp;b_1\\\\x_1\\oplus x_2\\oplus x_3\\oplus x_4\\oplus x_6\\oplus x_{10}\\oplus x_{14}&amp;=&amp;b_2\\\\\\qquad\\qquad\\cdots\\\\x_4\\oplus x_8\\oplus x_{12}\\oplus x_{13}\\oplus x_{14}\\oplus x_{15}\\oplus x_{16}&amp;=&amp;b_{16}\\end{cases}$$ 于是，求解哪些火堆需要切换的问题则转化为了求解方程组的问题。 到了这一步，你的线性代数知识是否已被唤起？这里不再是线性方程组，而将线性方程中的加法换为异或，变为了 “异或方程组”，同样可以化为矩阵形式： $$Ax=b\\quad\\Leftrightarrow\\quad\\left[\\begin{array}{c}\\textcolor{red}{1}\\,\\textcolor{red}{1}\\,\\textcolor{red}{1}\\,\\textcolor{red}{1}\\,\\textcolor{red}{1}\\,0\\,0\\,0\\,\\textcolor{red}{1}\\,0\\,0\\,0\\,\\textcolor{red}{1}\\,0\\,0\\,0\\\\\\textcolor{red}{1}\\,\\textcolor{red}{1}\\,\\textcolor{red}{1}\\,\\textcolor{red}{1}\\,0\\,\\textcolor{red}{1}\\,0\\,0\\,0\\,\\textcolor{red}{1}\\,0\\,0\\,0\\,\\textcolor{red}{1}\\,0\\,0\\\\\\cdots\\;\\text{another 13 lines}\\;\\cdots\\\\0\\,0\\,0\\,\\textcolor{red}{1}\\,0\\,0\\,0\\,\\textcolor{red}{1}\\,0\\,0\\,0\\,\\textcolor{red}{1}\\,\\textcolor{red}{1}\\,\\textcolor{red}{1}\\,\\textcolor{red}{1}\\,\\textcolor{red}{1}\\end{array}\\right]x=b$$ 利用高斯消元法，对增广矩阵 $[A|b]$ 进行初等行变换（只包括行之间的异或运算），直到矩阵 $A$ 化为单位矩阵；而变换后的状态向量 $b$ 便成了我们需要求解的 $x$ 向量。 最后根据向量 $x$，按顺序输出即可。 如此，$4\\times4$ 的 “传火” 问题，甚至是 $m\\times n$ 的十字翻转棋问题，便能在 $O((mn)^2)$ 的时间复杂度下解决了。 参考代码solution.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;array&gt;#include &lt;bitset&gt;#include &lt;cstdio&gt;using namespace std;void solve(bitset&lt;16&gt;&amp; x){ // generate matrix A array&lt;bitset&lt;16&gt;, 16&gt; A; for (int i = 0; i != 4; ++i) for (int j = 0; j != 4; ++j) for (int k = 0; k != 4; ++k) { A[i * 4 + j].set(i * 4 + k); A[i * 4 + j].set(k * 4 + j); } for (int i = 0; i != 15; ++i) { // if A[i][i] is not a pivot // swap row i with the first row which has a pivot if (!A[i][i]) for (int j = i + 1; j != 16; ++j) if (A[j][i]) { swap(A[j], A[i]); bool tmp = x[j]; x[j] = x[i]; x[i] = tmp; break; } // eliminate for (int j = i + 1; j != 16; ++j) if (A[j][i]) { A[j] ^= A[i]; x[j] = x[j] ^ x[i]; } } // eliminate for (int i = 15; i != 0; --i) for (int j = i - 1; j &gt;= 0; --j) if (A[j][i]) { A[j] ^= A[i]; x[j] = x[j] ^ x[i]; }}int main(){ bitset&lt;16&gt; x; for (int i = 0; i != 4; ++i) { for (int j = 0; j != 4; ++j) if (getchar() == '+') x.set(i * 4 + j); getchar(); } solve(x); printf(&quot;%ld\\n&quot;, x.count()); for (int i = 0; i != 16; ++i) if (x[i]) printf(&quot;%d %d\\n&quot;, (i / 4) + 1, (i % 4) + 1);}","link":"/posts/the-cross-flip-game/"},{"title":"DAG的拓扑顺序与深度优先搜索","text":"刷 AtCoder 动态规划专题时，卡在了G题上面，大概是因为不熟悉拓扑顺序。 所以这篇文章将探讨有向无环图中的拓扑顺序与深度优先搜索算法。 定义In computer science, a topological sort or topological ordering of a directed graph is a linear ordering of its vertices such that for every directed edge uv from vertex u to vertex v, u comes before v in the ordering. WikipediaTopological sorting 拓扑排序，是将一个有向无环图中所有顶点排成一个线性序列，使得图中任意一条边 $\\langle u,v\\rangle$ 都满足 $u$ 在线性序列中出现在 $v$ 之前。 算法常见的实现算法有这两种，更常见的是第一种，它更符合直观理解。 Kahn’s algorithm简单来说，首先创建一个列表用于存储排序后的顶点。找到一个没有出度的顶点，将其放入列表的最后，切断以该顶点为起点的所有边，再去找没有出度的点，并一直重复这些过程直至所有顶点都已加入列表（如果没有全部加入列表却找不出没有出度的顶点了，这张图一定是有环图）。 示例代码Kahn.cpp123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int MAXN = 1e5 + 7;int cnt[MAXN]; // cnt[v] means the number of edges end with vvector&lt;int&gt; from[MAXN]; // to[v] stores ends of edges starting from int result[MAXN], idx;bool vis[MAXN]; // wether a vertx is already in the result listint main(){ int n, m; // n for vertices, m for edges scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i != m; ++i) { int u, v; // an edge from u to v scanf(&quot;%d%d&quot;, &amp;u, &amp;v); from[u].push_back(v); ++cnt[v]; } while (idx != n) { bool flag = true; for (int i = 1; i &lt;= n; ++i) { if (!vis[i] &amp;&amp; !cnt[i]) { flag = false; vis[i] = true; result[idx++] = i; for (int j : from[i]) --cnt[j]; } } if (flag) // finding no vertex with no predecessor puts(&quot;Not a DAG (cyclic graph).&quot;), exit(0); } // print vertices out in topological order printf(&quot;%d&quot;, result[0]); for (int i = 1; i != n; ++i) printf(&quot; %d&quot;, result[i]); puts(&quot;&quot;);} Depth-first search另一种算法使用了深度优先搜索。随意抽取一个未被造访的点进行深度优先搜索，搜索到 “叶子顶点”（只有入度没有出度的顶点）后将其加入搜索结果。深度优先搜索的过程中如果重复遇到同一个顶点，则该图不是 DAG（有回环）。 这里的深度优先搜索的目的是探索叶子顶点，探索完成后才会将顶点标上已造访的标记。为了判断是否重复遇到同一个顶点，需要使用另一个 “临时标记”，沿途记录某个顶点是否已被造访，并在一次探索完成后删除。要注意与判断该顶点是否已被造访的 “永久标记” 进行区分。 示例代码Depth-first-search.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int MAXN = 1e5 + 7;vector&lt;int&gt; from[MAXN]; // to[v] stores ends of edges starting from vint result[MAXN], idx;bool perm[MAXN], temp[MAXN]; // permanent mark and temporary markvoid dfs(int u){ if (temp[u]) puts(&quot;Not a DAG (cyclic graph).&quot;), exit(0); temp[u] = true; for (int v : from[u]) if (!perm[v]) dfs(v); temp[u] = false; perm[u] = true; // mind that recursion means deferred operations // that's why we have to do insertions from back to front result[--idx] = u;}int main(){ int n, m; // n for vertices, m for edges scanf(&quot;%d%d&quot;, &amp;n, &amp;m); idx = n; for (int i = 0; i != m; ++i) { int u, v; // an edge from u to v scanf(&quot;%d%d&quot;, &amp;u, &amp;v); from[u].push_back(v); } while (idx) for (int i = 1; i &lt;= n; ++i) if (!perm[i]) dfs(i); // print vertices out in topological order printf(&quot;%d&quot;, result[0]); for (int i = 1; i != n; ++i) printf(&quot; %d&quot;, result[i]); puts(&quot;&quot;);} 应用这里就用 AtCoder 动态规划专题的 G 题来举例。 题目链接：AtCoder Educational DP Contest - G - Longest Path 题意给出一张有向无环图，每条边的长度都是 $1$，求出图中最长路径的长度。 将前面的深度优先搜索算法改一改，除去 “临时标记”，并且在回溯过程中记下以某顶点为起点的最长路径长度&hairsp;$(dp_i)$&hairsp;。 为什么这与拓扑序有关？深度优先搜索的顺序其实就是拓扑序，先被访问的顶点不会再被访问。所以沿途记录下的最长路径长度，确定后便不再改变。基于先前的的计算结果，按照一定的顺序和规则不断更新，这也是使用动态规划的理由。 示例代码G.cpp12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int MAXN = 1e5 + 7;vector&lt;int&gt; from[MAXN];int dp[MAXN];int ans;void dfs(int u){ if (dp[u]) return; for (int v : from[u]) { dfs(v); dp[u] = max(dp[u], 1 + dp[v]); } if (dp[u] &gt; ans) ans = dp[u];}int main(){ int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i != m; ++i) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); from[u].push_back(v); } for (int i = 1; i &lt;= n; ++i) if (!dp[i]) dfs(i); printf(&quot;%d\\n&quot;, ans);}","link":"/posts/topological-order-and-depth-first-searching/"},{"title":"新增Valine评论系统","text":"给博客添加了评论系统 Valine，支持 Markdown 写作和 Gravatar 头像。 当然，博客本身的内容更重要，可是谁不喜欢折腾呢……","link":"/posts/valine-comment-system/"},{"title":"Concrete Mathematics Notes","text":"I have finished reading the first two chapters of Concrete Mathematics. Here are my notes on the book and solutions to the exercises.","link":"/redirect/concrete-mathematics/"}],"tags":[{"name":"Offline Query","slug":"offline-query","link":"/tags/offline-query/"},{"name":"Sparse Table","slug":"sparse-table","link":"/tags/sparse-table/"},{"name":"Number Theory","slug":"number-theory","link":"/tags/number-theory/"},{"name":"Graph Theory","slug":"graph-theory","link":"/tags/graph-theory/"},{"name":"Depth-first Searching","slug":"depth-first-searching","link":"/tags/depth-first-searching/"},{"name":"Brute Force","slug":"brute-force","link":"/tags/brute-force/"},{"name":"Dynamic Programming","slug":"dynamic-programming","link":"/tags/dynamic-programming/"},{"name":"Segment Tree","slug":"segment-tree","link":"/tags/segment-tree/"},{"name":"Monotonic Queue","slug":"monotonic-queue","link":"/tags/monotonic-queue/"},{"name":"Linear Algebra","slug":"linear-algebra","link":"/tags/linear-algebra/"}],"categories":[{"name":"Algorithm Contest","slug":"algorithm-contest","link":"/categories/algorithm-contest/"},{"name":"Mathematics","slug":"mathematics","link":"/categories/mathematics/"},{"name":"Segment Tree","slug":"algorithm-contest/segment-tree","link":"/categories/algorithm-contest/segment-tree/"}]}