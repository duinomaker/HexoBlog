{"pages":[{"title":"404","text":"哎呀，页面不见了！ Oops! The page couldn’t be reached. 博客维护记录：/maintenance/","link":"/404.html"},{"title":"Concrete Mathematics Notes","text":"PrefaceThese are my notes on Concrete Mathematics. Exercises in this book, compared to their SICP counterparts, are really more challenging. I’m running out of my brain power (together with draft paper) while solving them. To advance my proficiency in written English, I’ll be taking notes in English since April 25, 2020. Although previous works are done in Chinese, I feel no need to translate them, since it would be time-consuming and would have little to do with my comprehension of the book. NotesChapter I&nbsp;&nbsp;Recurrent ProblemsChapter II&nbsp;Sums ExercisesChapter I&nbsp;&nbsp;Recurrent ProblemsChapter II&nbsp;Sums","link":"/CM/"},{"title":"SICP Notes","text":"PrefaceThese are my notes on Structure and Interpretation of Computer Programs. To advance my proficiency in written English, I’ll be taking notes in English since April 25, 2020. Although previous works are done in Chinese, I feel no need to translate them, since it would be time-consuming and would have little to do with my comprehension of the book. NotesChapter I&nbsp;&nbsp;Building Abstractions with ProceduresChapter II&nbsp;Building Abstractions with Data Exercises1.1&nbsp;The Elements of Programming1.2&nbsp;Procedures and the Processes They Generate1.3&nbsp;Formulating Abstractions with Higher-Order Procedures2.1&nbsp;Introduction to Data Abstraction2.2&nbsp;Hierarchical Data and the Closure Property2.3&nbsp;Symbolic Data2.4&nbsp;Multiple Representations for Abstract Data Assets1&nbsp;The Miller–Rabin Primality Test","link":"/SICP/"},{"title":"About","text":"我是 duinomaker，就读于南京邮电大学，大一学生。 怀着对计算机科学的崇敬、对编程的热爱，本人正专注研读 Concrete Mathematics 和 SICP，并开始巩固算法知识。 本页面更新于 2020年7月1日 &nbsp;E-Mail: duinomaker@gmail.com","link":"/about/"},{"title":"Hello, intrepid explorer","text":"There’re possibly three reasons to explain your clicking on my avatar: You wanted to inspect my avatar You wanted to access my profile page You are excited about discovering something different If it was case one, here’s a high resolution one. If it was case two, go to the “About” page. If it was case three, maybe you have captured something strange in your address bar. Evidently, someplace in my blog conceals my diaries, you may discover the place by inspecting my GitHub repositories. Have fun!","link":"/diaries/"},{"title":"博客维护记录","text":"2020-07-01 改进字数统计功能，使其能统计到各笔记页面的字数 2020-06-28 禁用 Valine 评论系统2020-06-24 取消 RSS 订阅功能2020-06-23 移除网站备案信息2020-06-23 博客迁移至 Github Pages，页面资源使用 jsdelivr 提供 2020-05-15 增加页面内容的水平占比，调整卡片间的垂直距离2020-05-10 优化 MathJax 在移动设备上的显示效果 2020-04-17 移除主页卡片中的 “Read More” 按钮2020-04-14 开设 /notes/ 作为笔记的索引页2020-04-14 开设 /CM/ 用于记录 Concrete Mathematics 阅读笔记2020-04-09 默认的数学公式渲染器由 MathJax 改为 KaTeX2020-04-08 将 MathJax 更新至 3.x 版本2020-04-06 开设 /SICP/ 用于记录 SICP 阅读笔记2020-04-05 博客迁移至云主机2020-04-03 修改文章底部 hashtags 的样式，禁止其内容自动换行2020-04-03 修改内联代码字体颜色为 currentColor，大小为 0.875em 2020-03-28 禁用 Google Analytics 插件2020-03-26 添加网站备案信息2020-03-15 修复数学公式水平长度溢出问题，自动增加水平滚动条2020-03-10 增加 /about/ 页面的 Friends 区块2020-03-10 取消 /diaires/ 中各页面和 404 页面的评论功能2020-03-10 统一文章顶部分类与各子分类之间分割符颜色为灰色2020-03-05 增加 Valine 评论系统2020-03-02 缩小桌面版字体大小 2020-02-22 禁止 Safari 浏览器自动检测页面中电话号码2020-02-21 开设 /diaries/ 用于记录日记2020-02-20 禁止内置搜索引擎搜索 pages2020-02-20 调整导航栏 logo 垂直位置，使之在各平台都可以居中2020-02-20 禁用页面动画效果2020-02-17 更新 profile 中的头像2020-02-12 增加 gulp 插件压缩 html 文件2020-02-12 增加 sitemaps、auto nofollow 插件和 robots.txt2020-02-10 博客诞生","link":"/maintenance/"},{"title":"Notes","text":"Structure and Interpretationof Computer Programs Concrete Mathematics","link":"/notes/"},{"title":"Repositories","text":"随手写的一些实用工具。 2020-06-16 /repos/mega-helper/2020-04-03 /repos/white-space-converter/","link":"/repos/"},{"title":"Reasoning Bases","text":"Disappointed at my problem solving techniques today. Our house is equipped with a solar heat system. In the afternoon, I found out that hot water was no longer available, and the thermometer read only 40 centigrade, peculiar in such a sunny day. I referred to FAQs in the specification, my situation is most probably tank leakage in the effect of broken tubes. Due to my adherence to the belief that the water pump is for pumping water into the water tank, the pump works if and only if the water tank lacks pressure, the water tank lacks pressure if the water tank leaks, and the fact that the pump wasn’t working constantly, I deduced that the water tank doesn’t leak. But I was then shocked after my mom found the water meter spinning constantly. The persuasive fact is that the water pump is actually for draining water from the tank rather than for pumping water into the tank, my bases was flawed. Checking the water meter is an evident method but I didn’t come up with. My instinct is to think logically, and I was taught a lesson today that always to check the validity of bases when reasoning.","link":"/diaries/2020-06-07/"},{"title":"README","text":"更进一步地利用我的独立博客，我干脆连日记也一起放在上面，用于写下一些不成熟的想法和批判自己，理论上算是公开了。 这是个很矛盾的想法，其实我是写给自己看的——毕竟实际看到这个页面的人很少。但我又想在名义上沾上一些 “公开”，于是就这样做了。另外，如果你看到了这些页面，不要告诉我，不确定是个十分奇妙的感受。让其处于 被其他人看到了 和 没有被其他人看到 相互交织的一种状态，就像薛定谔的猫一样。 某些时候，一些特定的内容涉及隐私。这些内容我不想揭露，但必须得写下来，于是就有了加密机制。下方是加密内容的一个例子，我使用了 AES (CBC 模式 + PKCS7 填充)： decrypt 6e 43 1b a6 66 5d 5c a2 1e 16 1f e2 37 ad 1e 39 50 8c 88 55 2f 36 d1 4b 07 ff 11 2a 6f 82 78 05 f2 9e 09 21 73 22 05 86 51 91 a4 17 f0 bd 53 ad 密码错误的话，会提示再试一次。好奇的你可能会对密码输入框 “Inspect Element”，接着会发现一段长长的 SHA256 Digest，之后开始怀疑我是否严谨。说明一下吧，我喜欢烹饪，可是加盐时从来不考虑口味（雾 密码正确的话，这些绿色的字节就会变为： “这是一段加密文字。” 目录（目前只有破事水）2020-06-07&nbsp;Reasoning Bases","link":"/diaries/README/"},{"title":"","text":"function browserdetails(useragent) { var os = false; // var brand = false; var details = {}; if (Object(useragent).details !== undefined) { return useragent.details; } useragent = (' ' + useragent).toLowerCase(); // if (useragent.indexOf('~:') !== -1) { // brand = useragent.match(/~:(\\d+)/); // brand = brand && brand.pop() | 0; // } if (useragent.indexOf('windows phone') > 0) { os = 'Windows Phone'; } else if (useragent.indexOf('android') > 0 || useragent.indexOf('andr0id') > 0) { os = 'Android'; } else if (useragent.indexOf('iphone') > 0) { os = 'iPhone'; } else if (useragent.indexOf('imega') > 0) { os = 'iPhone'; } else if (useragent.indexOf('ipad') > 0) { os = 'iPad'; } else if (useragent.indexOf(' edga/') > 0) { os = 'Android'; } // else if (useragent.indexOf(' crios') > 0) { // details.brand = 'CriOS'; // } details.os = os || ''; // if (brand) { // details.brand = brand; // } return details; } var ua = window.navigator.userAgent.toLowerCase(); try { ua = Object(ua); ua.details = Object.create(browserdetails(ua)); } catch (e) { } function isMobile() { var mobileStrings = [ 'iphone', 'ipad', 'android', 'blackberry', 'nokia', 'opera mini', 'ucbrowser', 'windows mobile', 'windows phone', 'iemobile', 'mobile safari', 'bb10; touch' ]; for (var i = mobileStrings.length; i--;) { if (ua.indexOf(mobileStrings[i]) > 0) { return true; } } return false; } var is_mobile = isMobile(); var is_ios = is_mobile && (ua.indexOf('iphone') > -1 || ua.indexOf('ipad') > -1 || ua.indexOf('ipod') > -1); if (is_ios) { tmp = ua.match(/(?:iphone|cpu) os (\\d+)[\\._](\\d+)/); if (tmp) { is_ios = parseInt(tmp[1]); if (!is_ios) { is_ios = true; } } tmp = undefined; if (is_mobile) { // Prevent Safari's copy&paste bug.. window.onhashchange = function () { location.reload(); }; } } // file: mega://#!! // folder: mega://#F!! var input_bar = document.getElementsByClassName('input')[0]; function getAppLink() { var link = input_bar.value.trim(); var result = link.match(/mega.nz\\/(file|folder)\\/(.+)?#(.+)/); try { var key = result.pop(); var id = result.pop(); var type = result.pop(); } catch (e) { return false; } return (type === 'file' ? '#!' : '#F!') + id + '!' + key; } function getStoreLink() { switch (ua.details.os) { case 'iPad': case 'iPhone': return 'https://itunes.apple.com/app/mega/id706857885'; case 'Windows Phone': return 'zune://navigate/?phoneappID=1b70a4ef-8b9c-4058-adca-3b9ac8cc194a'; case 'Android': return 'https://play.google.com/store/apps/details?id=mega.privacy.android.app&referrer=meganzindexandroid'; default: return false; } } function redirectToApp() { var redirectLink = getAppLink(); if (!redirectLink) { window.alert(\"The link is invalid.\"); return; } // If iOS (iPhone, iPad, iPod), use method based off https://github.com/prabeengiri/DeepLinkingToNativeApp/ if (is_ios) { var appLink = 'mega://' + redirectLink; window.location = appLink; // var timeout = null; // var redirectToStore = function () { // window.top.location = getStoreLink(); // }; // var redirect = function () { // var ms = 500; // window.location = appLink; // if (is_ios > 8 && ua.details.brand !== 'CriOS') { // ms = 4100; // } // timeout = setTimeout(redirectToStore, ms); // }; // redirect(); } // Otherwise if Windows Phone else if (ua.details.os === 'Windows Phone') { window.location = 'mega://' + redirectLink; } // Otherwise if Android else if (ua.indexOf('android') > -1) { var intent = 'intent://' + redirectLink + '/#Intent;scheme=mega;package=mega.privacy.android.app;end'; document.location = intent; } else { // Otherwise show an error saying the device is unsupported window.alert('This device is unsupported.'); } return false; } function redirectToStore() { var storeLink = getStoreLink(); if (!storeLink) { window.alert('This device is unsupported.'); return; } window.top.location = storeLink; }","link":"/repos/mega-helper/helper.js"},{"title":"MEGA Helper","text":"如果您未安装MEGA应用，点击此处下载安装。 OPEN IN MEGA APP 该项目的源代码由MIT许可证进行许可。 project-hierarchy >folded1234mega-helper├── helper.js├── index.html└── LICENSE","link":"/repos/mega-helper/"},{"title":"","text":"const input_bar = document.getElementById('password') const output_bar = document.getElementById('out') function stringToBytes(str) { var bytes = new Array() var len, c len = str.length for (var i = 0; i < len; i++) { c = str.charCodeAt(i) if (c >= 0x010000 && c > 18) & 0x07) | 0xF0) bytes.push(((c >> 12) & 0x3F) | 0x80) bytes.push(((c >> 6) & 0x3F) | 0x80) bytes.push((c & 0x3F) | 0x80) } else if (c >= 0x000800 && c > 12) & 0x0F) | 0xE0) bytes.push(((c >> 6) & 0x3F) | 0x80) bytes.push((c & 0x3F) | 0x80) } else if (c >= 0x000080 && c > 6) & 0x1F) | 0xC0) bytes.push((c & 0x3F) | 0x80) } else { bytes.push(c & 0xFF) } } return bytes } function bytesToString(arr) { if (typeof arr === 'string') { return arr } var str = '', _arr = arr for (var i = 0; i < _arr.length; i++) { var one = _arr[i].toString(2), v = one.match(/^1+?(?=0)/) if (v && one.length == 8) { var bytesLength = v[0].length var store = _arr[i].toString(2).slice(7 - bytesLength) for (var st = 1; st < bytesLength; st++) { store += _arr[st + i].toString(2).slice(2) } str += String.fromCharCode(parseInt(store, 2)) i += bytesLength - 1 } else { str += String.fromCharCode(_arr[i]) } } return str } function encode() { let str = input_bar.value let length = stringToBytes(str).length if (length % 4) str = str.padEnd(Math.ceil(length / 4) * 4, '\\0') let bytes = stringToBytes(str) let groups = length / 4 let result = [] for (let i = 0; i < groups; ++i) { let tmp = 0 for (let j = 0; j < 4; ++j) tmp = tmp * 256 + bytes[i * 4 + j] for (let j = 0; j < 14; ++j) { result = [226, 128, 139 + (tmp % 5)].concat(result) tmp = Math.floor(tmp / 5) } } output_bar.innerHTML = bytesToString(result) } function decode() { let data = input_bar.value.match(/[\\u200b\\u200c\\u200d\\u200e\\u200f]/g) if (data == null || data.length % 14) { output_bar.innerHTML = '无隐藏信息或是格式错误' return } let cipher = data.map((c) => (c.charCodeAt(0) - 8203)) let result = [] let groups = cipher.length / 14 for (let i = 0; i < groups; ++i) { let tmp = 0 for (let j = 0; j < 14; ++j) tmp = tmp * 5 + cipher[i * 14 + j] for (let j = 0; j < 4; ++j) { result = [tmp % 256].concat(result) tmp = Math.floor(tmp / 256) } } output_bar.innerHTML = bytesToString(result) } document.getElementById('decode').removeAttribute('disabled') document.getElementById('encode').removeAttribute('disabled') var clipboard = new ClipboardJS(\"#encode\") clipboard.on('success', function (e) { if (output_bar.innerHTML == '') output_bar.innerHTML = '请输入需要编码的内容' else output_bar.innerHTML = '编码后的内容已复制到剪贴板' }) clipboard.on('error', function (e) { output_bar.innerHTML = '[' + output_bar.innerHTML + '] 复制失败，请手动复制中括号中的内容' })","link":"/repos/white-space-converter/converter-deprecated.js"},{"title":"","text":"const input_bar = document.getElementById('cipher') const output_bar = document.getElementById('out') const dict = '\\u200b\\ufeff' function stringToCipher(str, dict) { let hex = CryptoJS.enc.Utf8.parse(str).toString(CryptoJS.enc.Hex) let bytes = new Array for (let i = 0; i < hex.length; i += 2) bytes.push(parseInt(hex[i], 16) * 16 + parseInt(hex[i + 1], 16)) let result = '' for (let i = 0; i < bytes.length; ++i) { let tmp = '', t = bytes[i] for (let j = 0; j < 8; ++j) { tmp = dict[t % 2] + tmp t = Math.floor(t / 2) } result += tmp } if (result.length) return dict[0] + result return '' } function cipherToString(cipher, dict) { let bits = Array.from(cipher).map((x) => (x == dict[0] ? 0 : 1)) let bytes = new Array for (let i = 0, i_ = (bits.length - 1) / 8; i < i_; ++i) { let tmp = 0 for (let j = 0; j < 8; ++j) tmp = tmp * 2 + bits[i * 8 + j + 1] bytes.push(tmp) } let hex = '' for (let i = 0; i < bytes.length; ++i) hex += bytes[i].toString(16) return CryptoJS.enc.Hex.parse(hex).toString(CryptoJS.enc.Utf8) } function encode() { output_bar.innerHTML = stringToCipher(input_bar.value, dict) } function decode() { const regex = new RegExp(`[${dict[0]}${dict[1]}]`, 'g') let cipher = input_bar.value.match(regex) if (cipher == null) output_bar.innerHTML = '无隐藏内容' else if ((cipher.length - 1) % 8) output_bar.innerHTML = '编码格式有误' else output_bar.innerHTML = cipherToString(cipher.join(''), dict) } const clipboard = new ClipboardJS(\"#encode\") clipboard.on('success', function (e) { if (output_bar.innerHTML == '') output_bar.innerHTML = '请输入需要编码的内容' else output_bar.innerHTML = '编码后的内容已复制到剪贴板' }) clipboard.on('error', function (e) { if (output_bar.innerHTML == '') output_bar.innerHTML = '请输入需要编码的内容' else output_bar.innerHTML = '[' + output_bar.innerHTML + '] 复制失败，请手动复制中括号中的内容' }) document.getElementById('decode').removeAttribute('disabled') document.getElementById('encode').removeAttribute('disabled')","link":"/repos/white-space-converter/converter.js"},{"title":"White-space Converter","text":"decode encode 该项目的源代码由MIT许可证进行许可。 project-hierarchy >folded12345white-space-converter├── converter-deprecated.js├── converter.js├── index.html└── LICENSE","link":"/repos/white-space-converter/"},{"title":"Chapter 1 Recurrent Problems","text":"WarmupsHomework exercises1.8List $Q_1$ through $Q_6$, we could find out that $Q$ is periodic. $$\\begin{aligned}Q_m&amp;=\\alpha;\\\\Q_{m+1}&amp;=\\beta;\\\\Q_{m+2}&amp;=(1+\\beta)/\\alpha;\\\\Q_{m+3}&amp;=(1+\\alpha+\\beta)/(\\alpha\\beta);\\\\Q_{m+4}&amp;=(1+\\alpha)/\\beta,\\quad\\text{for $m\\in\\lbrace0,5,10,\\ldots\\rbrace$.}\\end{aligned}$$ 1.9a$$\\begin{aligned}x_1\\ldots x_{n}&amp;\\leq\\left(\\frac{x_1+\\cdots+x_{n-1}+x_n}{n}\\right)^n\\qquad\\text{by $(n-1)x_n=x_1+\\cdots+x_{n-1}$}\\\\x_1\\ldots x_{n}&amp;\\leq\\left(\\frac{(n-1)x_n+x_n}{n}\\right)^n\\\\x_1\\ldots x_{n-1}&amp;\\leq(x_n)^{n-1}\\\\x_1\\ldots x_{n-1}&amp;\\leq\\left(\\frac{x_1+\\cdots+x_{n-1}}{n-1}\\right)^{n-1}.\\end{aligned}$$ 1.9b$$\\begin{aligned}x_1\\ldots x_n x_{n+1}\\ldots x_{2n}&amp;\\leq\\left(\\frac{x_1+\\cdots+x_n}{n}\\right)^n\\left(\\frac{x_{n+1}+\\cdots+x_{2n}}{n}\\right)^n\\qquad\\text{by $P(2):x_1x_2\\leq\\left(\\frac{x_1+x_2}2\\right)^2$}\\\\&amp;\\leq\\left(\\frac{\\left(\\frac{x_1+\\cdots+x_n+x_{n+1}+\\cdots+x_{2n}}2\\right)^2}{n^2}\\right)^n\\\\&amp;\\leq\\left(\\frac{x_1+\\cdots+x_n+x_{n+1}+\\cdots+x_{2n}}{2n}\\right)^{2n}.\\end{aligned}$$ 1.9cFor example, $P(5)$ follows from $P(6)$ from $P(3)$ from $P(4)$ from $P(2)$ which is proved to be true. And whenever $n&gt;1$, $P(n)$ is finally based on $P(2)$. 1.10It’s clear that $Q_n=2R_n-1$ if we move $n-1$ disks counter-clockwise; move the largest disk clockwise; move $n-1$ disks counter-clockwise again. Then $R_n=2R_n+Q_{n-1}+2$ if we move $n-1$ disks counter-clockwise; move the largest disk clockwise; move $n-1$ disks clockwise; move the largest disk clockwise again; move $n-1$ disks back counter-clockwise. Plug $Q_n=2R_n-1$ in, then $R_n=Q_n+Q_{n-1}+1$. 1.11aMove a double $(n-1)$-tower, then move the two largest disks, which takes $2$ moves, then move the double $(n-1)$-tower again. Let $A_n$ be the minimum number of moves, hence $A_n=2A_{n-1}+2=2^{n+1}-2$. 1.11bLet $\\require{enclose}\\enclose{horizontalstrike}{B_n}$ be the minimum number of moves to move a double $\\require{enclose}\\enclose{horizontalstrike}{n}$-tower in the original order; $\\require{enclose}\\enclose{horizontalstrike}{H_n}$ be the minimum number of moves to move a double $\\require{enclose}\\enclose{horizontalstrike}{n}$-tower except for the bottom disk. Then we have $\\require{enclose}\\enclose{horizontalstrike}{B_n=H_n+1+B_{n-1}+1+B_{n-1}}$ and $\\require{enclose}\\enclose{horizontalstrike}{H_n=B_{n-1}+1+B_{n-1}}$. Insert $\\require{enclose}\\enclose{horizontalstrike}{H_n}$ to the $\\require{enclose}\\enclose{horizontalstrike}{B_n}$ equation, we could get $\\require{enclose}\\enclose{horizontalstrike}{B_n=4B_{n-1}+3=4^n-1}$. By referring to the answer, I found out that my approach above wasn’t correct. I’ve made a mistake that I postulated all disks never change the order during their moves, which is not necessary. It can be shown that no strategy does better than $B_n=A_{n-1}+2+A_{n-1}+2+B_{n-1}$. This strategy changes the order of bottom two disks twice but doesn’t care whether the upper disks keep the order during their moves, which is also the reason why we use $A_n$ here. Thus, $B_n=2^{n+2}-5$. 1.12$$A(m_1,\\ldots,m_n)=2A(m_1,\\ldots,m_{n-1})+m_n.$$ This is an equation of the “generalized Josephus” type, whose solution is $(m_1\\ldots m_k)_2$. 1.13We already know $n$ straight lines define $L_n=\\frac{n(n+1)}2+1$ regions on a plane, and when the $n$-th line is added in, $n$ new areas are created. Let the zig-zags be extremely narrow to be seen as straight lines to some extent. So when the $n$-th zig-zag is added in, $n$ new areas are created “in the straight line manner”. We could also see that when two zig-zags intersect, $8$ new areas are created “around their intersection” in the way shown below: And when the $n$-th zig-zag is added in, there are at most $n-1$ new “intersections”. So $$Z\\!Z_n=Z\\!Z_{n-1}+n+8(n-1)=\\frac92n^2+\\frac72n+1.$$ 1.14$n$ new areas are created when the $n$-th line is added into the plane, which is equal to the maximum number of line segments created by splitting a line with $n-1$ points. Analogously, $L_{n-1}$ new pieces of cheese is created when making the $n$-th slice. So, in recurrence form $$P_n=\\begin{cases}1,&amp;\\text{if $n=0$};\\\\P_{n-1}+L_{n-1},&amp;\\text{if $n&gt;0$}.\\end{cases}$$ We have $P_5=26$. 1.15The function $I$ has the same recursion relation as $J$, but with different boundary values, which are $I(2)=2,I(3)=1$. Thus, we cannot find a unique $I(1)$ that satisfies this recurrence. So we have to split it into two cases, one with $I(2)=2$ and one with $I(3)=1$. Let’s represent in terms of $n=2^m+l$, and let $\\beta_0=-1,\\beta_1=1$. The recurrence unfolds, binary-wise: $$\\begin{aligned}I\\big((b_mb_{m-1}\\ldots b_0)_ 2\\big)&amp;=2I\\big((b_mb_{m-1}\\ldots b_1)_ 2\\big)+\\beta _ {b_0}\\\\&amp;\\;\\;\\vdots\\\\&amp;=2^{m-1}I\\big((b_mb_{m-1})_2\\big)+\\cdots+2\\beta _{b_1}+\\beta _{b_0}.\\end{aligned}$$ Then we can stop here, so far the function $I$ have the same form as $J$, and the two leading bits $(b_mb_{m-1})_2$ are enough to contain the two cases: $$\\begin{aligned}J(2)=1,I(2)=2&amp;\\implies I(n)-J(n)=2^{m-1};\\\\J(3)=3,I(3)=1&amp;\\implies I(n)-J(n)=-2^m.\\end{aligned}$$ That is to say $$I(n)=\\begin{cases}J(n)+2^{m-1},&amp;\\text{if $0\\leq l&lt;2^{m-1}$};\\\\J(n)-2^m,&amp;\\text{if $2^{m-1}\\leq l&lt;2^m$}.\\end{cases}$$ 1.16Express $g(n)$ in the form $$g(n)=A(n)\\alpha+B(n)\\beta_0+C(n)\\beta_1+D(n)\\gamma.$$ Let $g(n)=1$, which implies $(\\alpha,\\beta_0,\\beta_1,\\gamma)=(1,-2,-2,0)$. Then $$A(n)-2B(n)-2C(n)=1.\\tag{1}$$ Let $g(n)=n$, which implies $(\\alpha,\\beta_0,\\beta_1,\\gamma)=(1,0,1,-1)$. Then $$A(n)+C(n)-D(n)=n.\\tag{2}$$ Let $(\\alpha,\\beta_0,\\beta_1,\\gamma)=(1,-2,-2,0)$, which gives $g(n)=3^m$. Then (note we’re representing in terms of $n=2^m+l$) $$A(n)=3^m.\\tag{3}$$ Let $(\\alpha,\\beta_0,\\beta_1,\\gamma)=(0,0,1,0)$. Similar to the binary expansion in the Josephus problem, we have $$C(n)=(b_{m-1}\\ldots b_0)_3.\\tag{4}$$ I also checked that for $(1)(2)(3)$ and $(4)$, $$\\left|\\begin{array}{cccc}1&amp;-2&amp;-2&amp;0\\\\1&amp;0&amp;1&amp;-1\\\\1&amp;0&amp;0&amp;0\\\\0&amp;0&amp;1&amp;0\\end{array}\\right|\\neq0.$$ The recurrence is solvable; hence $$\\begin{aligned}A(n)&amp;=3^m;\\\\B(n)&amp;=\\big(3^m-2(b_{m-1}\\ldots b_0)_ 3-1\\big)/2;\\\\C(n)&amp;=(b_{m-1}\\ldots b_0)_ 3;\\\\D(n)&amp;=3^m+(b_{m-1}\\ldots b_0)_3-n.\\end{aligned}$$ Then $$\\begin{aligned}g(n)&amp;=3^m\\alpha+\\big(3^m-2(b_{m-1}\\ldots b_0)_ 3-1\\big)\\frac{\\beta_0}2+(b_{m-1}\\ldots b_0)_ 3\\beta_1+\\big(3^m+(b_{m-1}\\ldots b_0)_ 3-n\\big)\\gamma\\\\&amp;=\\left(\\alpha+\\frac{\\beta_0}2+\\gamma\\right)3^m+(-\\beta_0+\\beta_1+\\gamma)(b_{m-1}\\ldots b_0)_3-\\frac{\\beta_0}2-n\\gamma.\\end{aligned}$$","link":"/CM/exercises/1/"},{"title":"Chapter 2 Sums","text":"WarmupsBasics2.11$$\\begin{aligned}\\sum_{0\\leq k\\lt n}(a_{k+1}-a_k)b_k&amp;=\\sum_{0\\leq k\\lt n}\\big(a_{k+1}b_{k+1}-a_kb_k-a_{k+1}(b_{k+1}-b_k)\\big)\\\\&amp;=\\sum_{0\\leq k\\lt n}(a_{k+1}b_{k+1}-a_kb_k)-\\sum_{0\\leq k\\lt n}a_{k+1}(b_{k+1}-b_k)\\\\&amp;=a_nb_n-a_0b_0-\\sum_{0\\leq k\\lt n}a_{k+1}(b_{k+1}-b_k),\\quad\\text{for $n\\geq0$.}\\end{aligned}$$ 2.12If $x=p(k)$ then $x+c=k+\\big((-1)^k+1\\big)c$. Observe that $\\big((-1)^k+1\\big)c$ is even, $x+c$ must have the same parity as $k$. This gives $(-1)^k=(-1)^{x+c}$ and $k=x-(-1)^{x+c}c$. Conversely, this value of $k$ yields $x=p(k)$. 2.13The sum is a special case of the general recurrence $$\\begin{aligned}R_0&amp;=\\alpha;\\\\R_n&amp;=R_{n-1}+(-1)^n(\\beta+\\gamma n+\\delta n^2),\\quad\\text{for $n&gt;0$,}\\end{aligned}$$ whose solution would be $$R(n)=A(n)\\alpha+B(n)\\beta+C(n)\\gamma+D(n)\\delta.$$ Setting $R_n=1$ yields $A(n)=1$.Setting $R_n=(-1)^n$ yields $A(n)+2B(n)=(-1)^n$.Setting $R_n=(-1)^nn$ yields $-B(n)+2C(n)=(-1)^nn$.Setting $R_n=(-1)^nn^2$ yields $-C(n)+2D(n)=(-1)^nn^2$. Therefore, $D(n)=(-1)^n(n^2+n)/2$. For this sum, we have $\\delta=1$; hence $$\\sum_{k=0}^n(-1)^kk^2=(-1)^n(n^2+n)/2.$$ 2.14$$\\begin{aligned}\\sum_{k=1}^nk2^k&amp;=\\sum_{1\\leq j\\leq k\\leq n}2^k\\\\&amp;=\\sum_{1\\leq j\\leq n}\\sum_{j\\leq k\\leq n}2^k\\\\&amp;=\\sum_{1\\leq j\\leq n}(2^{n+1}-2^j)\\\\&amp;=n2^{n+1}-(2^{n+1}-2)\\\\&amp;=(n-1)2^{n+1}-2.\\end{aligned}$$ 2.15$$\\begin{aligned}\\sum_{k=1}^nk^3+\\sum_{k=1}^nk^2&amp;=2\\sum_{1\\leq j\\leq k\\leq n}jk\\\\\\sum_{k=1}^nk^3+\\sum_{k=1}^nk^2&amp;=\\left(\\sum_{1\\leq k\\leq n}k\\right)^2+\\sum_{1\\leq k\\leq n}k^2\\\\\\sum_{k=1}^nk^3&amp;=\\left(\\sum_{1\\leq k\\leq n}k\\right)^2\\\\\\sum_{k=1}^nk^3&amp;=n^2(n+1)^2/4.\\end{aligned}$$ 2.16If no denominator is zero, $$\\begin{aligned}x^{\\underline m}/(x-n)^{\\underline m}&amp;=x^{\\underline n}/(x-m)^{\\underline n}\\\\x^{\\underline m}(x-m)^{\\underline n}&amp;=x^{\\underline n}(x-n)^{\\underline m},\\end{aligned}$$ the latter is applicable to the law of exponents. 2.17$$\\begin{aligned}x^{\\overline m}&amp;=x(x+1)\\cdots(x+m-1)\\\\&amp;=(-1)^m(-x)(-x-1)\\cdots(-x-m+1)\\\\&amp;=(-1)^m(-x)^{\\underline m}.\\end{aligned}$$ $$\\begin{aligned}x^{\\overline m}&amp;=x(x+1)\\cdots(x+m-1)\\\\&amp;=(x+m-1)\\cdots(x+1)x\\\\&amp;=(x+m-1)^{\\underline m}.\\end{aligned}$$ $$\\begin{aligned}x^{\\overline m}&amp;=x(x+1)\\cdots(x+m-1)\\\\&amp;=1/(x-1)^{\\underline{-m}}.\\end{aligned}$$ The second line is similar. 2.18If $\\sum_{k\\in K}a_k$ is absolutely convergent, so are $\\sum_{k\\in K}(\\Re a_k)^+$, $\\sum_{k\\in K}(\\Re a_k)^-$, $\\sum_{k\\in K}(\\Im a_k)^+$ and $\\sum_{k\\in K}(\\Im a_k)^-$. For all finite subset $F\\subsetneq K$, there must be a bounding constant $B$ such that $$\\sum_{k\\in F}|a_k|\\leq\\sum_{k\\in F}\\big((\\Re a_k)^++(\\Re a_k)^-+(\\Im a_k)^++(\\Im a_k)^-\\big)\\leq B.$$ Conversely, with the fact that $(\\Re z)^+,(\\Re z)^-,(\\Im z)^+,(\\Im z)^-\\leq|z|$, we know that $\\sum_{k\\in K}(\\Re a_k)^+$, $\\sum_{k\\in K}(\\Re a_k)^-$, $\\sum_{k\\in K}(\\Im a_k)^+$ and $\\sum_{k\\in K}(\\Im a_k)^-$ are each absolutely convergent, so is $\\sum_{k\\in K}a_k$. Homework exercises2.19Multiply both sides by $2^{n-1}/n!$, we get $$\\begin{aligned}\\frac{2^n}{n!}T_n&amp;=\\frac{2^{n-1}}{(n-1)!}T_{n-1}+3\\cdot2^{n-1}\\\\T_n&amp;=\\frac{n!}{2^n}\\left(T_0+\\sum_{k=1}^n3\\cdot2^{n-1}\\right)\\\\T_n&amp;=3\\cdot n!+\\frac{n!}{2^{n-1}}.\\end{aligned}$$ 2.20$$\\begin{aligned}\\sum_{k=0}^nkH_k&amp;=\\sum_{k=0}^n\\big((k+1)H_{k+1}-(n+1)H_{n+1}\\big)\\\\\\sum_{k=0}^nkH_k&amp;=\\sum_{k=0}^nkH_{k+1}+\\sum_{k=0}^nH_{k+1}-(n+1)H_{n+1}\\\\(n+1)H_{n+1}&amp;=\\sum_{k=0}^n\\frac k{k+1}+\\sum_{k=0}^nH_{k+1}\\\\(n+1)H_{n+1}&amp;=\\sum_{k=0}^n(H_k+1)\\\\(n+1)(H_n-1)&amp;=\\sum_{k=0}^nH_k.\\end{aligned}$$ 2.21$$\\begin{aligned}\\sum_{k=0}^n(-1)^{n-k}&amp;=\\sum_{k=0}^n(-1)^{n-k-1}+(-1)^n+1\\\\2\\sum_{k=0}^n(-1)^{n-k}&amp;=(-1)^n+1\\\\S_n&amp;=\\begin{cases}1,&amp;\\text{$n$ is even;}\\\\0,&amp;\\text{$n$ is odd.}\\end{cases}\\end{aligned}$$ $$\\begin{aligned}\\sum_{k=0}^n(-1)^{n-k}k&amp;=\\sum_{k=0}^n-(-1)^{n-k}(k+1)+n+1\\\\2\\sum_{k=0}^n(-1)^{n-k}k&amp;=-\\sum_{k=0}^n(-1)^{n-k}+n+1\\\\2T_n&amp;=-S_n+n+1\\\\T_n&amp;=\\begin{cases}n/2,&amp;\\text{$n$ is even;}\\\\(n+1)/2,&amp;\\text{$n$ is odd.}\\end{cases}\\end{aligned}$$ If we did the first step for $T_n$ differently, we could find out that $\\sum_{k=0}^n(-1)^{n-k}(2k+1)=n+1$, which would be useful later. $$\\begin{aligned}\\sum_{k=0}^n(-1)^{n-k}k^2&amp;=\\sum_{k=0}^n-(-1)^{n-k}(k^2+2k+1)+n^2+2n+1\\\\2\\sum_{k=0}^n(-1)^{n-k}k^2&amp;=-\\sum_{k=0}^n(-1)^{n-k}(2k+1)+n^2+2n+1\\\\2\\sum_{k=0}^n(-1)^{n-k}k^2&amp;=n^2+n\\\\U_n&amp;=n(n+1)/2.\\end{aligned}$$ 2.22$$\\begin{aligned}\\sum_{1\\leq j\\lt k\\leq n}(a_jb_k-a_kb_j)(A_jB_k-A_kB_j)&amp;=\\sum_{1\\leq j\\lt k\\leq n}(a_jb_kA_jB_k+a_kb_jA_kB_j)-\\sum_{1\\leq j\\lt k\\leq n}(a_jb_kA_kB_j+a_kb_jA_jB_k)\\\\&amp;=\\sum_{1\\leq j,k\\leq n}a_jb_kA_jB_k-\\sum_{1\\leq k\\leq n}a_kb_kA_kB_k-\\sum_{1\\leq j,k\\leq n}a_jb_kA_kB_j+\\sum_{1\\leq k\\leq n}a_kb_kA_kB_k\\\\&amp;=\\sum_{1\\leq j,k\\leq n}a_jb_kA_jB_k-\\sum_{1\\leq j,k\\leq n}a_jb_kA_kB_j\\\\&amp;=\\left(\\sum_{k=1}^na_kA_k\\right)\\left(\\sum_{k=1}^nb_kB_k\\right)-\\left(\\sum_{k=1}^na_kB_k\\right)\\left(\\sum_{k=1}^nb_kA_k\\right).\\end{aligned}$$ 2.23a$$\\begin{aligned}\\sum_{k=1}^n\\frac{2k+1}{k(k+1)}&amp;=\\sum_{k=1}^n(2k+1)\\left(\\frac1{k}-\\frac1{k+1}\\right)\\\\&amp;=\\sum_{k=1}^n\\frac1k+\\sum_{k=1}^n\\frac1{k+1}\\\\&amp;=2H_n-\\frac n{n+1}.\\end{aligned}$$ 2.23bLet $u=2k+1$, then $\\Delta v=(k-1)^{\\underline{-2}}$, $\\Delta u=2$ and $v=-(k-1)^{\\underline{-1}}$. $$\\begin{aligned}\\sum_{k=1}^n\\frac{2k+1}{k(k+1)}&amp;=-\\frac{2k+1}k\\Bigg|_1^{n+1}+\\sum _{1\\leq k\\lt n+1}2k^{\\underline{-1}}\\\\&amp;=2H_n-\\frac n{n+1}.\\end{aligned}$$ 2.24Sum by parts to evaluate the general form $\\sum_{0\\leq k\\lt n}H_kk^{\\underline m}$, let $u=H_k$, then $\\Delta v=k^{\\underline m}$, $\\Delta u=k^{\\underline{-1}}$ and $v=k^{\\underline{m+1}}/(m+1)$. $$\\begin{aligned}\\sum_{0\\leq k\\lt n}H_kk^{\\underline m}&amp;=H_k\\frac{k^{\\underline{m+1}}}{m+1}\\Bigg|_0^n-\\sum _{0\\leq k\\lt n}\\frac{k^{\\underline m}}{(m+1)^2}\\\\&amp;=\\frac{0^{\\underline{m+1}}}{(m+1)^2}+\\left(\\frac{H_n}{m+1}-\\frac1{(m+1)^2}\\right).\\end{aligned}$$ In this case, we have $m=-2$, so the sum is $1-(H_n+1)/(n+1)$. 2.25$$\\begin{aligned}&amp;\\prod_{k\\in K}a_k^c=\\left(\\prod_{k\\in K}a_k\\right)^c;&amp;&amp;\\text{(distributive law)}\\\\&amp;\\prod_{k\\in K}a_kb_k=\\left(\\prod_{k\\in K}a_k\\right)\\left(\\prod_{k\\in K}b_k\\right);&amp;&amp;\\text{(associative law)}\\\\&amp;\\prod_{k\\in K}a_k=\\prod_{p(k)\\in K}a_{p(k)};&amp;&amp;\\text{(commutative law)}\\\\&amp;\\prod_{k\\in K}a_k=\\prod_ka_k^{[k\\in K]};&amp;&amp;\\text{(Iverson’s convention)}\\\\&amp;\\prod_{\\substack{j\\in J\\\\k\\in K}}a_{j,k}=\\prod_{j\\in J}\\prod_{k\\in K}a_{j,k};&amp;&amp;\\text{(interchanging the order)}\\\\&amp;\\prod_{\\substack{j\\in J\\\\k\\in K}}a_j^{b_k}=\\left(\\prod_{j\\in J}a_j\\right)^{\\sum_{k\\in K}b_k}.&amp;&amp;\\text{(general distributive law)}\\end{aligned}$$ 2.26$$\\begin{aligned}\\left(\\prod_{1\\leq j\\leq k\\leq n}a_ja_k\\right)^2&amp;=\\left(\\prod_{1\\leq j,k\\leq n}a_ja_k\\right)\\left(\\prod_{1\\leq j=k\\leq n}a_ja_k\\right)\\\\\\left(\\prod_{1\\leq j\\leq k\\leq n}a_ja_k\\right)^2&amp;=\\left(\\prod_{1\\leq k\\leq n}a_k\\right)^n\\left(\\prod_{1\\leq k\\leq n}a_k\\right)^n\\left(\\prod_{1\\leq k\\leq n}a_k^2\\right)\\\\\\prod_{1\\leq j\\leq k\\leq n}a_ja_k&amp;=\\left(\\prod_{1\\leq k\\leq n}a_k\\right)^{n+1}.\\end{aligned}$$ 2.27$$\\begin{aligned}\\Delta(c^{\\underline x})&amp;=c^{\\underline{x+1}}-c^{\\underline x}\\\\&amp;=(c-1)c^{\\underline x}-xc^{\\underline x}.\\end{aligned}$$ $$\\begin{aligned}\\sum_{k=1}^n\\frac{(-2)^{\\underline k}}k&amp;=\\sum_{1\\leq k\\lt n+1}(k+1)(-2)^{\\underline{k-2}}\\\\&amp;=\\sum_{1\\leq k\\lt n+1}(k-2)(-2)^{\\underline{k-2}}-(-3)(-2)^{\\underline{k-2}}\\\\&amp;=-(-2)^{\\underline{k-2}}\\Big|_{1}^{n+1}\\\\&amp;=(-1)^nn!-1.\\end{aligned}$$ 2.28From the second line to the third line, the interchange of summation is not justifiable. That’s because the terms in $$\\sum_{k\\geq1}\\sum_{j\\geq1}\\left(\\frac{k}j[j=k+1]-\\frac{j}k[j=k-1]\\right)$$ do not converge absolutely.","link":"/CM/exercises/2/"},{"title":"第一章 递归问题","text":"这一章通过汉诺塔、线段分割平面、约瑟夫问题这三个问题引入了递归问题的概念。它们都用到递归的思想，即一定规模的问题的解取决于同一个问题更小规模的解。 为了解决这类问题，一般需要这些步骤： 给问题中需要求解的量命名； 探究小规模的问题，并尝试得到它们的解； 找到所求量的数学表达式，并证明； 如果可以，找到解的封闭形式，并证明。 在汉诺塔中，首先将需要求解的，将 $n$ 个盘转移到另一根柱的最少一定次数命名为 $T_n$，显然有 $T_0=0$ 成立。 接下来，观察到需要先移动 $n-1$ 个盘，再移动最底下的盘，最后再移动 $n-1$ 个盘。据此可以得到，移动 $2T_{n-1}+1$ 次就足够了，即 $T_n\\leq2T_{n-1}+1$&hairsp;；为了得到等号，还需证明移动 $2T_{n-1}+1$ 次是必须的，即 $T_n\\geq2T_{n-1}+1$，证明过程这里略过。 顺带一提，在线段分割平面问题中也是先找到上限&hairsp;$(L_n\\leq L_{n-1}+n)$，再证明能够取到等号，有些像充分必要性的证明。 总之，这样一来，就得出了 $$\\begin{aligned}T_0&amp;=0\\,;\\\\T_n&amp;=2T_{n-1}+1\\,,\\quad\\text{for}\\;n&gt;0\\,.\\end{aligned}$$ 这样的式子叫做递归式&hairsp;(recurrence)，由边界值和递归关系组成。为了方便有时只写出递归关系，尽管完整的式子是包含边界值的。 数学归纳法是一个用于证明某个关于整数 $n$ 的关系式的正确性的一般方法。首先是证明该关系式对某个 $n_0$ 成立，作为归纳基础&hairsp;(basis)&hairsp;；接着，在假定该关系式对于 $n_0$ 到 $n-1$ 的一切整数都成立的基础上，证明该关系式对于整数 $n$ 也成立，这称为归纳推理&hairsp;(induction)&hairsp;。 封闭形式的式子中，只包含 “经典的” 运算，加减乘除、乘方、阶乘等。例如 $1+2+\\cdots+n$ 不是封闭形式，因为它用 “$\\cdots$” 作弊；而 $n(n+1)/2$&hairsp;、$2^n-1$ 等都是封闭形式。 在推广约瑟夫问题时，我们需要求解 $$\\begin{aligned}f(1)&amp;=\\alpha\\,;\\\\f(2n)&amp;=2f(n)+\\beta\\,,\\quad\\text{for}\\;n\\geq1\\,;\\\\f(2n+1)&amp;=2f(n)+\\gamma\\,,\\quad\\text{for}\\;n\\geq1\\,.\\end{aligned}$$ 可以将上式的解表示为 $f(n)=A(n)\\alpha+B(n)\\beta+C(n)\\gamma\\,.\\quad(*)$ 于是我们引入成套方法&hairsp;(repertoire method)，它的本质是求解线性方程组。首先求出某些特殊情况的解，等攒够了特殊情况（有多少个未知函数就需要多少个特殊情况），再代入原式求解。 还是刚才的例子，选取这些特殊情况，分别是 $$\\begin{aligned}(\\alpha,\\beta,\\gamma)\\to(1,0,0)&amp;\\implies A(n)=2^m\\,;\\\\f(n)=1&amp;\\implies(\\alpha,\\beta,\\gamma)\\to(1,-1,-1)\\,;\\\\f(n)=n&amp;\\implies(\\alpha,\\beta,\\gamma)\\to(1,0,1)\\,.\\end{aligned}$$ 代入 $(*)$ 式可得到 $$\\begin{aligned}A(n)&amp;=2^m\\,,\\quad\\text{where}\\;n=2^m+l\\;\\text{and}\\;0\\leq l&lt;2^m\\,;\\\\A(n)-B(n)-C(n)&amp;=1\\,;\\\\A(n)+C(n)&amp;=n\\,.\\end{aligned}$$ 求出 $A(n)$&hairsp;、$B(n)$&hairsp;、$C(n)$ 后代入 $(*)$ 式，即可得解。","link":"/CM/notes/1/"},{"title":"Chapter 2 Sums","text":"2.1 NotationThe summation of an explicit sequence denoted as a succession of summations like $a_1+a_2+\\cdots+a_n$ can be written in the delimited form $\\sum_{k=1}^na_k$. Here, $a_k$ is called the summand, and $k$ is an index variable said to be bound to the summation. Summations can also be written in the general form like $\\sum_{1\\leq k\\leq n}a_k$, making it easier for manipulations such as substitution of index variables. 2.2 Sums and RecurrencesThere’s a neat relation between sums and recurrences. A sum like $$S_n=\\sum_{k=0}^na_k$$ is equivalent to the recurrence $$\\begin{aligned}S_0&amp;=a_0;\\\\S_n&amp;=S_{n-1}+a_n,\\quad\\text{for $n&gt;0$.}\\end{aligned}$$ Therefore we can evaluate a sum using methods of solving recurrences, such as the repertoire method we’ve learnt in Chapter 1. We developed a technique that can reduce any recurrence of the form $$a_nT_n=b_nT_{n-1}+c_n$$ to a sum, by multiplying both sides by a summation factor $s_n$, such that $s_nb_n=s_{b-1}a_{n-1}$. Then we can view $s_na_nT_n$ as a whole and go on. 2.3 Manipulation of SumsTo evaluate sums in closed form or to simplify sums, the key to success is the ability to change one summation into another under a few rules. Let $K$ be any finite set of integers. Sums over the elements of $K$ can be transformed by using these three rules: $$\\begin{aligned}\\sum_{k\\in K}{ca_k}&amp;=c\\sum_{k\\in K}{a_k};&amp;&amp;\\text{(distributive law)}\\\\\\sum_{k\\in K}(a_k+b_k)&amp;=\\sum_{k\\in K}a_k+\\sum_{k\\in K}b_k;&amp;&amp;\\text{(associative law)}\\\\\\sum_{k\\in K}a_k&amp;=\\sum_{p(k)\\in K}a_{p(k)}.&amp;&amp;\\text{(commutative law)}\\end{aligned}$$ The commutative law allows us to reorder terms. Here $p(k)$ is any permutation of the set of all integers. Actually, it’s a special case of a more generalized rule: Suppose there’s an arbitrary function $f:J\\to K$ that takes an integer $j\\in J$ into an integer $k\\in K$. The formula is $$\\sum_{j\\in J}a_{f(j)}=\\sum_{k\\in K}a_k\\#f^-(k),$$ where $\\#f^-(k)$ stands for the number of elements in the set $f^-(k)=\\lbrace j\\mid f(j)=k\\rbrace$. If $f$ is an one-to-one correspondence between $J$ and $K$, we have $\\#f^-(k)=1$ for all $k$, and the formula reduces to the commutative law. 2.4 Multiple SumsMultiple sums follow two additional rules: $$\\begin{aligned}\\sum_{P(j,k)}a_{j,k}&amp;=\\sum_j\\sum_ka_{j,k}[P(j,k)]=\\sum_k\\sum_ja_{j,k}[P(j,k)];&amp;&amp;\\text{(interchanging the order of summation)}\\\\\\sum_{\\substack{j\\in J\\\\k\\in K}}a_jb_k&amp;=\\left(\\sum_{j\\in J}a_j\\right)\\left(\\sum_{k\\in K}b_k\\right).&amp;&amp;\\text{(general distributive law)}\\end{aligned}$$ Another representation of the law of interchanging the order of summation is $$\\sum_{j\\in J}\\sum_{k\\in K(j)}a_{j,k}=\\sum_{k\\in K^\\prime}\\sum_{j\\in J^\\prime(k)}a_{j,k}.$$ Here the sets $J$, $K(j)$, $K^\\prime$ and $J^\\prime(k)$ must be related in such a way that $$[k\\in K][j\\in J(k)]=[j\\in J^\\prime][k\\in K^\\prime(j)].$$ It might be hard to understand at the first sight. But imagine that all items spread within a table like the one here: the left-hand side of the equation means for every $k$, sum up all items available in the $k$-th column, that is, all items in $J(k)$; the right-hand side is similar, $K^\\prime(j)$ is the set of all items available in the $j$-th row. 2.5 General MethodsMethod 0 is to look up. The authors suggested a few huge books for manual look ups. Fortunately, the on-line database OEIS is available; it is a more suitable tool than books for such knowledge. Method 1 is guessing then proving. Since guessing needs flashes of inspiration, this method do not always work, and proving should in fact be a complement for other methods that establish sums from scratch. Method 2 is the perturbation method. Perturb the sum a bit, then find relations between the perturbed sum and the original sum. Method 3 is the repertoire method. This method still needs intuition to determine what form the recursion should be. Method 4 uses infinite calculus to approximate the sum, then use other methods to compensate for the error terms. Method 5 is to clever rewrite of the original sum. This method requires even more intuition than the repertoire method does. Expand a single sum to multiple sums to simplify the summand. Method 6 is the topic of the next section. Method 7 will be introduced in later chapters. 2.6 Finite and Inifinite CalculusJust like in calculus, we need a huge repertoire to evaluate sums effectively. Here are some useful formula: $$\\begin{aligned}&amp;x^{\\underline{m+n}}=x^{\\underline m}(x-m)^{\\underline n};\\\\&amp;\\sum\\nolimits_a^bc^x\\delta x=\\frac{c^b-c^a}{c-1};\\\\&amp;\\sum\\nolimits_a^bx^{\\underline m}\\delta x=\\begin{cases}\\frac{x^{\\underline{m+1}}}{m+1}\\Big|_a^b,&amp;\\text{if $m\\neq-1$;}\\\\H_x\\Big|_a^b,&amp;\\text{if $m=-1$.}\\end{cases}\\end{aligned}$$ The relation of $\\Delta(uv)=u\\Delta v+{\\rm E}v\\Delta u$ yields the rule for summation by parts: $$\\sum u\\Delta v=uv-\\sum{\\rm E}v\\Delta u.$$ This rule is useful when $\\sum{\\rm E}v\\Delta u$ is easier to evaluate than the original one. 2.7 Infinite SumsIn this section, we proved the validity of the three basic laws for absolutely convergent sums. Make sure the sum converges absolutely before applying these rules.","link":"/CM/notes/2/"},{"title":"1.1 程序设计的基本元素","text":"Exercise 1.110, 12, 8, 3, 6, a, b, 19, #f, 4, 16, 6, 16Exercise 1.2(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5))))) (* 3 (- 6 2) (- 2 7)))Exercise 1.3(define (square a) (* a a)) (define (square-sum a b) (+ (square a) (square b))) (define (square-sum-of-two-larger-numbers a b c) (cond ((not (or (&gt; a b) (&gt; a c))) (square-sum b c)) ((not (or (&gt; b a) (&gt; b c))) (square-sum a c)) (else (square-sum a b))))Exercise 1.4若 b 为正数，求出 (+ a b) 的值，否则求出 (- a b) 的值。 Exercise 1.5正则序求值： (test 0 (p)) (if (= 0 0) 0 (p)) 0应用序求值： (test 0 (p)) (if (= 0 0) 0 (p)) (if (= 0 0) 0 (p)) (if (= 0 0) 0 (p)) ...应用序求值时，先要展开所有表达式。表达式 (p) 展开后仍是 (p)，所以应用序求值的方式无法对该式求值。 Exercise 1.6求不出表达式的值。new-if 不是特殊形式，意味着它是一个一般的过程，使用应用序求值。sqrt-iter 过程展开后永远包含另一个 sqrt-iter 过程，编译器会无休止地将展开重复下去。 Exercise 1.7例如 (sqrt 0.00000001) 应当算出 $0.0001$，实际得到的是 $0.031250$ 左右，但是符合 good-enough? 的条件；再比如 (sqrt 20000000000000000)，估值一直停留在 $141421356.237309$ 左右，足够精确却达不到 good-enough? 的条件。 将 good-enough? 的定义改为以下，可以改进程序： (define (good-enough? guess x) (&lt; (abs (- (square guess) x)) (* guess 0.001)))Exercise 1.8(define (cube x) (* x x x)) (define (good-enuf? guess x) (&lt; (abs (- (cube guess) x)) (* guess 0.001))) (define (improve guess x) (/ (+ (/ x (* guess guess)) (* guess 2)) 3)) (define (cbrt-iter guess x) (if (good-enuf? guess x) guess (cbrt-iter (improve guess x) x))) (define (cbrt x) (cbrt-iter 1.0 x))","link":"/SICP/exercises/1-1/"},{"title":"1.2 过程与它们所产生的计算","text":"Exercise 1.9情形一，递归计算 (+ 4 5) (inc (+ (dec 4) 5)) (inc (inc (+ (dec 3) 5))) (inc (inc (inc (+ (dec 2) 5)))) (inc (inc (inc (inc (+ (dec 1) 5))))) (inc (inc (inc (inc (+ 0 5))))) (inc (inc (inc (inc 5)))) (inc (inc (inc 6))) (inc (inc 7)) (inc 8) 9情形二，迭代计算 (+ 4 5) (+ 3 6) (+ 2 7) (+ 1 8) (+ 0 9) 9Exercise 1.101024, 65536, 65536$f(n)=2n$$g(n)=2^n$$h(n)=2^{2^{2^{\\cdot^{\\cdot^\\cdot}}}}(\\text{共有}\\,n\\,\\text{个}\\,2)$ Exercise 1.11递归计算 (define (f n) (if (&lt; n 3) n (+ (f (- n 1)) (f (- n 2)) (f (- n 3)))))迭代计算 (define (f-iter n) (define (f-impl n a b c) (if (= n 0) a (f-impl (- n 1) b c (+ a b c)))) (f-impl n 0 1 2))Exercise 1.12(define (pascal row col) (if (or (= col 0) (= row col)) 1 (+ (pascal (- row 1) (- col 1)) (pascal (- row 1) col))))Exercise 1.13首先，从 Fibonacci 的定义开始： $${\\rm Fib}(n)={\\rm Fib}(n-1)+{\\rm Fib}(n-2)$$ 若假设成立，则将 ${\\rm Fib}(n)=\\frac{\\phi^n-\\psi^n}{\\sqrt5}$ 代入式中，得出： $$\\begin{aligned}\\frac{\\phi^n-\\psi^n}{\\sqrt5}=\\frac{\\phi^{n-1}-\\psi^{n-1}}{\\sqrt5}+\\frac{\\phi^{n-2}-\\psi^{n-2}}{\\sqrt5}\\\\\\phi^n-\\psi^n=\\phi^n\\left(\\frac1\\phi+\\frac1{\\phi^2}\\right)-\\psi^n\\left(\\frac1\\psi+\\frac1{\\psi^2}\\right)\\end{aligned}$$ 由 $\\phi=\\frac{1+\\sqrt5}{2}$ 和 $\\psi=\\frac{1-\\sqrt5}{2}$ 可知： $$\\frac1\\phi+\\frac1{\\phi^2}=1,\\;\\frac1\\psi+\\frac1{\\psi^2}=1$$ 代回上式，算式左右两边相等，所以假设成立。接下来将其拆开： $$\\begin{aligned}{\\rm Fib}(n)=\\frac{\\phi^n-\\psi^n}{\\sqrt5}=\\frac{\\phi^n}{\\sqrt5}-\\frac{\\psi^n}{\\sqrt5}\\\\\\frac{\\phi^n}{\\sqrt5}={\\rm Fib}(n)+\\frac{\\psi^n}{\\sqrt5}\\end{aligned}$$ 要证明 ${\\rm Fib}(n)$ 是与 $\\frac{\\phi^n}{\\sqrt5}$ 最接近的整数，只需证明 $\\left|\\frac{\\psi^n}{\\sqrt5}\\right|&lt;\\frac1{2}$ 对于一切非负整数 $n$ 成立： 首先，归纳基础 $\\left|\\frac{\\psi^0}{\\sqrt5}\\right|\\approx0.447&lt;\\frac1{2}$ 成立。 假设 $\\left|\\frac{\\psi^{n-1}}{\\sqrt5}\\right|&lt;\\frac1{2}$ 成立，而 $\\left|\\frac{\\psi^n}{\\sqrt5}\\right|=\\left|\\frac{\\psi^{n-1}}{\\sqrt5}\\right|\\cdot|\\psi|$&hairsp;。因为 $|\\psi|&lt;1$，所以 $\\left|\\frac{\\psi^n}{\\sqrt5}\\right|&lt;\\left|\\frac{\\psi^{n-1}}{\\sqrt5}\\right|&lt;\\frac1{2}$&hairsp;。所以 $\\left|\\frac{\\psi^n}{\\sqrt5}\\right|&lt;\\frac1{2}$ 对于一切非负整数 $n$ 成立。 所以 ${\\rm Fib}(n)$ 是与 $\\frac{\\phi^n}{\\sqrt5}$ 最接近的整数，证毕。 Exercise 1.14递归过程中只需要记录该节点之上的节点信息，所以需要的空间与调用树的最大深度成正比。 (cc amount kinds) 节点包含着种类数不变而零钱量减少某个常数的节点，其以下部分的最大深度显然与 amount 成正比，所以空间为 $\\Theta(n)$&hairsp;。 考虑 (cc n 0) 的情况，由于是叶子节点，所需时间为 $\\Theta(1)$&hairsp;；再看 (cc n 1) 的情况，其下方有一条像链一样连接着的，从 (cc (- n 1) 1) 直至 (cc 0 1) 的 $n$ 个节点，而这些节点又额外地包含了一个形如 (cc x 0)&hairsp;、所需时间为 $\\Theta(1)$ 的节点。所以这时的所需时间为 $\\Theta(n)$&hairsp;；接下来，(cc n 2)&hairsp;、(cc n 3) 等的情况，可以仿照 (cc n 1) 的情况来分析，kinds 每增加 $1$，所需时间就得 “乘上一个 $n$”。 综上所述，有 $k$ 种货币时，时间为 $\\Theta(n^k)$&hairsp;。 Exercise 1.15a. p 被调用了 $5$ 次。b. 空间增长为 $\\Theta(\\log n)$ 阶，时间增长也为 $\\Theta(\\log n)$ 阶。 Exercide 1.16(define (fast-expt b n) (define (fast-expt-impl ans tmp m) (if (= m 0) ans (if (even? m) (fast-expt-impl ans (square tmp) (/ m 2)) (fast-expt-impl (* ans tmp) tmp (- m 1))))) (fast-expt-impl 1 b n))Exercise 1.17(define (double x) (+ x x)) (define (halve x) (/ x 2)) (define (mul a b) (if (= b 0) 0 (if (even? b) (mul (double a) (halve b)) (+ a (mul a (- b 1))))))Exercise 1.18(define (double x) (+ x x)) (define (halve x) (/ x 2)) (define (mul a b) (define (mul-impl ans tmp m) (if (= m 0) ans (if (even? m) (mul-impl ans (double tmp) (halve m)) (mul-impl (+ ans tmp) tmp (- m 1))))) (mul-impl 0 a b))Exercise 1.19(define (fib n) (fib-iter 1 0 0 1 n)) (define (fib-iter a b p q count) (cond ((= count 0) b) ((even? count) (fib-iter a b (+ (* p p) (* q q)) (+ (* q q) (* p q 2)) (/ count 2))) (else (fib-iter (+ (* b q) (* a q) (* a p)) (+ (* b p) (* a q)) p q (- count 1)))))Exercise 1.20应用序求值 (gcd 206 40) (gcd 40 (remainder 206 40)) (gcd 6 (remainder 40 6)) (gcd 4 (remainder 6 4)) (gcd 2 (remainder 4 2)) (gcd 2 0) 2remainder 一共被调用了 $4$ 次。 正则序求值 (gcd 206 40) (if (= 40 0) ...) (gcd 40 (remainder 206 40)) (if (= (remainder 206 40) 0) ...) (if (= 6 0) ...) (gcd (remainder 206 40) (remainder 40 (remainder 206 40))) (if (= (remainder 40 (remainder 206 40)) 0) ...) (if (= 4 0) ...) (gcd (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) (if (= (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) 0) ...) (if (= 2 0) ...) (gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))) (if (= (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) 0) ...) (if (= 0 0) ...) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) 2remainder 一共被调用了 $18$ 次：$14$ 次用在条件判断中，$4$ 次用在最后的计算中。 正则序求值最后用于计算的调用次数，等于应用序求值的总调用次数。接下来只需要分析用于条件判断的调用次数。 将第 $n$ 条 if 表达式的条件部分中 remainder 的出现次数记作 $f(n)$，可以发现 $$\\begin{aligned}f(0)&amp;=0,\\;f(1)=1\\\\f(n)&amp;=f(n-1)+f(n-2)+1\\end{aligned}$$ 稍加推导，可以发现 $$\\begin{aligned}f(n)-f(n-1)&amp;={\\rm Fib}(n)\\\\f(n)&amp;=\\sum_{i=0}^n{\\rm Fib}(i)\\\\f(n)&amp;={\\rm Fib}(n+2)-1\\end{aligned}$$ 设 remainder 在应用序求值中的总调用次数为 $n$，在正则序求值中的总调用次数为 ${\\rm R}(n)$，可以得出 $$\\begin{aligned}{\\rm R}(n)&amp;=n+\\sum_{i=0}^nf(i)\\\\{\\rm R}(n)&amp;={\\rm Fib}(n+4)-3\\end{aligned}$$ 本题中 ${\\rm R}(4)=18$，由此可以看出正则序求值可能造成大量的冗余计算。 Exercise 1.21199, 1999, 7Exercise 1.22不得不吐槽书中的程序，实在不好用，所以自己重写了一个，正好后面几题也用得到： (define (report-time start-time) (display (- (runtime) start-time)) (newline)) (define (conditional-time-report pred-proc p1) (define (timer start-time) (cond ((pred-proc p1) (report-time start-time) #t) (else #f))) (timer (runtime))) (define (search-for-primes num cnt) (if (&gt; cnt 0) (if (conditional-time-report prime? num) (search-for-primes (+ num 2) (- cnt 1)) (search-for-primes (+ num 2) cnt)))) (search-for-primes &lt;an odd number to start with&gt; &lt;how many prime numbers before stop&gt;)$n$ 每增加 $4$ 倍，运行时间大约增加 $2$ 倍，这可以粗略地验证该算法的增长阶为 $\\Theta(\\sqrt n)$&hairsp;。 Exercise 1.23时间大约是原来的一半多一些：一半因为要测试的数减少了约一半，多一些是因为一个额外的 if 语句。 Exercise 1.24增长得比预期更快。这是因为，基本操作的所需时间，会随着数字规模的增大而增加的。而这时，我们得出增长阶为 $\\Theta(\\log n)$ 的假设——基本操作需要常数时间——失效了。 Exercise 1.25对是对，但这样做会产生巨大的中间数，从而需要大量时间来处理大数。 Exercise 1.26用两次递归调用代替了原来的平方，现在的 expmod 呈现树形递归，计算树形递归的所需时间根据树高呈指数增长。这里树高为 $\\log(n)$，那么增长阶为 $\\Theta(e^{\\log n})=\\Theta(n)$&hairsp;。 Exercise 1.27(define (full-fermat-test n) (define (test-it a) (= (expmod a n n) a)) (define (test-impl m) (cond ((= m n) #t) ((test-it m) (test-impl (+ m 1))) (else #f))) (test-impl 1)) (full-fermat-test 561) (full-fermat-test 1105) (full-fermat-test 1729) ... (prime? 561) (prime? 1105) (prime? 1729) ...用 prime? 确定它们都不是素数，但 “骗过” 了所有费马测试。 Exercise 1.28这题有些难度，用到了一个结论：若存在 $1\\lt a\\lt n-1$，使得 $a^2\\equiv 1\\;({\\rm mod}\\;n)$ 成立，则 $n$ 不是素数。 证明这个结论，需要证明若 $n$ 是素数，则 $x_1=1,x_2=n-1$ 是 $x^2\\equiv1\\;({\\rm mod}\\;n)$ 仅有的两个解： $$\\begin{aligned}\\begin{aligned}x^2&amp;\\equiv1\\;({\\rm mod}\\;n)\\\\x^2-1&amp;\\equiv0\\;({\\rm mod}\\;n)\\\\(x-1)(x+1)&amp;\\equiv0\\;({\\rm mod}\\;n)\\end{aligned}\\\\\\begin{aligned}&amp;\\therefore n\\mid(x-1)\\;\\text{或}\\;n\\mid(x+1)\\\\&amp;\\because n\\;\\text{是素数}\\;\\therefore(x-1)\\;\\text{或}\\;(x+1)\\;\\text{是}\\;n\\;\\text{的倍数}\\\\&amp;\\therefore x_1=1,x_2=n-1\\end{aligned}\\end{aligned}$$ 若 $1\\lt a\\lt n-1$ 是其解，则称 $a$ 为 $n$ 的 非平凡平方根&hairsp;$($$\\textit{nontrivial square root}$$)$&hairsp;。若 $n$ 有非平凡平方根，则其不是素数。 这题用到了另一个技巧，修改了 expmod 过程，使其在找到非平凡平方根后返回 $0$&hairsp;。这样一来，一旦过程中出现非平凡平方根，整个 expmod 的值将是 $0$，便于之后的判断。为了理解这一点，我整理了$\\text{Miller–Rabin}$素性测试的原理及实现。 (define (square x) (* x x)) (define (miller-rabin-expmod base ex n) (define (squaremod-with-check x) (define (check squaremod-x) (if (and (= squaremod-x 1) (not (= x 1)) (not (= x (- n 1)))) 0 squaremod-x)) (check (remainder (* x x) n))) (cond ((= ex 0) 1) ((even? ex) (squaremod-with-check (miller-rabin-expmod base (/ ex 2) n))) (else (remainder (* base (miller-rabin-expmod base (- ex 1) n)) n)))) (define (miller-rabin-test n rounds) (define (test-it a) (define (test-impl expmod-a) (= expmod-a 1)) (test-impl (miller-rabin-expmod a (- n 1) n))) (cond ((= rounds 0) #t) ((test-it (+ 1 (random (- n 1)))) (miller-rabin-test n (- rounds 1))) (else #f)))","link":"/SICP/exercises/1-2/"},{"title":"1.3 用高阶函数做抽象","text":"Exercise 1.29为了避免 h 被重复求值多次，我在最外层定义了一个 h-equals，也就是将已经求出的值绑定给了 h&hairsp;。这就有点像赋值操作了，而函数式编程范式一个重要的特点却是 “无状态性”。是不是偏离了原本的意图呢？有些费解。 (define (simpson f a b n) (define (h-equals h) (define (term k) (define (coef k) (cond ((or (= k 0) (= k n)) 1) ((even? k) 2) (else 4))) (* (coef k) (f (+ a (* k h))))) (define (next k) (+ k 1)) (* (sum term 0 next n) (/ h 3))) (h-equals (/ (- b a) n)))Exercise 1.30(define (sum term a next b) (define (iter a result) (if (&gt; a b) result (iter (next a) (+ result (term a))))) (iter a 0))Exercise 1.31这里为了方便，pi-approx 将两项合并为一项来计算了，大概不算犯规吧。 (define (square x) (* x x)) (define (product term a next b) (define (iter a result) (if (&gt; a b) result (iter (next a) (* result (term a))))) (iter a 1)) (define (factorial n) (define (self x) x) (define (next x) (+ x 1)) (product self 1 next n)) (define (pi-approx n) (define (term x) (* (/ (* (+ 2 (* x 2)) (+ 4 (* x 2))) (square (+ 3 (* x 2)))) 1.0)) (define (next x) (+ x 1)) (* (product term 0 next n) 4))Exercise 1.32(define (accumulate combiner null-value term a next b) (if (&gt; a b) null-value (combiner (term a) (accumulate combiner null-value term (next a) next b)))) (define (accumulate-iter combiner null-value term a next b) (define (iter a result) (if (&gt; a b) result (iter (next a) (combiner (term a) result)))) (iter a null-value))Exercise 1.33(define (filtered-accumulate filter combiner null-value term a next b) (define (iter a result) (if (&gt; a b) result (if (filter a) (iter (next a) (combiner (term a) result)) (iter (next a) result)))) (iter a null-value)) (define (coprime? a b) (= (gcd a b) 1)) (define (sum-primes a b) (define (next x) (+ x 1)) (filtered-accumulate prime? + 0 square a next b)) (define (sum-coprimes n) (define (coprime-with-n? x) (coprime? n x)) (define (next x) (+ x 1)) (define (self x) x) (filtered-accumulate coprime-with-n? + 0 self 1 next (- n 1)))Exercise 1.34演变过程是这样的： (f f) (f 2) (2 2)对 (2 2) 求值就会出错，本来应该放置过程的位置是 2，而它不是一个过程。 Exercise 1.35(define golden-ratio (fixed-point (lambda (x) (+ 1.0 (/ 1.0 x))) 1.0))正确地逼近了黄金分割比例的值。 Exercise 1.36(define (root-x-pow-x start-point) (fixed-point (lambda (x) (/ (log 1000) (log x))) start-point 0)) (define (root-x-pow-x-with-damp start-point) (define (damp-func x) (/ (+ x (/ (log 1000) (log x))) 2.0)) (fixed-point damp-func start-point 0)) (root-x-pow-x 3.0) (root-x-pow-x 10.0) (root-x-pow-x-with-damp 3.0) (root-x-pow-x-with-damp 10.0)阻尼法所需的迭代步数更少。 Exercise 1.37(define (cont-frac n d k) (define (frac-transform term k) (/ (n k) (+ (d k) term))) (define (rec i) (if (&gt; i k) 0.0 (frac-transform (rec (+ i 1)) i))) (rec 1)) (define (cont-frac-iter n d k) (define (frac-transform term k) (/ (n k) (+ (d k) term))) (define (iter result k) (if (= k 0) result (iter (frac-transform result k) (- k 1)))) (iter 0.0 k)) (cont-frac (lambda (x) 1.0) (lambda (x) 1.0) 11) (cont-frac-iter (lambda (x) 1.0) (lambda (x) 1.0) 11)为了达到 $4$ 位小数的精度，需要十几步计算。 Exercise 1.38(define (approx-e k) (define (arr n) (let ((t (+ n 1))) (if (= (remainder t 3) 0) (* (/ t 3) 2.0) 1.0))) (+ (cont-frac (lambda (x) 1.0) arr k) 2))Exercise 1.39(define (tan-cf x k) (let ((minus-x2 (- (* x x)))) (define (n k) (if (= k 1) x minus-x2)) (define (d k) (* (- (* k 2) 1) 1.0)) (cont-frac n d k)))Exercise 1.40(define (cubic a b c) (lambda (x) (+ (* x x x) (* a x x) (* b x) c)))Exercise 1.41(define (double f) (lambda (x) (f (f x)))) (((double (double double)) inc) 5)输出了 $21$，因为 inc 外面嵌套了 $4$ 个 double，所以一共增加了 $2^4=16$ 次。 Exercise 1.42(define (compose f g) (lambda (x) (f (g x))))Exercise 1.43(define (repeated f times) (lambda (x) (cond ((= times 0) x) ((even? times) ((double (repeated f (/ times 2))) x)) (else ((compose f (repeated f (- times 1))) x)))))Exercise 1.44(define (n-fold f n dx) (define (smooth f) (lambda (x) (/ (+ (f (- x dx)) (f x) (f (+ x dx))) 3))) ((repeated smooth n) f))Exercise 1.45(define (log2-ceil n) (define (iter x ord) (if (&lt; x n) (iter (* x 2) (+ ord 1)) ord)) (iter 1 0)) (define (root-find n ord) (fixed-point-of-transform (lambda (x) (/ n (expt x (- ord 1)))) (repeated average-damp (log2-ceil ord)) 1.0))计算 $n$ 次根号，需要将 average-damp 重复应用 $\\lceil\\log_2n\\rceil$ 次。 Exercise 1.46(define (iterative-improve good-enough? improve initial-guess) (define (iter guess) (let ((next (improve guess))) (if (good-enough? guess next) next (iter next)))) (iter initial-guess)) (define (good-enough? a b) (&lt; (abs (- a b)) 0.00001)) (define (sqrt n) (define (improve x) (/ (+ x (/ n x)) 2.0)) (iterative-improve good-enough? improve 1.0)) (define (fixed-point f guess) (iterative-improve good-enough? f guess))","link":"/SICP/exercises/1-3/"},{"title":"2.1 Introduction to Data Abstraction","text":"Exercise 2.1(define (make-rat n d) (if (negative? d) (cons (- n) (- d)) (cons n d)))Exercise 2.2(define (make-segment p1 p2) (cons p1 p2)) (define (make-point x y) (cons x y)) (define (start-segment s) (car s)) (define (end-segment s) (cdr s)) (define (x-point p) (car p)) (define (y-point p) (cdr p)) (define (midpoint-segment s) (let ((p1 (start-segment s)) (p2 (end-segment s))) (make-point (/ (+ (x-point p1) (x-point p2)) 2) (/ (+ (y-point p1) (y-point p2)) 2))))Exercise 2.3Denote a rectangle with its size (i.e., width and height), and, in consideration for further extensibility, with its origin point and rotation. (define (make-rect width height origin rotation) (cons (make-size width height) (cons origin rotation))) (define (make-size width height) (cons width height)) (define (get-size rect) (car rect)) (define (size-width size) (car size)) (define (size-height size) (cdr size)) (define (perimeter rect) (let ((size (get-size rect))) (* (+ (size-width size) (size-height size)) 2))) (define (area rect) (let ((size (get-size rect))) (* (size-width size) (size-height size))))Exercise 2.4(define (cdr z) (z (lambda (p q) q)))Exercise 2.5(define (factor-out n factor) (define (iter n cnt) (if (= (remainder n factor) 0) (iter (/ n factor) (+ cnt 1)) cnt)) (iter n 0)) (define (cons a b) (* (expt 2 a) (expt 3 b))) (define (car n) (factor-out n 2)) (define (cdr n) (factor-out n 3))Exercise 2.6(define one (lambda (f) (lambda (x) (f x)))) (define two (lambda (f) (lambda (x) (f (f x))))) (define (plus m n) (lambda (f) (lambda (x) ((m f) ((n f) x)))))Exercise 2.7(define (lower-bound intv) (car intv)) (define (upper-bound intv) (cdr intv))Exercise 2.8(define (sub-interval x y) (make-interval (- (lower-bound x) (upper-bound y)) (- (upper-bound x) (lower-bound y))))Exercise 2.9For addition and abstraction of two intervals $I_1$ and $I_2$&hairsp;, the width of the result is a function of the widths of the input, namely $$\\begin{aligned}2\\cdot width&amp;=[H(I_1)+H(I_2)]-[L(I_1)+L(I_2)]\\\\&amp;=[H(I_1)-L(I_1)]+[H(I_2)-L(I_2)]\\\\&amp;=width_1+width_2\\,,\\end{aligned}$$ where $H(I)$ stands for (upper-bound I)&hairsp;, $L(I)$ stands for (lower-bound I)&hairsp;, and $width_1,width_2$ stands for the width of the two intervals, respectively. But the equation above doesn’t hold for a multiplication or a division. Presume that the width of the result was a function of the widths of the inputs, then multiplying different intervals with the same widths should give the same answer. But [4, 14] * [2, 4] = [8, 56] (width = 48); [5, 15] * [1, 3] = [5, 45] (width = 40).Thus, the presumption turns out to be wrong. Exercise 2.10(define (div-interval x y) (if (&lt;= (* (lower-bound y) (upper-bound y)) 0) (error &quot;zero-spanned division error&quot;) (mul-interval x (make-interval (/ 1.0 (upper-bound y)) (/ 1.0 (lower-bound y))))))Exercise 2.11The answer is WAY longer than the original version. Ben is very mean. (define (mul-interval x y) (let ((a (lower-bound x)) (b (upper-bound x)) (c (lower-bound y)) (d (upper-bound y))) (if (&lt; a 0) (if (&lt; b 0) (if (&lt; c 0) (if (&lt; d 0) (make-interval (* b d) (* a c)) (make-interval (* a d) (* a c))) (make-interval (* a d) (* b c))) (if (&lt; c 0) (if (&lt; d 0) (make-interval (* b c) (* a c)) (make-interval (min (* b c) (* a d)) (max (* a c) (* b d)))) (make-interval (* a d) (* b d)))) (if (&lt; c 0) (if (&lt; d 0) (make-interval (* b c) (* a d)) (make-interval (* b c) (* b d))) (make-interval (* a c) (* b d))))))Exercise 2.12(define (make-center-percent c p) (make-center-width c (* c p 0.01))) (define (percent intv) (* (/ (width intv) (center intv)) 100.0))Exercise 2.13The actual percentage tolerance is $$\\frac{w_1w_2(p_1+p_2)}{center}\\,,\\quad\\begin{aligned}&amp;\\text{where $w$ denotes width, $p$ denotes percentage tolerance}\\\\&amp;\\text{and $center$ denotes the center of the product interval.}\\end{aligned}$$ Since the tolerance is small enough to ignore the discrepancy between $center$ and $w_1w_2$&hairsp;, the percentage tolerance is $p_1+p_2$ approximately. Thus, we have (define (prod-percent-approx a b) (+ (percent a) (percent b)))Exercises 2.14 ~ 2.16All three problems point to the difficulty to introduce “identity” to interval arithmetic. Suppose we have two numbers $A$ and $B$&hairsp;, which settles within intervals $I_A=[L_A,H_A]$ and $I_B=[L_B,H_B]$&hairsp;, respectively (assuming that all numbers are positive). Then we’ll have $$\\frac{I_A}{I_B}=\\left[\\frac{L_A}{H_B},\\frac{H_A}{L_B}\\right]$$ under the definition of interval division. But when we try to divide an interval by itself, we’ll get $$\\frac{I_A}{I_A}=\\left[\\frac{L_A}{H_A},\\frac{H_A}{L_A}\\right]$$ which is for most of the time not equal to $[1,1]$ as we might have expected. The above example illustrates that, the re-appearance of an interval in an expression may well introduce uncertainty to the evaluation. This is because, we never know whether two intervals are related to the same number. In other words, intervals don’t have “identity”. Intervals don’t have identity, but real numbers do. I have devised an approach to eliminate these uncertainties. That is, settle the numbers into their corresponding intervals randomly before evaluating the expression. After repeating the “settle-evaluate” loop for say $100,000$ times, we’ll get a decent approximation to the actual interval. My approach is inspired by the Monte Carlo methods, which rely on repeated random sampling to obtain numerical results. The approach may be time-consuming since the evaluation has to be carried out a great many times before the approximation becomes precise enough. But it will always give the right answer. My code written in Python is given below: random-sampling.py1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import randominfty = float('inf')class Interval(object): def __init__(self, lower, upper): self.lower = lower self.upper = upper def settle(self): return random.random() * (self.upper - self.lower) + self.lower @staticmethod def from_center_percent(center, percent): width = center * percent * 0.01 return Interval(center - width, center + width) def __str__(self): return 'Interval(%.3f, %.3f)' % (self.lower, self.upper)def evaluate(func, intervals, precision=100000): lower, upper = infty, -infty for _ in range(precision): val = func(*(i.settle() for i in intervals)) if val &lt; lower: lower = val if val &gt; upper: upper = val return Interval(lower, upper)if __name__ == '__main__': # These two functions accept two arguments, # which are values settled for each loop # within their corresponding interval. def func_1(a, b): return (a * b) / (a + b) def func_2(a, b): return 1.0 / (1.0 / a + 1.0 / b) I = Interval.from_center_percent intervals = [I(100, 5), I(10, 5)] print(evaluate(func_1, intervals)) print(evaluate(func_2, intervals)) We know par2 is the procedure which has its parameters appear only once in its body. So it have no issues with identity. And in the random sampling approach, both func_1 and func_2 evaluate to the same answer, which is equal to the one produced by par2&hairsp;.","link":"/SICP/exercises/2-1/"},{"title":"2.2 Hierarchical Data and the Closure Property","text":"Exercise 2.17(define (last-pair lst) (if (null? (cdr lst)) lst (last-pair (cdr lst))))Exercise 2.18(define (reverse lst) (define (iter lst result) (if (null? lst) result (iter (cdr lst) (cons (car lst) result)))) (iter lst nil))Exercise 2.19(define (no-more? coins) (null? coins)) (define (first-denomination coins) (car coins)) (define (except-first-denomination coins) (cdr coins))The order of denominations doesn’t affect the result. Because both procedures compute all possible combinations. Exercise 2.20(define (same-parity f . r) (define (equiv? a b) (or (and a b) (and (not a) (not b)))) (let ((p (even? f))) (define (choose r) (cond ((null? r) nil) ((equiv? p (even? (car r))) (cons (car r) (choose (cdr r)))) (else (choose (cdr r))))) (cons f (choose r))))Exercise 2.21(define (square-list items) (if (null? items) nil (cons (* (car items) (car items)) (square-list (cdr items))))) (define (square-list items) (map (lambda (x) (* x x)) items))Exercise 2.22The first one will generate a reversed result because the first element of items is attached to the front of answer every iteration; The latter one doesn’t work because it will finally produce a structure like (((((() . 1) . 2) . 3) . 4) . 5)&hairsp;, which is not even a list. Exercise 2.23(define (for-each proc items) (define (iter items) (cond ((not (null? items)) (proc (car items)) (iter (cdr items))))) (iter items))Exercise 2.24The interpreter prints (1 (2 (3 4)))&hairsp;. Exercise 2.25(car (cdr (car (cdr (cdr lst))))) (car (car lst)) (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr lst))))))))))))Exercise 2.26(1 2 3 4 5 6) ((1 2 3) 4 5 6) ((1 2 3) (4 5 6))Exercise 2.27(define (deep-reverse tree) (define (iter tree result) (cond ((null? tree) result) ((pair? tree) (iter (cdr tree) (cons (deep-reverse (car tree)) result))) (else tree))) (iter tree nil))Exercise 2.28I made use of the append procedure defined previously. (define (fringe tree) (cond ((null? tree) nil) ((pair? tree) (append (fringe (car tree)) (fringe (cdr tree)))) (else (list tree))))Exercise 2.29a. (define (left-branch mobile) (car mobile)) (define (right-branch mobile) (car (cdr mobile))) (define (branch-length mobile) (car mobile)) (define (branch-structure mobile) (car (cdr mobile)))b. (define (total-weight object) (if (number? object) object (+ (total-weight (branch-structure (left-branch object))) (total-weight (branch-structure (right-branch object))))))c. (define (torque branch) (* (branch-length branch) (total-weight (branch-structure branch)))) (define (balanced? object) (or (number? object) (and (= (torque (left-branch object)) (torque (right-branch object))) (balanced? (branch-structure (left-branch object))) (balanced? (branch-structure (right-branch object))))))d. (define (left-branch mobile) (car mobile)) (define (right-branch mobile) (cdr mobile)) (define (branch-length mobile) (car mobile)) (define (branch-structure mobile) (cdr mobile))Only four procedures have to be changed. That’s the convenience abstraction barriers bring to us. Exercise 2.30(define (square-tree tree) (cond ((null? tree) nil) ((pair? tree) (cons (square-tree (car tree)) (square-tree (cdr tree)))) (else (* tree tree))))Exercise 2.31(define (tree-map proc tree) (cond ((null? tree) nil) ((pair? tree) (cons (tree-map proc (car tree)) (tree-map proc (cdr tree)))) (else (proc tree))))Another solution uses map&hairsp;: (define (tree-map proc tree) (map (lambda (subtree) (cond ((null? subtree) nil) ((pair? subtree) (tree-map proc subtree)) (else (proc subtree)))) tree))Exercise 2.32(define (subset s) (if (null? s) (list nil) (let ((rest (subset (cdr s)))) (append rest (map (lambda (lst) (cons (car s) lst)) rest)))))Initially I wrongly wrote nil instead of (list nil)&hairsp;, which always generates an empty list. It works, because the set of all subsets is a union of: The set of all subsets excluding the first number; The set of all subsets excluding the first number that has the first number re-inserted into each subset. Exercise 2.33(define (map proc seq) (accumulate (lambda (x y) (cons (proc x) y)) nil seq)) (define (append seq1 seq2) (accumulate cons seq2 seq1)) (define (length seq) (accumulate (lambda (x y) (+ y 1)) 0 seq))Exercise 2.34(define (horner-eval x coefficient-sequence) (accumulate (lambda (this-coeff higher-terms) (+ (* higher-terms x) this-coeff)) 0 coefficient-sequence))Exercise 2.35(define (count-leaves tree) (accumulate (lambda (x y) (+ (cond ((null? x) 0) ((pair? x) (count-leaves x)) (else 1)) y)) 0 tree))Exercise 2.36(define (accumulate-n op init seqs) (if (null? (car seqs)) nil (cons (accumulate op init (map car seqs)) (accumulate-n op init (map cdr seqs)))))Another version uses a separately defined transpose procedure: (define (transpose seqs) (if (null? (car seqs)) nil (cons (map car seqs) (transpose (map cdr seqs))))) (define (accumulate-n op init seqs) (map (lambda (x) (accumulate op init x)) (transpose seqs)))Exercise 2.37(define (matrix-*-vector m v) (map (lambda (x) (dot-product x v)) m)) (define (transpose mat) (if (null? (car mat)) nil (cons (map car mat) (transpose (map cdr mat))))) (define (matrix-*-matrix m n) (let ((cols (transpose n))) (map (lambda (x) (matrix-*-vector cols x)) m)))Exercise 2.383/2 1/6 (1 (2 (3 ()))) (((() 1) 2) 3)op should have commutativity and associativity simultaneously: Commutativity alone is not enough, such as $x\\;{\\rm op}\\;y=x^2+y^2$&hairsp;; Associativity alone is not enough, such as matrix multiplications. Exercise 2.39(define (reverse seq) (fold-right (lambda (x y) (append y (list x))) nil seq)) (define (reverse seq) (fold-left (lambda (x y) (cons y x)) nil seq))Exercise 2.40(define (unique-pairs n) (flatmap (lambda (i) (map (lambda (j) (list i j)) (enumerate-interval 1 (- i 1)))) (enumerate-interval 1 n))) (define (prime-sum-pairs n) (map make-pair-sum (filter prime-sum? (unique-pairs n))))Exercise 2.41(define (make-triples n s) (define (eligible? triple) (and (&lt; (cadr triple) (caddr triple)) (&lt;= (caddr triple) n))) (filter eligible? (flatmap (lambda (i) (map (lambda (j) (list j i (- s i j))) (enumerate-interval 1 (- i 1)))) (enumerate-interval 2 n))))Exercise 2.42(define empty-board nil) (define (adjoin-position new-row k rest-of-queens) (append rest-of-queens (list (list new-row k)))) (define (safe? k positions) (define (row-of pos) (car pos)) (define (col-of pos) (cadr pos)) (let ((new-queen (car (filter (lambda (pos) (= (col-of pos) k)) positions))) (rest-of-queens (filter (lambda (pos) (not (= (col-of pos) k))) positions))) (define (examine unexamined-queens) (cond ((null? unexamined-queens) #t) ((let ((x1 (row-of (car unexamined-queens))) (y1 (col-of (car unexamined-queens))) (x2 (row-of new-queen)) (y2 (col-of new-queen))) (or (= (+ x1 y1) (+ x2 y2)) (= (+ x1 y2) (+ x2 y1)) (= x1 x2) (= y1 y2))) #f) (else (examine (cdr unexamined-queens))))) (examine rest-of-queens))) (define (queens board-size) (define (queen-cols k) (if (= k 0) (list empty-board) (filter (lambda (positions) (safe? k positions)) (flatmap (lambda (rest-of-queens) (map (lambda (new-row) (adjoin-position new-row k rest-of-queens)) (enumerate-interval 1 board-size))) (queen-cols (- k 1)))))) (queen-cols board-size))I also wrote a more abstract version that defines (define (two-queens-safe? q1 q2) (let ((x1 (row-of q1)) (y1 (col-of q1)) (x2 (row-of q2)) (y2 (col-of q2))) (not (or (= (+ x1 y1) (+ x2 y2)) (= (+ x1 y2) (+ x2 y1)) (= x1 x2) (= y1 y2)))))to check whether two queens are safe with respect to each other. And uses (accumulate (lambda (another-queen result) (and (two-queens-safe? new-queen another-queen) result)) #t rest-of-queens)to replace the original examine procedure. I gave it up thinking that it would sacrifice the readability of my program. But this level of abstraction provides a fundamental basis for the algorithm analyses in Exercise 2.43. Exercise 2.43Exchanging the order of the mapping causes (queen-cols (- k 1)) to be invoked for every element in (enumerate-interval 1 board-size)&hairsp;. Let’s say that $A_{k,n}$ is the number of all ways to place queens in the first $k$ columns of an $n\\times n$ board. For the $8\\times8$ case, we have $$\\begin{array}{r|ccccccccc}k&amp;0&amp;1&amp;2&amp;3&amp;4&amp;5&amp;6&amp;7&amp;8\\\\A_{k,8}&amp;1&amp;8&amp;42&amp;140&amp;344&amp;568&amp;550&amp;312&amp;92\\end{array}$$ Since that two-queens-safe? defined in Exercise 2.42 takes a constant time to determine whether two queens are safe with respect to each other, we stipulate that it is the primitive operation. Let’s say $B_{k,n}$ is the number of times two-queens-safe? to be invoked when calling (queen-cols k) of the original algorithm on an $n\\times n$ board. We have the recurrence $$B_{k,n}=\\begin{cases}0\\,,&amp;\\text{if $k=0$}\\,;\\\\n(k-1)A_{k-1,n}+B_{k-1,n}\\,,&amp;\\text{if $k&gt;0$}\\,.\\end{cases}$$ In the recurrence above, multiply $A_{k-1,n}$ by $n(k-1)$ means we have to attach $n$ possible new queens to each of ways to place previous queens, and filter each of them, during which the new queen has to be examined with the other $k-1$ queens. In the original algorithm, $B_{8,8}=81696$&hairsp;. Exchanging the order of mapping causes (queen-cols (- k 1)) to be invoked $n$ times instead of once, the recurrence is simply $$B^\\prime_{k,n}=\\begin{cases}0\\,,&amp;\\text{if $k=0$}\\,;\\\\n(k-1)A_{k-1,n}+nB^\\prime_{k-1,n}\\,,&amp;\\text{if $k&gt;0$}\\,.\\end{cases}$$ In Louis’ algorithm, $B^\\prime_{8,8}=59878720$&hairsp;, about $733\\cdot B_{8,8}$&hairsp;. So the required time is about $733T$&hairsp;. Exercise 2.44(define (up-split painter n) (if (= n 0) painter (let ((smaller (up-split painter (- n 1)))) (below painter (beside smaller smaller)))))Exercise 2.45(define (split proc1 proc2) (define (impl painter n) (if (= n 0) painter (let ((smaller (impl painter (- n 1)))) (proc1 painter (proc2 smaller smaller))))) impl)Exercise 2.46(define (make-vect xcor ycor) (list xcor ycor)) (define (xcor-vect vect) (car vect)) (define (ycor-vect vect) (cadr vect)) (define (add-vect vect1 vect2) (make-vect (+ (xcor-vect vect1) (xcor-vect vect2)) (+ (ycor-vect vect1) (ycor-vect vect2)))) (define (sub-vect vect1 vect2) (make-vect (- (xcor-vect vect1) (xcor-vect vect2)) (- (ycor-vect vect1) (ycor-vect vect2)))) (define (scale-vect factor vect) (make-vect (* (xcor-vect vect) factor) (* (ycor-vect vect) factor)))Exercise 2.47(define (make-frame origin edge1 edge2) (list origin edge1 edge2)) (define (origin-frame frame) (car frame)) (define (edge1-frame frame) (cadr frame)) (define (edge2-frame frame) (caddr frame))or (define (make-frame origin edge1 edge2) (cons origin (cons edge1 edge2))) (define (origin-frame frame) (car frame)) (define (edge1-frame frame) (cadr frame)) (define (edge2-frame frame) (cddr frame))Exercise 2.48(define (make-segment start end) (cons start end)) (define (start-segment segment) (car segment)) (define (end-segment segment) (cdr segment))Exercise 2.49a. (define outline (segments-&gt;painter (list (make-segment (make-vect 0.0 0.0) (make-vect 0.0 1.0)) (make-segment (make-vect 0.0 1.0) (make-vect 1.0 1.0)) (make-segment (make-vect 1.0 1.0) (make-vect 1.0 0.0)) (make-segment (make-vect 1.0 0.0) (make-vect 0.0 0.0)))))b. (define cross (segments-&gt;painter (list (make-segment (make-vect 0.0 0.0) (make-vect 1.0 1.0)) (make-segment (make-vect 0.0 1.0) (make-vect 1.0 0.0)))))c. (define diamond (segments-&gt;painter (list (make-segment (make-vect 0.5 0.0) (make-vect 1.0 0.5)) (make-segment (make-vect 1.0 0.5) (make-vect 0.5 1.0)) (make-segment (make-vect 0.5 1.0) (make-vect 0.0 0.5)) (make-segment (make-vect 0.0 0.5) (make-vect 0.5 0.0)))))d. Too many line segments to draw, I’m skipping this. Exercise 2.50(define (flip-horiz painter) (transform-painter painter (make-vect 0.0 1.0) (make-vect 1.0 1.0) (make-vect 0.0 0.0))) (define (rotate180 painter) (transform-painter painter (make-vect 1.0 1.0) (make-vect 0.0 1.0) (make-vect 1.0 0.0))) (define (rotate270 painter) (transform-painter painter (make-vect 0.0 1.0) (make-vect 0.0 0.0) (make-vect 1.0 1.0)))Exercise 2.51(define (below painter1 painter2) (let ((split-point (make-vect 0.0 0.5))) (let ((paint-bottom (transform-painter painter1 (make-vect 0.0 0.0) (make-vect 1.0 0.0) split-point)) (paint-top (transform-painter painter2 split-point (make-vect 1.0 0.5) (make-vect 0.0 1.0)))) (lambda (frame) (paint-bottom frame) (paint-top frame)))))or (define (below painter1 painter2) (rotate270 (beside (rotate90 painter2) (rotate90 painter1))))Exercise 2.52a. (define (add-segments segment-list painter) (lambda (frame) ((segments-&gt;painter segment-list) frame) (painter frame))) (define smiley-wave (add-segments (list &lt;smiley segments&gt;) wave))b. (define (corner-split painter n) (if (= n 0) painter (let ((up-smaller (up-split painter (- n 1)))) (below (right-split painter n) (beside up-smaller (corner-split painter (- n 1)))))))c. Made Mr. Rogers look outward. (define (compose . procs) (lambda (x) (define (impl procs) (if (null? procs) x ((car procs) (impl (cdr procs))))) (impl procs))) (define (square-limit painter n) (define (corner-split-n painter) (corner-split painter n)) ((square-of-four (compose flip-horiz corner-split-n flip-horiz) (compose corner-split-n flip-horiz) (compose flip-horiz flip-vert corner-split-n flip-horiz) (compose flip-vert corner-split-n flip-horiz)) painter))","link":"/SICP/exercises/2-2/"},{"title":"2.3 Symbolic Data","text":"Exercise 2.53(list &apos;a &apos;b &apos;c) -&gt; (a b c) (list (list &apos;george)) -&gt; ((george)) (cdr &apos;((x1 x2) (y1 y2))) -&gt; ((y1 y2)) (cadr &apos;((x1 x2) (y1 y2))) -&gt; (y1 y2) (pair? (car &apos;(a short list))) -&gt; #f (memq &apos;red &apos;((red shoes) (blue socks))) -&gt; #f (memq &apos;red &apos;(red shoes blue socks)) -&gt; (red shoes blue socks)Exercise 2.54(define (equal? a b) (cond ((and (pair? a) (pair? b)) (and (equal? (car a) (car b)) (equal? (cdr a) (cdr b)))) ((not (or (pair? a) (pair? b))) (eq? a b)) (else #f)))Exercise 2.55''abracadabra is an abbreviation of (list 'quote 'abracadabra)&hairsp;; its first element is 'quote&hairsp;. Exercise 2.56(define (exponentiation? e) (and (pair? e) (eq? (car e) &apos;**))) (define (base e) (cadr e)) (define (exponent e) (caddr e)) (define (make-exponentiation base exponent) (cond ((=number? exponent 0) 1) ((=number? exponent 1) base) ((and (number? base) (number? exponent)) (expt base exponent)) (else (list &apos;** base exponent)))) (define (deriv exp var) (cond ((number? exp) 0) ((variable? exp) (if (same-variable? exp var) 1 0)) ((sum? exp) (make-sum (deriv (addend exp) var) (deriv (augend exp) var))) ((product? exp) (make-sum (make-product (multiplier exp) (deriv (multiplicand exp) var)) (make-product (deriv (multiplier exp) var) (multiplicand exp)))) ((exponentiation? exp) (make-product (exponent exp) (make-product (make-exponentiation (base exp) (make-sum (exponent exp) -1)) (deriv (base exp) var)))) (else (error &quot;unknown expression type -- DERIV&quot; exp))))Exercise 2.57(define (augend e) (let ((rem (cddr e))) (if (null? (cdr rem)) (car rem) (cons &apos;+ rem)))) (define (multiplicand e) (let ((rem (cddr e))) (if (null? (cdr rem)) (car rem) (cons &apos;* rem))))Exercise 2.58a. (define (sum? e) (and (pair? e) (eq? (cadr e) &apos;+))) (define (addend e) (car e)) (define (augend e) (caddr e)) (define (make-sum a1 a2) (cond ((=number? a1 0) a2) ((=number? a2 0) a1) ((and (number? a1) (number? a2)) (+ a1 a2)) ((equal? a1 a2) (make-product a1 2)) (else (list a1 &apos;+ a2)))) (define (product? e) (and (pair? e) (eq? (cadr e) &apos;*))) (define (multiplier e) (car e)) (define (multiplicand e) (caddr e)) (define (make-product m1 m2) (cond ((or (=number? m1 0) (=number? m2 0)) 0) ((=number? m1 1) m2) ((=number? m2 1) m1) ((and (number? m1) (number? m2)) (* m1 m2)) (else (list m1 &apos;* m2))))b. A simple solution works under the assumption that the expression contains only additions and multiplications. An expression is a sum if it contains any '+ in its topmost “layer” , otherwise, a product. (define (sum? e) (and (pair? e) (not (null? (cdr e))) (or (eq? (cadr e) &apos;+) (sum? (cddr e))))) (define (addend e) (if (eq? (cadr e) &apos;+) (car e) (cons (car e) (cons (cadr e) (let ((rem (addend (cddr e)))) (if (pair? rem) rem (list rem))))))) (define (augend e) (let ((rem (cddr e))) (if (eq? (cadr e) &apos;+) (if (null? (cdr rem)) (car rem) rem) (augend rem)))) (define (make-sum a1 a2) (cond ((=number? a1 0) a2) ((=number? a2 0) a1) ((and (number? a1) (number? a2)) (+ a1 a2)) (else (append (if (pair? a1) a1 (list a1)) (if (pair? a2) (cons &apos;+ a2) (list &apos;+ a2)))))) (define (product? e) (not (sum? e))) (define (multiplier e) (car e)) (define (multiplicand e) (let ((rem (cddr e))) (if (null? (cdr rem)) (car rem) rem))) (define (make-product m1 m2) (cond ((or (=number? m1 0) (=number? m2 0)) 0) ((=number? m1 1) m2) ((=number? m2 1) m1) ((and (number? m1) (number? m2)) (* m1 m2)) (else (list m1 &apos;* m2))))Exercise 2.59(define (union-set set1 set2) (cond ((null? set1) set2) ((element-of-set? (car set1) set2) (union-set (cdr set1) set2)) (else (adjoin-set (car set1) (union-set (cdr set1) set2)))))Exercise 2.60adjoin-set was changed to allow duplicates. adjoin-set is sufficiently more efficient, it has a time complexity of $\\Theta(1)$ compared to the original $\\Theta(n)$&hairsp;. The set allowing duplicates is suitable for situations that require frequent adjoin operations. (define (element-of-set? x set) (if (null? set) #f (or (equal? x (car set)) (element-of-set? x (cdr set))))) (define (adjoin-set x set) (cons x set)) (define (intersection-set set1 set2) (cond ((null? set1) &apos;()) ((element-of-set? (car set1) set2) (cons (car set1) (intersection-set (cdr set1) set2))) (else (intersection-set (cdr set1) set2)))) (define (union-set set1 set2) (cond ((null? set1) set2) ((element-of-set? (car set1) set2) (union-set (cdr set1) set2)) (else (adjoin-set (car set1) (union-set (cdr set1) set2)))))Exercise 2.61Both version have the time complexity of $\\Theta(n)$&hairsp;, but the ordered version has to examine on the average half of the set instead of the entire set. (define (adjoin-set x set) (cond ((null? set) (list x)) ((= x (car set)) set) ((&lt; x (car set)) (cons x set)) (else (cons (car set) (adjoin-set x (cdr set))))))Exercise 2.62(define (union-set set1 set2) (cond ((null? set1) set2) ((null? set2) set1) ((= (car set1) (car set2)) (cons (car set1) (union-set (cdr set1) (cdr set2)))) ((&lt; (car set1) (car set2)) (cons (car set1) (union-set (cdr set1) set2))) (else (cons (car set2) (union-set set1 (cdr set2))))))Exercise 2.63a. Trees in Figure 2.16 can be represented as (define tree1 &apos;(7 (3 (1 () ()) (5 () ())) (9 () (11 () ())))) (define tree2 &apos;(3 (1 () ()) (7 (5 () ()) (9 () (11 () ()))))) (define tree3 &apos;(5 (3 (1 () ()) ()) (9 (7 () ()) (11 () ()))))Both procedures evaluate to the same list (1 3 5 7 9 11)&hairsp;. b. tree-&gt;list2 grows slower. For tree-&gt;list1&hairsp;, $$T(n)=2\\cdot T(n/2)+\\Theta(n)\\,,$$ where $\\Theta(n)$ means that append takes linear time to combime two lists; and the recurrence has the solution $T(n)\\sim\\Theta(n\\log n)$&hairsp;. For tree-&gt;list2&hairsp;, $$T(n)=2\\cdot T(n/2)+\\Theta(1)\\,,$$ since it uses a single cons to combine the results; and the recurrence has the solution $T(n)\\sim\\Theta(n)$&hairsp;. Actually, I looked up the solutions to the recurrences, since I’m not able to solve such equations at present. I will come back to explain them once I finished reading related topics in Concrete Mathematics. Exercise 2.64a. The generated tree looks like 5 / \\ 1 9 \\ / \\ 3 7 11The partial-tree procedure split the list into three parts and combine them into a tree. For example, the list (1 3 5 7 9 11) would be split into parts: list (1 3) of the length left-size&hairsp;, which is used to generate the left-tree&hairsp;; 5 as this-entry&hairsp;, the entry of the generated tree; list (7 9 11) of the length right-size&hairsp;, which is used to generate the right-tree&hairsp;. Then the parts would be combined like (this-entry left-tree right-tree)&hairsp;. b. Suppose we’re going to convert a list of length $n$ into a tree. The list-&gt;tree procedure depends on (partial-tree &lt;list&gt; n)&hairsp;, which generates two partial-tree of the lengths of about half of $n$&hairsp;, and combine them into a tree. The combining step uses list which requires a constant time. Then we have the recurrence $$T(n)=2\\cdot T(n/2)+\\Theta(1)\\,,$$ which has the solution $T(n)\\sim\\Theta(n)$&hairsp;. Exercise 2.65Implemented using previously defined procedures. union-set-as-list is the original union-set&hairsp;; intersection-set-as-list is the original intersection-set&hairsp;. (define (union-set set1 set2) (let ((list1 (tree-&gt;list set1)) (list2 (tree-&gt;list set2))) (list-&gt;tree (union-set-as-list list1 list2)))) (define (intersection-set set1 set2) (let ((list1 (tree-&gt;list set1)) (list2 (tree-&gt;list set2))) (list-&gt;tree (intersection-set-as-list list1 list2))))Exercise 2.66(define (lookup given-key set-of-records) (cond ((null? set-of-records) #f) ((equal? given-key (key (entry set-of-records))) (entry set-of-records)) ((&lt; given-key (key (entry set-of-records))) (lookup x (left-branch set-of-records))) ((&gt; given-key (key (entry set-of-records))) (lookup x (right-branch set-of-records)))))Exercise 2.67The result is (A D A B B C A)&hairsp;. Exercise 2.68(define (encode-symbol symbol tree) (if (leaf? tree) &apos;() (cond ((element-of-set? symbol (symbols (left-branch tree))) (cons 0 (encode-symbol symbol (left-branch tree)))) ((element-of-set? symbol (symbols (right-branch tree))) (cons 1 (encode-symbol symbol (right-branch tree)))) (else (error &quot;bad symbol: ENCODE-SYMBOL&quot; symbol)))))At first, I wrote a procedure with a helper procedure encode-1 instead of encode-symbol (because I carelessly skipped reading the latter part of the requirements), which is analogous to the decode sample code in the book. This version is faster than a procedure making use of append&hairsp;, since append takes linear time to combine the results instead of constant time. (define (encode message tree) (define (symbol-&gt;next-bit symbol tree) (cond ((element-of-set? symbol (symbols (left-branch tree))) 0) ((element-of-set? symbol (symbols (right-branch tree))) 1) (else (error &quot;bad symbol: SYMBOL-&gt;NEXTBIT&quot; symbol)))) (define (encode-1 symbols current-branch) (if (null? symbols) &apos;() (let ((next-bit (symbol-&gt;next-bit (car symbols) current-branch))) (let ((next-branch (choose-branch next-bit current-branch))) (cons next-bit (if (leaf? next-branch) (encode-1 (cdr symbols) tree) (encode-1 symbols next-branch))))))) (encode-1 message tree))Exercise 2.69(define (successive-merge set) (if (null? (cdr set)) (car set) (successive-merge (adjoin-set (make-code-tree (car set) (cadr set)) (cddr set)))))Exercise 2.70$84$ bits are needed using Huffman encoding method; $108$ bits are needed using fixed-length code. Exercise 2.71Such trees look like /\\ /\\ 2^(n-1) /\\ 2^(n-2) /\\ ... 1 2The most frequent symbol requires one bit to represent; and the least frequent symbols require $n-1$ bits to represent. Exercise 2.72Encoding the most frequent symbol, we have to search through the entire symbol list once, which takes linear time. Thus $$T(n)\\sim\\Theta(n)\\,.$$ Encoding a least frequent symbol, we have to search through a list containing $n$ symbols, then a list containing $n-1$ symbols, then a list containing $n-2$ symbols, till we reach the bottom of the tree. Thus $$T(n)\\sim\\Theta(n^2)\\,.$$","link":"/SICP/exercises/2-3/"},{"title":"2.4 Multiple Representations for Abstract Data","text":"Exercise 2.73DrRacket as my interpreter, I added a few lines in the front to “implement” put and get&hairsp;, based on the built-in hash table structure. #lang racket (define *the-table* (make-hash)) (define (put key1 key2 value) (hash-set! *the-table* (list key1 key2) value)) (define (get key1 key2) (hash-ref *the-table* (list key1 key2) #f))a. That’s because numbers and variables are not tagged data. b. (define (install-linear-package) (define (make-sum exp1 exp2) (cond ((=number? exp1 0) exp2) ((=number? exp2 0) exp1) ((and (number? exp1) (number? exp2)) (+ exp1 exp2)) (else (list &apos;+ exp1 exp2)))) (define (make-product exp1 exp2) (cond ((=number? exp1 1) exp2) ((=number? exp2 1) exp1) ((and (number? exp1) (number? exp2)) (* exp1 exp2)) (else (list &apos;* exp1 exp2)))) (define (deriv-addition operands var) (let ((addend (car operands)) (augend (cadr operands))) (make-sum (deriv addend var) (deriv augend var)))) (define (deriv-multiplication operands var) (let ((multiplier (car operands)) (multiplicand (cadr operands))) (make-sum (make-product multiplier (deriv multiplicand var)) (make-product (deriv multiplier var) multiplicand)))) (put &apos;make &apos;+ make-sum) (put &apos;make &apos;* make-product) (put &apos;deriv &apos;+ deriv-addition) (put &apos;deriv &apos;* deriv-multiplication) &apos;done) (define (=number? exp num) (and (number? exp) (= exp num))) (define (variable? exp) (symbol? exp)) (define (same-variable? var1 var2) (and (variable? var1) (variable? var2) (eq? var1 var2))) (define (operator exp) (car exp)) (define (operands exp) (cdr exp)) (define (deriv exp var) (cond ((number? exp) 0) ((variable? exp) (if (same-variable? exp var) 1 0)) (else (let ((proc (get &apos;deriv (operator exp)))) (if proc (proc (operands exp) var) (error &quot;invalid operator -- DERIV&quot; exp)))))) (install-linear-package)c. (define (install-exponentiation-package) (define make-sum (get &apos;make &apos;+)) (define make-product (get &apos;make &apos;*)) (define (make-exponentiation exp1 exp2) (cond ((and (not (=number? exp1 0)) (=number? exp2 0)) 1) ((=number? exp2 1) exp1) (else (list &apos;** exp1 exp2)))) (define (deriv-exponentiation operands var) (let ((base (car operands)) (ex (cadr operands))) (make-product ex (make-exponentiation base (make-sum ex -1))))) (put &apos;make &apos;** make-exponentiation) (put &apos;deriv &apos;** deriv-exponentiation) &apos;done) (install-exponentiation-package)d. Arguments in every put call need to be reordered. Exercise 2.74Every company should provide their file in tagged-data form. Headquarters should implement (define (division file) ...) (define (records file) ...)to extract from the file its belonging division and the actual records it contains. a. (define (get-record employee file) ((get &apos;employee-records-&gt;record (division file)) employee (records file)))b. (define (get-salary employee file) (let ((record (get-record employee file))) ((get &apos;record-&gt;salary (division file)) record)))c. (define (find-employee-record employee files) (if (null? files) #f ((let ((record (get-record employee (car files)))) (if record record (find-employee-record employee (cdr files)))))))d. The new company should provide a package that includes employee-records-&gt;record and record-&gt;salary implementation. Exercise 2.75(define (make-from-mag-ang r a) (define (dispatch op) (cond ((eq? op &apos;real-part) (* r (cos a))) ((eq? op &apos;imag-part) (* r (sin a))) ((eq? op &apos;magnitude) r) ((eq? op &apos;angle) a) (else (error &quot;invalid operation -- MAKE-FROM-MAG-ANG&quot; op)))) dispatch)Exercise 2.76For generic operations with explicit dispatch, when you add a new type, you have to edit every existing operation; when you add a new operation, you have to create an operation that takes account of all types. This style is appropriate for a system in which new operations must often be added. For message-passing, when you add a new type, you have to create a new “operation dispatcher” that does all operations; when you add a new operation, you have to edit every existing “operation dispatcher”. This style is appropriate for a system in which new types must often be added. I placed data-directed style at last, because it actually eliminates the deficiencies above. In this style, operations are organized in a table. To add a new type, you can fill out a new column in the table, that is, create a package for that type, as what we’ve done in the book. To add a new operation, you can fill out a new row in the table, that is, create a package for that operation. Everything is additive no matter whether you’re adding a new type or a new operation.","link":"/SICP/exercises/2-4/"},{"title":"2.5 Systems with Generic Operations","text":"Exercise 2.","link":"/SICP/exercises/2-5/"},{"title":"第一章 构造抽象过程","text":"1.1 程序设计的基本元素 为了让我们能通过程序语言组织自己有关计算过程的思想，每一种强有力的语言都提供了三种机制，使我们能够将简单的认识组合起来形成更复杂的认识： 基本表达式，指语言中最基本的实体 组合的方法，通过它们可以用简单元素构成复合元素 抽象的方法，通过它们可以给复合元素命名，并将其视为单元操作 组合式求值有以下步骤： 对组合式的各个子表达式求值 将运算符的值应用于其它子表达式的值 对子表达式求值时也必须遵循这样的步骤，这意味着求值步骤本身就是递归的。 define 是我们给值命名的方式，也是最简单的抽象方式，形如 (define x 3)&hairsp;。这样做会导致名字 x 与值 3 相关联。将名字与值相关联，又能根据名字提取出值，解释器需要存储空间来维护名字-值关联，这存储空间被称为环境。 过程定义形如 (define (&lt;name&gt; &lt;formal parameters&gt;) &lt;body&gt;)，将用对应的实际参数替换形式参数，再求值的这一过程，在环境中绑定给一个名字，便于以后的调用。 应用序求值与正则序求值是表达式求值的两种方式。应用序求值时，解释器首先对运算符和各个对象求值，之后将得到的过程应用于得到的实际参数。而正则序求值时，先不求出运算对象的值，直到需要它们时再去求。 应用序，概括为 “先求值而后应用” 正则序，概括为 “完全展开后规约” Lisp 采用应用序求值，部分原因在于这样做能避免对于表达式的重复求值，从而可以提高一些效率。更重要的是，在超出了可以采用代换方式模拟过程的范围后，正则序的处理将变得复杂得多。 条件表达式和谓词，形如 (cond (&lt;p1&gt; &lt;e1&gt;) (&lt;p2&gt; &lt;e2&gt;) ... (&lt;pn&gt; &lt;en&gt;)) (if &lt;predicate&gt; &lt;consequent&gt; &lt;alternative&gt;)cond 之后跟随着形如 (&lt;p&gt; &lt;e&gt;) 的表达式，称为从句。从句中的 &lt;p&gt; 是谓词，与结果表达式 &lt;e&gt; 相对应。整个 cond 表达式的值是从左到右第一个谓词为真的从句的结果表达式，其中 else 是一个永远为真的谓词。 要对一个 if 表达式求值，首先对 &lt;predicate&gt; 求值。如果其为真，求出 &lt;consequent&gt; 的值，否则求出 &lt;alternative&gt; 的值作为整个 if 表达式的值。 由于 cond 和 if 不一定对其所有子表达式求值，它们不是一般的过程，而是特殊形式。 形式参数叫什么名字，其实无所谓，这样的名字称为约束变量。如果一个变量不是被约束的，我们就称它为自由的。名字在其中被约束的表达式的集合称为名字的作用域。约束变量在将其作为形式参数的过程中的作用域是这个过程的过程体。 词法作用域是作用域的一种工作模型。内层过程中的自由变量，实际上是外围过程定义中的约束变量。 嵌套定义的过程，称为块结构。块结构的好处是，可以省去将某些变量在内层过程中传递的过程。 1.2 过程与它们所产生的计算 能够遇见所作所为的后果，是一种很重要的能力。 过程规定了计算状态如何从之前的计算状态演变而来。计算的具体行为很难捉摸，但我们可以找到演变的一般模式。从全局的角度判断计算状态的演变方式，这就是这一节所需要学习的内容。 递归过程与递归计算是不同的概念：递归过程是指一个过程的定义中，包含了引用自身的表达式。而递归计算，指的是递归实际的演变方式。 线性递归与线性迭代是计算的两种演变方式： 线性递归：计算过程中不断展开表达式，随之构建起一条延迟操作的链，并在这些运算实际进行时收缩。当需要保存的信息量（正如延迟操作的步数）与问题规模的增长成正比时，称为线性递归。 线性迭代：没有增长和收缩过程，需要保存的信息是一定数量的状态变量，并且用一套规则来指定状态变量的更新方式。当计算步数与问题规模的增长成正比时，称为线性迭代。 迭代过程中，状态变量完全描述了当前的状态，只要提供这些状态变量，计算就能随时进行下去；而递归过程就不同了，递归过程中记录了变量以外的额外信息，用于告诉解释器 “我们在延迟操作链上的什么位置”。 树形递归是指递归过程中多次引用自身，使 “延迟操作链” 分叉为树形结构。树形递归往往需要极多运算资源，但它不是无用的。处理有层级结构的数据时，树形递归是个自然而强大的工具；处理数字时，树形递归方式更容易理解。 对于树形递归的计算过程中的每一个节点，只需保存树中在其之上的节点的信息。一般来说，树形递归的计算所需的步骤数正比于树中的节点数，所需空间正比于树的最大深度。 （练习 3.27 介绍了如何用表格优化树形递归，先挖个坑） 增长阶为计算所需要的资源量，提供了粗略的估计。设 ${\\rm R}(n)$ 为问题规模为 $n$ 时所需的计算资源量。当 $$\\exists k_1,k_2,N\\;\\forall n&gt;N\\,(k_1f(n)\\leq{\\rm R}(n)\\leq k_2f(n))$$ 成立时，我们称 ${\\rm R}(n)$ 有 $\\Theta(f(n))$ 的增长阶，记作 ${\\rm R}(n)\\sim\\Theta(f(n))$&hairsp;。 Lamé定理：如果用欧几里德算法计算一对数的 GCD 需要执行 $k$ 步，那么更小的那个数一定不小于第 $k$ 个斐波那契数。 运用这个定理，可以很方便地分析欧几里德算法的增长阶。设更小的数为 $n$，则一定有 $n\\geq{\\rm Fib}(k)\\approx\\frac{\\phi^k}{\\sqrt5}$&hairsp;。从此可以看出，$k$ 正比于 $\\log_\\phi(n)$ 增长，所以欧几里德算法的增长阶为 $\\Theta(\\log n)$&hairsp;。 费马小定理：若 $n$ 是素数，则对于任意 $a$ 不是 $n$ 的倍数，都有 $a^n\\equiv a\\;({\\rm mod}\\;n)$，它的另一个形式是 $a^{n-1}\\equiv1\\;({\\rm mod}\\;n)$，在$\\text{Miller–Rabin}$素性测试中得以应用。 1.3 用高阶函数做抽象 为了增加描述能力，一门强大的语言需要：将共有的模式命名并建立抽象，而后直接在抽象的层次上工作。 这就需要引入高阶过程，它们以过程为参数，或者以过程为返回值。 将过程作为参数，或者将过程作为其值，以便用过程来处理过程，这样的过程称作高阶过程。 匿名过程形如 (lambda (&lt;formal-parameters&gt;) &lt;body&gt;)&hairsp;。lambda 像 define 一样创造过程，但是不为它们绑定名称。 局部变量使用以下语法进行绑定，它们的作用域是 &lt;body&gt; 部分： (let ((&lt;var1&gt; &lt;exp1&gt;) (&lt;var2&gt; &lt;exp2&gt;) ... (&lt;varn&gt; &lt;expn&gt;)) &lt;body&gt;)let 也是一种特殊形式，和调用过程时，将表达式的值绑定给形式参数的原理一样，它并没有引入新的机制。 “$\\mapsto$” 这个符号叫做映射&hairsp;$($$\\textit{maps to}$$)$，是 lambda 在数学中的表达。例如 $y\\mapsto x/y$ 可以被表达为 (lambda (y) (/ x y))&hairsp;。 一般来说，程序语言会对计算元素的可操作方式作出限制。而带有最少限制的元素被称为拥有第一级状态，这些元素有这些特点： 可以被绑定给一个变量 可以作为参数传递给一个过程 可以被一个过程作为返回值 可以存储在数据结构中 Lisp 语言为过程赋予了完全的第一级状态，由此获得的描述能力是惊人的。 这样做是有代价的，也为解释器的实现提出了挑战：实现第一级状态的过程需要为过程中的自由变量预留存储空间，即使某个过程并没有被调用。","link":"/SICP/notes/1/"},{"title":"Chapter 2 Building Abstractions with Data","text":"2.1 Introduction to Data Abstraction Similar to procedural abstraction, data abstraction is a methodology that enables us to isolate how a compound data object is used from the details of how it is constructed from more primitive data objects. Selectors and constructors are sets of procedures used as the interface between the construction of data and the use of data, through which programs are as if operating on “abstract data”. A pair is a compound structure, whose behavior could be specified as (car (cons a b)) -&gt; a (cdr (cons a b)) -&gt; b Abstraction barriers isolate different “levels” of the system. Identify for each of type of data object a set of operations, and use only those operations in manipulating data objects. 2.2 Hierarchical Data and the Closure Property The ability to create pairs whose elements are pairs is the essence of list structure which benefits from the closure property of cons&hairsp;. Closure is the key to power in any means of combination because it permits us to create hierarchical structures — structures made up of parts, which themselves are made up of parts, and so on. The use of the word “closure” here comes from abstract algebra, where a set of elements is said to be closed under an operation if applying the operation to elements in the set produces an element that is again an element of the set. A sequence is an ordered collection of data objects. There are many ways to represent sequences. In our language, a sequence produced by (list &lt;a1&gt; &lt;a2&gt; ... &lt;an&gt;) is equivalent to (cons &lt;a1&gt; (cons &lt;a2&gt; (cons ... (cons &lt;an&gt; nil) ...)))&hairsp;. Such a sequence is called a list. Sequences serve as a conventional interface that permits us to combine processing modules (e.g. maps, filters, and accumulations). Trees are sequences whose elements are sequences. They can be dealt naturally with recursions. The approach of stratified design helps make programs robust, that is, it makes it likely that small changes in a specification will require correspondingly small changes in the program. 2.3 Symbolic Data To extend the representational capability of our language, we introduce the ability to quote a data object, that is, to work with arbitrary symbols as data. Prefix code is a way of coding such that no complete code of any symbol is the prefix of the code for another symbol. One particular scheme uses Huffman encoding tree. 2.4 Multiple Representations for Abstract Data This section introduces a new kind of data-abstraction barriers that isolate different representations of data from each other. Generic procedures are procedures that can operate on data that has multiple representations. We’ll need the help of type tags that specify how the data are to be processed. As systems evolve over time, we need conventions to incorporate new modules into systems additively, that is, without having to re-implement the modules. Two styles of organizing system with generic operations are introduced, they are: Data-directed style. In this style, we handle generic operations by dealing explicitly with operation-and-type tables. Message-passing style. In this style, we create data objects as dispatching procedures. Such a procedure takes as argument the name of an operation to be performed. 2.5 Systems with Generic Operations$\\cdots\\cdots$","link":"/SICP/notes/2/"}],"posts":[{"title":"区间最小公倍数","text":"题目链接：Codeforces Hello 2015 (Div.2) - LCM Query 求出某个序列所有给定长度的连续子序列的最小公倍数中的最小值。考虑到有大量询问、无需进行修改，故采用 稀疏表 + 离线处理 的方法。 题目描述出题人喜欢最小公倍数&hairsp;$({\\rm lcm})$，他提供了一个数列 $a_1,a_2,\\ldots,a_n$，并给出了一些 $x$，希望你对每个 $x$ 都求出以下式子的值： $$\\min_{i=1}^{n-x+1}{\\rm lcm}(a_i,a_{i+1},\\ldots,a_{i+x-1})$$ 简单来说求出这个数列所有长度为 $x$ 的连续子序列的最小公倍数中的最小值（简单来说？ 数列 ${a_i}$ 的长度为 $n$，一个 $x$ 就是一次询问，共有 $m$ 次询问，并有以下限制： $1\\leq n\\leq2\\times10^4$$1\\leq m\\leq10^6$$1\\leq a_i\\leq60$$1\\leq x\\leq n$ 题解对于一个数 $x$，可以将其分解质因数：$x=p_1^{b_1}\\times p_2^{b_2}\\times\\ldots\\times p_k^{b_k}$，其中 $p_i$ 指第 $i$ 个素数。于是 $x$ 就可以表示为一个数列 $b$&hairsp;。用这种表示方法，可以很方便地表示最小公倍数。假设有两个数 $x=p_1^{b_1}\\times p_2^{b_2}\\times\\ldots\\times p_k^{b_k}$ 和 $y=p_1^{c_1}\\times p_2^{c_2}\\times\\ldots\\times p_k^{c_k}$，那么就有： $${\\rm lcm}(x,y)=p_1^{\\max(b_1,c_1)}\\times p_2^{\\max(b_2,c_2)}\\times\\ldots\\times p_k^{\\max(b_k,c_k)}$$ 由于题目要求让结果对 $10^9 + 7$ 取模，算出的结果不能直接比较大小。所以利用对数的性质，取对数后再比较对数的大小： $$\\begin{aligned}\\log(x)&amp;=b_1\\log(p_1)+b_2\\log(p_2)+\\ldots+b_k\\log(p_k)\\\\\\log(y)&amp;=c_1\\log(p_1)+c_2\\log(p_2)+\\ldots+c_k\\log(p_k)\\\\\\log(x)&amp;\\lt\\log(y)\\implies x\\lt y\\end{aligned}$$ 最后是查询，对于每一个 $x$ 都重新遍历一遍数列是肯定会 TLE 的，所以要先将每一个区间长度的结果处理出来。大概过程是这样的：创建两个 “指针” $l$ 和 $r$&hairsp;。一开始，$l$ 和 $r$ 都指向第一个元素，之后让 $r$ 不断向后移动，直至指向第一个 ${\\rm lcm}$ 值$ {\\rm lcm}(a_l,a_{l+1},\\ldots,a_r)$ 与之前的 ${\\rm lcm}$ 值不同的元素，并用之前的 ${\\rm lcm}$ 值更新 $ans_{r-l}$ 的值。再向右移动 $r$ 并如此更新，直至数列尾后元素。之后 $l$ 和 $r$ 同时指向第二个元素，重复上述操作，再同时指向第三个元素…… 直至同时指向数列的尾部元素。 以数列 $12,3,6,25,5,7$ 举例： $l=0,r=3$，用 ${\\rm lcm}(12,3,6)=12$ 更新 $ans_3$ $l=0,r=5$，用 ${\\rm lcm}(12,3,6,25,5)=300$ 更新 $ans_5$ $l=0,r=6$，用 ${\\rm lcm}(12,3,6,25,5,7)=2100$ 更新 $ans_6$ $l=1,r=3$，用 ${\\rm lcm}(3,6)=6$ 更新 $ans_2$ …… 这部分比较难搞懂，代码中已经用 $64$ 道反斜杠划出了重点。 参考代码lcm-query.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;using namespace std;typedef vector&lt;int&gt; vi;typedef long long ll;const int maxn = 2e4 + 1;const int lg2maxn = 15;const ll mod = 1e9 + 7;int lg2[maxn], pw2[lg2maxn], ansi[maxn];vi rmq[maxn][lg2maxn], ans[maxn], p;vector&lt;double&gt; lnp;void init(){ for (int i = 2; i != maxn; ++i) lg2[i] = lg2[i &gt;&gt; 1] + 1; for (int i = 0; i != lg2maxn; ++i) pw2[i] = 1 &lt;&lt; i; for (int i = 2; i &lt;= 60; ++i) { bool prime = true; for (int j = 2; prime &amp;&amp; j * j &lt;= i; ++j) if (!(i % j)) prime = false; if (prime) p.push_back(i), lnp.push_back(log((double)i)); } fill(ans, ans + maxn, vi(p.size(), 7));}vi lcm(const vi&amp; a, const vi&amp; b){ vi res(p.size()); for (int i = 0, i_ = p.size(); i != i_; ++i) res[i] = max(a[i], b[i]); return res;}vi intvlcm(int l, int r){ int s = lg2[r - l]; return lcm(rmq[l][s], rmq[r - pw2[s]][s]);}vi itov(int x){ vi res(p.size(), 0); for (int i = 0, i_ = p.size(); i != i_; ++i) while (!(x % p[i])) ++res[i], x /= p[i]; return res;}int vtoi(const vi&amp; x){ ll res = 1ll; for (int i = 0, i_ = p.size(); i != i_; ++i) for (int j = x[i]; j--;) res = (res * p[i]) % mod; return res;}bool cmp(const vi&amp; a, const vi&amp; b){ double x = 0.0, y = 0.0; for (int i = 0, i_ = p.size(); i != i_; ++i) x += lnp[i] * a[i], y += lnp[i] * b[i]; return x &lt; y;}int main(){ init(); int n, q; scanf(\"%d%d\", &amp;n, &amp;q); for (int i = 0, t; i != n; ++i) scanf(\"%d\", &amp;t), rmq[i][0] = itov(t); for (int j = 1; j &lt;= lg2[n]; ++j) for (int i = n - pw2[j]; i != -1; --i) rmq[i][j] = lcm(rmq[i][j - 1], rmq[i + pw2[j - 1]][j - 1]); //////////////////////////////// for (int l = 0; l != n; ++l) { vi cur = rmq[l][0]; for (int r = l; r != n;) { cur = lcm(cur, rmq[r][0]); for (int k = lg2[n - r]; k != -1; --k) if (r + pw2[k] &lt;= n &amp;&amp; lcm(cur, rmq[r][k]) == cur) r += pw2[k]; ans[r - l] = min(ans[r - l], cur, cmp); } } //////////////////////////////// for (int x; q--;) { scanf(\"%d\", &amp;x); printf(\"%d\\n\", ansi[x] ? ansi[x] : (ansi[x] = vtoi(ans[x]))); }}","link":"/posts/codeforces-gym-100571-c/"},{"title":"My Impression of Hexo","text":"Struggled for hours tweaking themes and preferences, I finally end up with this. Hexo was amazing, that simple and elegant writing experience really captivates me.","link":"/posts/my-impression-of-hexo/"},{"title":"2020牛客寒假算法基础集训营5","text":"解题报告 ( ABCDEFGHIJ ) 比赛链接：2020牛客寒假算法基础集训营5 A. 模板题目描述牛牛，牛可乐和牛能组成了一只队伍参加ACM系列赛事，他们起了一个优雅的队名叫~“牛牛战队”。 牛牛战队在没有比赛的时候，会把各种板子放在密码柜里，防止弄丢。这一个密码由整个队伍掌管。其中牛牛和牛能有两个密钥，各自有一个仅由大写字母构成的字符串。牛可乐则掌握着解密方法。一天，你用一瓶可乐贿赂牛可乐，得到了解密的办法： 牛可乐将试图通过以下操作用尽可能少的步骤把一个密钥转换为另一个： 将其中任意一个字母替换为另一个 把最后一个字母删除 在尾部添加一个字母 得到的转化步数就是最后的密码。 一天，你和他们队员一起聚餐，你用可乐把他们灌倒了，从牛牛和牛能口中套出了两个密钥。你要趁他们醒之前拿到模板并复印一份再放回去。你能尽快的算出密码吗？ 输入描述输入数据共 $3$ 行，第一行包括两个整数 $n,m\\,(1\\leq n,m\\leq10^5)$ 表示两个密钥的长度 第二行包含一个长度为 $n$ 的字符串 $s_1$ 表示第一个密钥。 第三行包含一个长度为 $m$ 的字符串 $s_2$ 表示第二个密钥。 输出描述在一行内输出一个整数，表示密码。 示例输入1234 3WXYZWXY 输出11 题解由于插入和删除操作只能在字符串末尾进行，这题简单了很多。 $$\\text{转化步数}=\\max\\lbrace m,n\\rbrace\\,-\\,\\text{重合的字符个数}$$ 参考代码A.cpp1234567891011121314#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = l, i##_ = r; i &lt; i##_; ++i)using namespace std;int main(){ int n, m, ans = 0; string a, b; cin &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b; rep(i, 0, min(a.length(), b.length())) if (a[i] == b[i]) ++ans; cout &lt;&lt; max(m, n) - ans &lt;&lt; endl;} B. 牛牛战队的比赛地题目描述由于牛牛战队经常要外出比赛，因此在全国各地建立了很多训练基地，每一个基地都有一个坐标 $(x,y)$&hairsp;。这周末，牛牛队又要出去比赛了，各个比赛的赛点都在 $x$ 轴上。牛牛战队为了方便比赛，想找一个到达训练基地最大距离最小的地方作为比赛地。这个问题对于牛牛战队太简单了，它就交给了你，你来帮他算一下~ 输入描述输入数据第一行包含一个整数 $N\\, (1\\leq N\\leq100,000)$，表示牛牛战队训练基地的数量。 接下来 $N$ 行，每行包括 $2$ 个整数 $x,y\\, (-10,000\\leq x,y\\leq10,000)$，表示每一个训练基地的坐标。 输出描述输出一个小数，表示选择的比赛地距离各训练基地最大距离的最小值。 如果你的答案是 $a$，标准答案是 $b$，当 $|a-b|\\leq10^{-4}$ 时，你的答案将被判定为正确。 示例输入123430 02 00 2 输出12 说明当在 $(0,0)$ 比赛时，到三个训练基地的最大距离是 $2$&hairsp;。可以证明这是最小值。 题解这道题需要对半径使用二分法，判断一个半径是否合法，合法则缩小半径，不合法则扩大半径。 如何判断一个半径是否合法（即 “这个半径的圆是否有可能囊括所有点”）呢？ 若一个半径合法，一定存在一个区间（或一点），使以区间上任一点为圆心的圆，都能囊括所有的点。我们只需记录下这个区间的左端点和右端点即可。判断时需遍历所有点，遍历时使用 $(x[i]-k,x[i]+k)$ 与原区间的交集更新区间（如图）。 若最终区间存在，则半径合法，否则不合法。 参考代码B.cpp1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int MAX_N = 1e5 + 7;double xs[MAX_N], ys[MAX_N];int n;bool check(double rad){ double l = -10010.0, r = 10010.0, rsqr = rad * rad; for (int i = 0; i != n; ++i) { if (abs(ys[i]) &gt; rad) return false; double k = sqrt(rsqr - ys[i] * ys[i]); if ((l = max(l, xs[i] - k)) &gt; (r = min(r, xs[i] + k))) return false; } return true;}int main(){ scanf(\"%d\", &amp;n); for (int i = 0; i != n; ++i) scanf(\"%lf%lf\", &amp;xs[i], &amp;ys[i]); double l = 0, r = 10010.0, m; while (r - l &gt; 1e-9) { m = (l + r) / 2.0; (check(m) ? r : l) = m; } printf(\"%.9f\\n\", m);} C. C语言IDED. 牛牛与牛妹的约会题目描述牛牛在辛苦的一天的比赛之后，要去找牛妹玩，其实牛妹那天也在比赛。他为了找到牛妹，要尽快的从自己的比赛地到她的比赛地。 还记得吗，比赛地都是只在 $x$ 轴上的，所以两个人的坐标都满足 $y=0$&hairsp;。牛牛除了可以以 $1$ 单位距离/单位时间的速度移动任意时间以外，还可以花费 $1$ 单位时间进行闪现。每次闪现时，如果当前他的坐标是 $x=k$，他将闪现到 $x=\\sqrt[3]{k}$ 的位置。 请帮他算算，最短需要多少时间，他可以找到牛妹~ 输入描述输入数据包括多组用例，输入第一行包含一个数字 $T\\,(1\\leq T\\leq5\\times10^5)$，表示数据组数。 接下来 $T$ 行，每行包括两个整数 $a,b\\,(|a|,|b|\\leq10^6)$，表示牛牛所在的位置和牛妹所在的位置。 输出描述输出共 $T$ 行，每行包括一个实数，表示牛牛所花费的最短时间。 如果你的答案是 $a$，标准答案是 $b$，当 $|a-b|\\leq10^{-6}$ 时，你的答案将被判定为正确。 示例输入12323 -11 2 输出123.4422495701.000000000 题解为了使时间尽量短，一定是闪现在前，移动在后。不停闪现，直到闪现能够缩短的距离小于 $1$，之后用移动来补全剩下的距离。 参考代码D.cpp12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int T, _a, _b; double ans, a, b, t; cin &gt;&gt; T; while (T--) { cin &gt;&gt; _a &gt;&gt; _b; a = _a, b = _b; ans = 0.0; while (true) { t = cbrt(a); if (1.0 + abs(t - b) &lt; abs(a - b)) { ans += 1.0; a = t; } else { ans += abs(a - b); break; } } printf(\"%.9f\\n\", ans); }} E. Enjoy the game题目描述牛牛战队的三个队员在训练之余会自己口胡了一些题当做平时的益智游戏。有一天牛可乐想出了一个小游戏给另外两名队员玩，游戏规则如下： 初始一共有 $n$ 张卡牌 先手第一步最少要拿 $1$ 张牌，最多要拿 $n−1$ 张牌。 接下来每一步，双方最少要拿 $1$ 张牌，最多拿等同于上一步对方拿的牌数的牌。 拿走最后一张牌的人将取得游戏的胜利。 你作为旁观者，看着他们玩得很开心，想参与到这场游戏中来，赌一赌谁会能赢。 输入描述输入数据包含一个整数 $n\\,(2\\leq n\\leq10^{18})$，表示初始卡牌张数。 输出描述如果先手有必胜策略，输出 Bob，否则输出 Alice&hairsp;。 示例输入12 输出1Alice 说明先手必须拿走一张牌，然后后手拿走了另一张牌，游戏结束。 题解这题是我比较喜欢的一题，考察了你的思维方式。拿到这题的第一想法是在纸上模拟一下，找找规律，模拟的过程中，我发现： 若纸牌张数为奇数，是一定有必胜策略的，只要一开始只拿一张牌，两人轮流拿牌后一定是自己拿到最后一张牌。 若纸牌张数为偶数，那么为了不输，拿牌的一方一定是拿偶数张牌的，否则接下来对方会只拿一张牌，并在轮流拿牌后拿到最后一张牌。既然双方为了不输都会拿偶数张牌，我们就可以将牌两两合并，将相邻的两张牌看作一张，从而将问题转化为只有半数牌的情况。 找到了如上规律，我们就可以解决这个问题了。以 $12$ 张牌的情况举例，我们可以将其等同为 $6$ 张牌的情况，进而等同为 $3$ 张牌的情况。$3$ 为非 $1$ 的奇数，所以是有必胜策略的。事实上，只有当牌数为 $ 2^n (n\\in\\mathbf{N}^{*})$ 时，是没有必胜策略的。 参考代码E.cpp12345678#include &lt;bits/stdc++.h&gt;int main(){ long long n; scanf(\"%lld\", &amp;n); puts((n &amp; (-n)) == n ? \"Alice\" : \"Bob\");} 未完待续……","link":"/posts/nowcoder-2020-winter-camp-5/"},{"title":"牛客练习赛58","text":"解题报告 ( ABCDEF ) 这两天为了把E题搞懂，还接触了一些线段树、离线处理的相关知识。虽然这里没有用到线段树，不过它在解决区间问题时是个重要的数据结构，这几天会相应地更新一些探究线段树的文章。 比赛链接：牛客练习赛58 这次练习赛 AB 两题都是签到题，不必多说。 C. 矩阵消除游戏题目描述牛妹在玩一个名为矩阵消除的游戏，矩阵的大小是 $m$ 行 $n$ 列，第 $i$ 行第 $j$ 列的单元格的权值为 $a_{i,j}$​ ，牛妹可以进行 $k$ 个回合的游戏，在每个回合，牛妹可以选择一行或者选择一列，然后将这一行或者这一列的所有单元格中的权值变为 $0$，同时牛妹的分数会加上这一行或者这一列中的所有单元格的权值的和。 求出得分的最大值。 输入描述第一行三个整数 $m,n,k$接下来 $m$ 行每行 $n$ 个整数表示矩阵中各个单元格的权值。 $1\\leq m,n\\leq15$$1\\leq a_{i,j}\\leq10^6$$1\\leq k\\leq m\\times n$ 输出描述输出一个整数表示牛妹能获得的最大分数。 示例输入12343 3 2101 1 1021 202 1100 8 100 输出1414 题解这题尝试了不少策略，都是贪心策略，不过都是错的。还没有想到什么更好的办法，那就暴力搜索吧…… 一共取 $k$ 行 / 列，那么就先试着取 $0$ 行 $k$ 列，再试着取 $1$ 行 $k-1$ 列…… 逐次枚举。 参考代码C.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int maxn = 1e6 + 7;int m, n, k;int mat[20][20];int ans;int cols_max(int num){ int sum[20] {}, res = 0; for (int i = 0; i != n; ++i) for (int j = 0; j != m; ++j) sum[i] += mat[j][i]; sort(sum, sum + n, greater&lt;int&gt;()); for (int i = 0; i != num; ++i) res += sum[i]; return res;}void dfs(int row, int num = 1, int sum = 0){ if (num == k + 1) return; int rec[20], rsum = 0, tmp; for (int i = 0; i != n; ++i) { rec[i] = mat[row][i]; rsum += rec[i]; mat[row][i] = 0; } if ((tmp = sum + rsum + cols_max(k - num)) &gt; ans) ans = tmp; for (int i = row + 1; i != m; ++i) dfs(i, num + 1, sum + rsum); for (int i = 0; i != n; ++i) mat[row][i] = rec[i];}int main(){ scanf(\"%d%d%d\", &amp;m, &amp;n, &amp;k); int sum = 0; for (int i = 0; i != m; ++i) for (int j = 0; j != n; ++j) { scanf(\"%d\", &amp;mat[i][j]); sum += mat[i][j]; } if (k &gt;= min(m, n)) printf(\"%d\\n\", sum), exit(0); ans = cols_max(k); for (int i = 0; i != m; ++i) dfs(i); printf(\"%d\\n\", ans);} D. 迷宫题目描述有一个 $m\\times n$ 的迷宫，迷宫中每个格子用 $0$ 或 $1$ 表示，$0$ 表示该格子可以通过，$1$ 表示该格子是个障碍物，牛妹站在格子 $(1,1)$，出口在格子 $(m,n)$，牛妹想要走出迷宫，但牛妹只会按以下策略走： 牛妹当前所在的格子称为当前格子 如果当前格子右边没有障碍物，牛妹就向右走，否则转到2 如果当前格子下方没有障碍物，牛妹就向下走，否则转到3 如果当前格子左边没有障碍物，牛妹就向左走，否则转到4 如果当前格子上方没有障碍物，牛妹就向上走，否则转到5 牛妹站在原地不动 由于牛妹按这样的策略可能会无法走到出口，牛妹的好朋友牛牛决定在牛妹离开格子 $(1,1)$ 前把迷宫中的一些非障碍格子变成障碍，帮助牛妹走出迷宫，但是牛牛比较懒，他想要最小化变成障碍的非障碍格子的数量。 输入描述第一行两个整数 $m,n$ 表示迷宫的大小接下来 $m$ 行每行一个长度为 $n$ 的 $01$ 串表示迷宫的格局 $1\\leq n,m\\leq1000$ 输出描述输出一个整数表示牛牛最少需要转换成障碍格子的非障碍格子的数量，如果无法帮助牛妹走出迷宫，输出 -1&hairsp;。 示例输入123454 40000011001100000 输出10 题解这题给出的五条行走策略，有点吓唬人，实际上可以缩减为这两条： 若右边没有障碍物，向右走一格，否则转到2 若下边没有障碍物，向下走一格 这两条都不符合的话，则无法到达终点。如果在某个位置可以向左走一格，下一步一定又得回到右边，从而左右来回移动，无法到达终点。 有了这两条，即只能向右或者向下走，这个问题就可以用记忆化搜索，或者动态规划来解决了。使用一个表格&hairsp;$(dp)$来记录结果。其中 $dp[i][j]$ 的含义是 “从 $(1,1)$ 位置走到 $(i,j)$ 位置总共放置的障碍物的最少个数”。那么，$(i,j)$ 取终点位置时，表中的便是这题的结果。 $$dp[i][j]=\\begin{cases}0&amp;,i=1,j=1\\\\dp[i][j-1]&amp;,i=1,j&gt;1\\\\dp[i-1][j]&amp;,i&gt;1,j=1\\\\\\min\\lbrace dp[i][j-1],dp[i-1][j]+1\\rbrace&amp;,(i-1,j+1)\\text{处没有障碍物}\\\\\\min\\lbrace dp[i][j-1],dp[i-1][j]\\rbrace&amp;,\\text{否则}\\end{cases}$$ 仅当右边和下边都没有障碍物，却坚持要向下走时，需要在右边加一个障碍物。这就是上式第四条的含义。 我写了两个版本的代码，最终发现，动态规划比记忆化搜索快了近十倍。 统计数组访问（存 / 取）次数后大概分析了一下，这大概是因为动态规划只需要记忆化搜索一半不到的访问量，加之没有函数递归调用的开销。 参考代码 (Memory Searching)D_MS.cpp1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int maxn = 1007;int m, n;char mat[maxn][maxn];int dp[maxn][maxn], vis[maxn][maxn];int dfs(int x, int y){ if (vis[x][y]) return dp[x][y]; vis[x][y] = 1; if (y != n - 1 &amp;&amp; mat[x][y + 1] == '0') dp[x][y] = min(dp[x][y], dfs(x, y + 1)); if (x != m - 1 &amp;&amp; mat[x + 1][y] == '0') { if (y != n - 1 &amp;&amp; mat[x][y + 1] == '0') dp[x][y] = min(dp[x][y], dfs(x + 1, y) + 1); else dp[x][y] = min(dp[x][y], dfs(x + 1, y)); } return dp[x][y];}int main(){ scanf(\"%d%d\", &amp;m, &amp;n); memset(dp, 0x3f, sizeof(dp)); dp[m - 1][n - 1] = 0; for (int i = 0; i != m; ++i) scanf(\"%s\", mat[i]); if (dfs(0, 0) == 0x3f3f3f3f) puts(\"-1\"), exit(0); printf(\"%d\\n\", dp[0][0]);} 参考代码 (Dynamic Programming)D_DP.cpp1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int maxn = 1007;int m, n;char mat[maxn][maxn];int dp[maxn][maxn];int main(){ scanf(\"%d%d\", &amp;m, &amp;n); for (int i = 1; i &lt;= m; ++i) scanf(\"%s\", mat[i] + 1); memset(dp, 0x3f, sizeof(dp)); dp[1][1] = 0, mat[1][1] = '1'; for (int i = 1; i &lt;= m; ++i) for (int j = 1; j &lt;= n; ++j) { if (mat[i][j] == '1') continue; dp[i][j] = min(dp[i][j - 1], dp[i - 1][j] + (mat[i - 1][j + 1] == '0' ? 1 : 0)); } if (dp[m][n] == 0x3f3f3f3f) puts(\"-1\"), exit(0); printf(\"%d\\n\", dp[m][n]);} E. 最大GCD题目描述给出长度为 $n$ 的序列，序列中有 $n$ 个元素 $a_1,a_2,\\ldots a_n$​，你需要进行 $q$ 次查询，每次查询形如以下格式： $l\\;r\\;x$：你需要选择两个整数 $s,t$ 满足 $l\\leq s\\leq t\\leq r$，使得 $\\gcd(a[s],a[s+1],\\ldots,a[t−1],a[t],x)$ 最大化。 输入描述第一行两个整数 $n,q$第二行 $n$ 个整数 $a_1,a_2,\\ldots a_n$​接下来 $q$ 行每行三个整数表示一个查询 $1\\leq l\\leq r\\leq n,q,x,a_i​\\leq10^5$ 输出描述对于每个查询输出一个整数表示 $\\gcd(a[s],a[s+1],\\ldots,a[t−1],a[t],x)$ 的最大值。 示例输入12344 22 4 3 61 3 61 4 10 输出1232 题解看到这题，我懵圈了好久。查询时 “使得 $\\gcd(a[s],a[s+1],\\ldots,a[t−1],a[t],x)$ 最大化” 的这个步骤怎么解决？ 实际上是出题人在吓唬人，由于 $\\gcd$ 的特殊性质，选取的数越多只会让结果越小。所以查询的实际步骤是 “在 $\\lbrace a[l],a[l+1],\\ldots,a[r]\\rbrace$ 里取一个数 $a_i$，使得 $\\gcd(a_i,x)$ 最大化”。 首先想到的是最朴素的做法： 对于每一次查询，都将 $[l,r]$ 区间里的每一个数与 $x$ 求最大公约数，途中记录下最大的一个。 但是这样做的时间复杂度大致是 $O(nq\\log(x))$，最坏情况下能达到 $10^{10}$ 数量级，不可行。 涉及到最大公因数的问题，如果朴素的算法不能解决，那么从因子的角度去考虑无疑是一个有益的尝试： 首先将所有数的所有因子预存起来 对于每一次查询，从大到小枚举 $x$ 的因子，对 $[l,r]$ 区间里的每一个数，判断其是否有这个因子。如果枚举过程中出现了共有的因子，这个因子就是要查询的最大值。 可以给所有数建一个 vector&lt;int&gt;，存储其所有的因子。因子的大小是有序的，这样对于 $x$ 的每个因子，使用二分查找就能在 $O(\\log n)$ 的时间复杂度下判断一个数是否有这个因子。 这样做的时间复杂度大致是 $O(nq\\log(F)),F$ 为某个数的因子个数。由于 $[1,10^5]$ 范围内每个数的因子最多也就 $128$ 个，二分查找因子的速度很快。虽然速度比一开始快了一些，最坏情况下还是达到了 $10^{10}$ 数量级，仍然不可行。 所以接下来，要引进离线处理的方法，什么是离线处理？离线处理即不考虑对查询进行立即答复，而是将问题集中起来，最后统一答复。等到所有问题都聚集起来的时候，我们对其分析，往往可以发现各个查询之间有某些关联，利用这些关联得以更有效地解决问题。 具体到这一题，我们采用离线处理的方法，将查询全部读入后，按照区间右端点的顺序排序 (为什么是按右端点的顺序排序？往下看)。 之前，查询每个因子，都要重新枚举一次区间里的每一个数，这样效率明显太低。于是可以创建一个数组 $rec$，其中 $rec_i$ 的值表示因子 $i$ 出现的最右位置。每次查询前，需要将 $rec$ 数组更新到右端点 (具体见下方的 update 函数)。之后，对于 $x$ 的某个因子 $i$，只需判断其出现的最后位置是否在查询的左端点之后，即 $rec_i\\geq l$ 是否成立，就可以得知其是否在 $[l,r]$ 区间里出现过。 所以，按照右端点排序的理由就明确了，这样排序的话，可以确保 $rec$ 数组中存储的最右位置不超过当前查询的右端点。 这样做，需要更新的次数是所有查询右端点的最大值 (最大是 $n$&hairsp;)，每次查询需要 $F$ 次访问 $rec$ 数组 ($F$ 为某个 $x$ 的因子个数)。所以最坏情况下的时间复杂度是 $O(nF+qF)$，大约是 $10^6$ 数量级，符合要求。 参考代码E.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int maxn = 1e5 + 7;struct query { int l, r, x, idx;} Q[maxn];int n, q;int a[maxn], rec[maxn], ans[maxn];vector&lt;int&gt; fact[maxn];void init(){ memset(rec, -1, sizeof(rec)); for (int i = 1; i &lt; maxn; ++i) for (int j = i; j &lt; maxn; j += i) fact[j].push_back(i);}void update(int x, int pos){ for (int&amp; val : fact[x]) rec[val] = pos;}int main(){ init(); scanf(\"%d%d\", &amp;n, &amp;q); for (int i = 0; i != n; ++i) scanf(\"%d\", &amp;a[i]); for (int i = 0; i != q; ++i) scanf(\"%d%d%d\", &amp;Q[i].l, &amp;Q[i].r, &amp;Q[i].x), Q[i].idx = i; sort(Q, Q + q, [](const query&amp; a, const query&amp; b) -&gt; bool { return a.r &lt; b.r; }); int pos = 0; for (int i = 0; i != q; ++i) { int l = Q[i].l - 1, r = Q[i].r - 1, &amp;x = Q[i].x, &amp;idx = Q[i].idx; while (pos &lt;= r) update(a[pos], pos), ++pos; for (auto it = fact[x].rbegin(), it_ = fact[x].rend(); it != it_; ++it) if (rec[*it] &gt;= l) { ans[idx] = *it; break; } } for (int i = 0; i != q; ++i) printf(\"%d\\n\", ans[i]);} F. XOR TREE","link":"/posts/nowcoder-practice-58/"},{"title":"2020牛客寒假算法基础集训营6","text":"解题报告 ( ABCDEFGHIJ ) 2020-02-18 增加H题题解 比赛链接：2020牛客寒假算法基础集训营6 A. 配对题目描述现在有正整数集合 $A$ 和 $B$，每个集合里有 $N$ 个数，你要建立他们间的一一映射将每对配对的数字相加可以得到 $N$ 个和，你要做的就是最大化第 $K$ 大的和$1\\leq K\\leq N\\leq100,000$ 输入的所有数字不超过 $10^8$ 输入描述第一行 $2$ 个数字 $N,K$接下来两行，每行 $N$ 个正整数，分别表示 $A$ 和 $B$ 中的元素 输出描述一行，表示第 $K$ 大的和的最大值 示例输入1233 21 2 31 2 3 输出15 题解为了使相加后第 $K$ 大的数最大，应该将 $A$ 序列前 $K$ 大的数，与 $B$ 序列前 $K$ 大的数相配对。 如此看来，可以只保留 $A$ 序列和 $B$ 序列前 $K$ 大的项，而直接舍弃所有后面的项。此时题目便转化为了：将 $A$ 序列和 $B$ 序列前 $K$ 大的项配对求和，求和后序列的最小值最大是多少？ 为了使最小值尽量大，可以将 $A$ 序列由大到小排序，$B$ 序列由小到大排序，并逐项相加。最后求出序列的最小值，就是答案。 参考代码A.cpp1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = l, i##_ = r; i &lt; i##_; ++i)using namespace std;constexpr int MAX_N = 1e5 + 7;int A[MAX_N], B[MAX_N];int main(){ int n, k; scanf(\"%d%d\", &amp;n, &amp;k); rep(i, 0, n) scanf(\"%d\", &amp;A[i]); rep(i, 0, n) scanf(\"%d\", &amp;B[i]); sort(A, A + n, greater&lt;int&gt;()); sort(B, B + n); for (int i = 0; i != k; ++i) A[i] += B[i + n - k]; int ans = A[0]; rep(i, 1, k) if (A[i] &lt; ans) ans = A[i]; printf(\"%d\\n\", ans);} B. 图题目描述现在有一个 $N$ 个点的有向图，每个点仅有一条出边（有可能出现自环）你需要求出图中最长的简单路径包含点的数量$(1\\leq N\\leq1,000,000)$ 输入描述第一行，一个数字 $N$接下来 $N$ 行，每行一个正整数，第 $i+1$ 行的数字表示第 $i$ 个点出边终点的编号（点从 $1$ 开始标号） 输出描述一行一个数字，最长的简单路径的长度 示例输入12343232 输出13 题解简单路径即不重复经过同一点的路径，这题考察了深度优先搜索技巧。记录下某一点所指向的点&hairsp;$(to_i)$，该点是否已被访问过&hairsp;$(vis_i)$，以及以该点为起点最多经过多少点&hairsp;$(len_i)$&hairsp;。 具体实现方法见代码。 参考代码B.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int MAXN = 1e6 + 7;bool vis[MAXN];int len[MAXN], to[MAXN];int ans;void dfs(int x){ vis[x] = true; if (vis[to[x]]) { if (len[to[x]]) { len[x] = len[to[x]] + 1; } else { int curr = to[x], cnt = 1; while (curr != x) { ++cnt; curr = to[curr]; } curr = to[x]; while (curr != x) { len[curr] = cnt; curr = to[curr]; } len[x] = cnt; } } else { dfs(to[x]); if (!len[x]) len[x] = len[to[x]] + 1; } if (len[x] &gt; ans) ans = len[x];}int main(){ int n; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", &amp;to[i]); for (int i = 1; i &lt;= n; ++i) if (!vis[i]) dfs(i); printf(\"%d\\n\", ans);} C. 汉诺塔题目描述现在你有 $N$ 块矩形木板，第 $i$ 块木板的尺寸是 $X_i\\times Y_i$，你想用这些木板来玩汉诺塔的游戏。我们知道玩汉诺塔游戏需要把若干木板按照上小下大的顺序堆叠在一起，但因为木板是矩形，所以有一个问题：第 $i$ 块木板能放在第 $j$ 块木板上方当且仅当 $X_i &lt; X_j$ 且 $Y_i &lt; Y_j$，于是你很可能没法把所有的木板按照一定的次序叠放起来。你想把这些木板分为尽可能少的组，使得每组内的木板都能按照一定的次序叠放。你需要给出任意一种合理的分组方案。提醒：“任意” 意味着你的答案不必和标准输出完全一致，只要正确即可。 输入描述第一行，一个正整数 $N$接下来 $N$ 行，每行两个正整数表示 $X_i$ 和 $Y_i$对于所有的数据 $1\\leq N\\leq100,000$ 且 $1\\leq X_i,Y_i\\leq N$，$X_i$ 互不相等且 $Y_i$ 互不相等 输出描述输出文件包含两行，第一行一个正整数，表示最少组数第二行 $N$ 个正整数，依次表示你的方案中每块木板分在了哪一组组的编号必须是从 $1$ 开始的连续整数 示例输入123431 12 33 2 输出1221 1 2 题解待补充参考代码C.cpp12 D. 重排列题目描述一个序列的重排列是指对这个序列中的元素进行若干次（包括 $0$ 次）交换操作后得到的新序列在本题中，序列中可能出现重复的数字，他们被视作不同的元素例如，序列 $1\\quad1$ 的重排列有两种现在有两个长度为 $N$ 的非负整数序列 $A$ 和 $B$，问有多少种 $A$ 的重排列满足对于所有的 $1\\leq i\\leq N$，有 $A_i\\leq B_i$由于答案可能很大，你只需要输出答案对 $10^9+7$ 取模的结果 输入描述输入第一行，包含一个正整数 $N$接下来一行，$N$ 个非负整数表示序列 $A$再接下来一行，$N$ 个非负整数表示序列 $B$$1\\leq N\\leq100,000$ 且 $0\\leq A_i,B_i\\leq10^9$ 输出描述一行一个整数，表示答案 示例输入12341 1 2 31 2 3 4 输出18 题解首先将 $A$ 序列和 $B$ 序列分别由小到大排序。对于 $B$ 序列的每一项，$A$ 序列中小于这一项的项数可以求出，这项数代表可选的排列方案数。 还要注意的是，已选择的数不能重复选择，需要从方案数里减去已选数的个数。最后将这些方案数相乘即可得出答案： $$Answer =\\prod_{i=1}^{N}(A\\,\\text{序列中不大于}\\,B_i\\,\\text{的项数} - (i-1))$$ 参考代码D.cpp1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = l, i##_ = r; i &lt; i##_; ++i)using namespace std;using ll = long long;constexpr ll MAXN = 1e5 + 7;constexpr ll MOD = 1e9 + 7;ll A[MAXN], B[MAXN];int main(){ int n; ll ans = 1; scanf(\"%d\", &amp;n); rep(i, 0, n) scanf(\"%lld\", &amp;A[i]); rep(i, 0, n) scanf(\"%lld\", &amp;B[i]); sort(A, A + n); sort(B, B + n); rep(i, 0, n) ans = (ans * (upper_bound(A, A + n, B[i]) - A - i)) % MOD; printf(\"%lld\\n\", ans);} E. 立方数题目描述对于给定的正整数 $N$，求最大的正整数 $A$，使得存在正整数 $B$，满足 $A^3B=N$输入包含 $T$ 组数据，$1\\leq T\\leq10,000$ 且 $1\\leq N\\leq10^{18}$ 输入描述第一行数字 $T$ 表示数据组数接下来一行，$T$ 个正整数 $N$ 输出描述$T$ 行，每行一个数字表示答案 示例输入12427 24 7 54 输出12343213 题解待补充参考代码E.cpp12 F. 十字阵列题目描述小Q 新学会了一种魔法，可以对一个 $N$ 行 $M$ 列 的网格上的敌人造成伤害第 $i$ 次使用魔法可以对网格上的一个十字形区域（即第 $x_i$ 行和第 $y_i$ 列的合并）中的每个格子上的敌人造成 $z_i$ 点伤害现在小Q 一共使用了 $H$ 次魔法，你需要在所有的施法完成之后统计造成伤害的情况，详见输出描述提醒：本题输入规模较大，请使用高效的输入方式$1\\leq H\\leq500,000$ 且 $1\\leq x_i,y_i,z_i,N,M\\leq2000$ 且 $1\\leq x_i\\leq N$ 且 $1\\leq y_i\\leq M$ 输入描述第一行 $3$ 个数字 $N,M,H$接下来 $H$ 行，每行 $3$ 个正整数 $x_i，y_i，z_i$ 输出描述为了避免大量的输出，假设第 $i$ 行第 $j$ 列受到的总伤害是 $w_{ij}$你只需要输出 $\\sum{(w_{ij}\\times(i+j))}$ 对 $10^9+7$ 取模的结果即可 示例输入1234565 5 51 1 12 2 23 3 34 4 45 5 5 输出1890 题解加权求和。每个方块的权值是已知的&hairsp;$(i+j)$，一个点对总伤害的贡献，等于该行和该列所有权值的和，乘以伤害。 参考代码F.cpp123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (ll i = l, i##_ = r; i &lt; i##_; ++i)using namespace std;using ll = long long;constexpr ll MOD = 1e9 + 7;void read(ll&amp;a, ll&amp;b, ll&amp;c){ char ch; a = b = c = 0; while ((ch = getchar()) &gt;= '0' &amp;&amp; ch &lt;= '9') a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (ch &amp; 0xf); while ((ch = getchar()) &gt;= '0' &amp;&amp; ch &lt;= '9') b = (b &lt;&lt; 3) + (b &lt;&lt; 1) + (ch &amp; 0xf); while ((ch = getchar()) &gt;= '0' &amp;&amp; ch &lt;= '9') c = (c &lt;&lt; 3) + (c &lt;&lt; 1) + (ch &amp; 0xf);}int main(){ ll n, m, h, x, y, z; read(n, m, h); ll ans = 0, mn = ((m + 1) * m + (n + 1) * n) &gt;&gt; 1; rep(i, 0, h) { read(x, y, z); ans = (ans + (mn + x * m + y * n - x - y) * z) % MOD; } printf(\"%lld\\n\", ans);} G. 括号序列题目描述合法括号序列的定义是： 空序列是合法括号序列 如果 $S$ 是一个合法括号序列,那么 $(S)$ 是合法括号序列 如果 $A$ 和 $B$ 都是合法括号序列,那么 $AB$ 是一个合法括号序列 现在给定一个括号序列，求最少删去几个括号能得到一个合法的括号序列输入包含 $T$ 组数据，每组数据中，设括号序列的长度为 $N$$1\\leq T,\\sum^T{(N)}\\leq1,000,000$（由于空串是合法的括号序列，所以答案可以是 $N$） 输入描述第一行一个数字 $T$接下来 $T$ 组数据共 $2T$ 行，每组数据第一行是 $N$第二行则是一个长度为 $N$ 的括号序列 输出描述$T$ 行 $T$ 个数字，表示输入的括号序列最少删去几个括号能得到一个合法的括号序列 示例输入1234526())(()9()(()())) 输出1221 题解记录未封闭的左括号数量。若没有未封闭括号却又出现了右括号，删去；若读取到末尾仍有未封闭括号，说明之前有相同数量的左括号需要删去。 参考代码G.cpp12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;int main(){ int T; scanf(\"%d\", &amp;T); while (T--) { int n, cnt = 0, ans = 0; scanf(\"%d \", &amp;n); for (int i = 0; i != n; ++i) { if (getchar() == '(') { ++cnt; } else { if (cnt) --cnt; else ++ans; } } printf(\"%d\\n\", ans + cnt); }} H. 云题目描述现在天空（可视为二维平面）中有 $N$ 朵 ${\\rm A}$ 类云，$M$ 朵 ${\\rm B}$ 类云，每朵云的形状都可以用边平行于坐标轴的矩形来描述。一开始，${\\rm A}$ 类云在第三象限，${\\rm B}$ 类云在第一象限，没有任何云和坐标轴有交点。随着风的吹拂，${\\rm A}$ 类云以每秒一个单位的速度向右移动，${\\rm B}$ 类云以每秒一个单位的速度向下移动，当一朵 ${\\rm A}$ 类云和一朵 ${\\rm B}$ 类云在某一个时刻有了至少一个公共点，它们就相遇了。现在请你告诉小R，有多少对 ${\\rm A}$ 类云和 ${\\rm B}$ 类云能够相遇。$1\\leq N,M\\leq100,000$ 且 $1\\leq|X_i|,|Y_i|,|P_i|,|Q_i|\\leq10^9$ 注： 本题输入规模较大，请注意输入的效率 输入的云的形状可能为退化的矩形（直线或点） 输入描述输入第一行，包含两个正整数 $N$ 和 $M$接下来 $N$ 行，每行描述一朵 ${\\rm A}$ 类云再接下来 $M$ 行，每行描述一朵 ${\\rm B}$ 类云一朵云的位置用一行四个数 $A_i,B_i,C_i,D_i$ 表示，意为这朵云左上角在 $(A_i,B_i)$，右下角在&hairsp;$(C_i,D_i)$ 输出描述一行一个整数，表示答案 示例输入1231 1-2 -1 -1 -21 2 2 1 输出11 题解这题需要换个角度思考：${\\rm A}$ 类云向右运动，${\\rm B}$ 类云向下运动。只是粗略想想的话，会觉得是个很复杂的运动。 但如果我们在坐标系中添加这样一条辅助线&hairsp;$(x+y=0)$呢？ 如图所示，上述运动便可描述为 “云朵们面对辅助线，向对面的云靠近，并同时向右下角移动”。 我们甚至可以忽略 “并同时向右下角移动”，因为这样并不会影响云彩相遇与否。 如此一来，若两朵云会相遇，它们一定会在辅助线上扫过一个共同的区域。例如，图中红色线段与黑色线段有重合部分，它们一定会相遇。 所以可以采用投影的方法，将云彩投影到辅助线上，得到一条线段，其在辅助线上的覆盖范围是 $[a-b,c-d]$&hairsp;。最后清点有重合部分的线段对数，即可得到答案。 清点前需记录下覆盖范围的端点&hairsp;$(node)$，包括其坐标&hairsp;$(pos)$&hairsp;、左端点还是右端点&hairsp;$(lr)$&hairsp;、${\\rm A}$ 类云还是 ${\\rm B}$ 类云&hairsp;$(type)$&hairsp;。 具体实现见参考代码，参考了牛客上某些大神的已通过代码，一开始看得很懵，不过领悟了这投影的方法就很好理解了。 参考代码H.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int MAXN = 4e5 + 7;struct node { int pos; int lr; int type; bool operator&lt;(const node&amp; rhs) const { if (pos == rhs.pos) return lr &gt; rhs.lr; return pos &lt; rhs.pos; }} nodes[MAXN];int main(){ int n, m, k = 0; int a, b, c, d; long long cnt[2] = {}, ans = 0; scanf(\"%d%d\", &amp;n, &amp;m); while (n--) { scanf(\"%d%d%d%d\", &amp;a, &amp;b, &amp;c, &amp;d); nodes[k++] = { a - b, 1, 0 }; nodes[k++] = { c - d, -1, 0 }; } while (m--) { scanf(\"%d%d%d%d\", &amp;a, &amp;b, &amp;c, &amp;d); nodes[k++] = { a - b, 1, 1 }; nodes[k++] = { c - d, -1, 1 }; } sort(nodes, nodes + k); for (int i = 0; i != k; ++i) { cnt[nodes[i].type] += nodes[i].lr; if (nodes[i].lr == 1) ans += cnt[nodes[i].type ^ 1]; } printf(\"%lld\\n\", ans);} I. 导航系统题目描述小Q 所在的国家有 $N$ 个城市，城市间由 $N-1$ 条双向道路连接，任意一对城市都是互通的。每条道路有一个长度，自然，小Q 的导航系统能显示每对城市间的最短距离。但是小Q 对这个系统并不太放心，于是他向你求助：给定每对城市间的最短距离，你要判断距离表是否一定有误。如果这张距离表是自洽的，那么请你按升序依次给出每条道路的长度。对于全部的数据，$1\\leq N\\leq500$，输入的所有数字都是不超过 $10^9$ 的非负整数。 输入描述第一行一个数字 $N$接下来 $N$ 行，每行 $N$ 个正整数第 $i$ 行第 $j$ 列的数字表示城市 $i$ 和城市 $j$ 间的最短距离保证第 $i$ 行第 $i$ 列的数字为 $0$ 输出描述第一行，一个字符串如果距离表没有问题，输出 Yes并在接下来的 $N-1$ 行从小到大给出每条道路的长度否则输出 No 即可 示例1输入123430 1 21 0 12 1 0 输出123Yes11 示例2输入123430 1 11 0 11 1 0 输出1No 题解待补充参考代码I.cpp12 J. 签到题题目描述现有一个边长为正整数的三角形，问能否以其三个顶点为圆心画三个圆，使三个圆两两外切三边长均不超过 $10^8$ 输入描述三个正整数，表示三角形的边长 输出描述如果三条边不能构成三角形，输出 wtnl如果三条边能构成三角形但不能画出符合要求的圆，输出 No否则输出一行 Yes然后在第二行输出一组方案，按升序给出三个圆的半径，保留两位小数 示例输入12 3 3 输出12Yes1.00 1.00 2.00 题解初中数学？ 参考代码J.cpp12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;int main(){ ll a, b, c; scanf(\"%lld%lld%lld\", &amp;a, &amp;b, &amp;c); if (a &gt; b) swap(a, b); if (b &gt; c) swap(b, c); if (a &gt; b) swap(a, b); if (a + b &lt;= c) puts(\"wtnl\"), exit(0); printf(\"Yes\\n%.2f %.2f %.2f\\n\", (double)(b + a - c) / 2.0, (double)(a + c - b) / 2.0, (double)(b + c - a) / 2.0);}","link":"/posts/nowcoder-2020-winter-camp-6/"},{"title":"线段树之懒惰标记","text":"最近在学习线段树的有关知识，期间遇到的重要的知识点和不错的习题，我会总结并记录下来。本文将持续更新，并将作为该系列的索引置顶一段时间。当前的索引如下： [x]-基本概念[x]-懒惰标记[ ]-扫描线（学习中…）[ ]-…… 为什么引入懒惰标记？懒惰标记的用处，就是更快地实现实现区间修改、区间查询。 考虑之前讲到的线段树。如果用线段树的单点修改，我们需要先改变叶子节点的值，然后不断地向上递归修改祖先节点直至到达根节点，时间复杂度最高可以到达 $O(n\\log n)$ 的级别，这还只是单次操作，更别说有 $10^5$ 次指令的情况了。 该怎么实现？其实就是用一个暂时不处理，等到需要用到的时候再进行处理的思想。 我们想，如果已经到达了属于答案区间范围内的节点，我们就直接对该节点进行一系列的操作，然后直接返回。这样，一定能保证本次区间更新的正确性。然而，区间更新不只一次，如果照刚刚那样更新而不进行任何后处理的话，那么该节点的子节点都未更新，势必会导致答案错误。于是，我们需要一种东西来记录下节点的更新信息，以便下次更新时处理。 所以引入一个名叫懒惰标记(lazytag) 的东西。之所以称其为 lazytag，是因为当我们引入懒惰标记后，我们不会去更新已经覆盖答案区间的子节点，只有在接下来的操作中我们才可能会用到该区间的子区间。所以这次操作就无需更新。区间更新的期望复杂度就降到了 $O(\\log n)$ 的级别。 之前遇到的，只有单次修改、查询的情况，都是子区间向父区间传递信息，称之为 pushup。而这次将懒惰标记向下传递，不就是反过来，是父区间向子区间传递信息吗？我们将向下传递操作称为 pushdown。 线段树使用分治法，用递归进行实现。显然，子区间向父区间传递信息，应该在递归地操作子区间之后。而我们为了保证子区间的数据在操作其之前已被更新，就需要在递归操作之前，从父区间向子区间传递消息。 于是，以区间整体加上一个数的操作为例，就可以如此标记： 1234567891011121314151617181920212223242526272829303132333435363738/** * ls[p] p节点的左端点 * rs[p] p节点的右端点 * sum[p] p节点的区间和 * lazy[p] p节点的懒惰标记 */#define chl (p * 2 + 1)#define chr (p * 2 + 2)void pushdown(int p){ // 子区间和 += (子区间的元素个数) * 父区间的懒标记 sum[chl] += (rs[chl] - ls[chl]) * lazy[p]; sum[chr] += (rs[chr] - ls[chr]) * lazy[p]; // 父区间的懒标记传递给子区间 lazy[chl] += lazy[p]; lazy[chr] += lazy[p]; // 清零父区间的懒惰标记 lazy[p] = 0;}void modify(int x, int y, int val, int p = 0){ if (x &lt;= ls[p] &amp;&amp; rs[p] &lt;= y) { sum[p] += (rs[p] - ls[p]) * val; lazy[p] += val; return; } pushdown(p); int mid = (ls[p] + rs[p]) &gt;&gt; 1; if (rs[p] &lt;= mid) return modify(x, y, val, chl); if (ls[p] &gt;= mid) return modify(x, y, val, chr); modify(x, mid, val, chl); modify(mid, y, val, chr);} 我认为懒惰标记的使用，最重要的就是如何 pushdown 了，下面的几道题目很能说明问题。 【习题】线段树 2提供一个序列，要求你维护三种操作： 将某区间每一个数乘上 $x$ 将某区间每一个数加上 $x$ 求出某区间每一个数的和 题解在洛谷中作为一道模板题，这道题实在是太虐心了。不过不得不承认，做完以后对线段树和懒惰标记的理解深入了许多。 看了这题讨论区的题解，很多人说什么先乘后加，我也是想了挺久才弄懂。 于是考虑这样一个区间 $0$，和它的两个子区间 $1$ 和 $2$，如图： 接着，我们记区间 $i$ 的区间的元素个数为 $span_i$&hairsp;、区间和为 $sum_i$&hairsp;、修改前的初始区间和为 $sum^\\prime_i$&hairsp;、区间延迟加法的懒标记为 $lazyadd_i$&hairsp;、区间延迟乘法的懒标记为 $lazymul_i$&hairsp;。于是有以下初始情况，初始情况下，$lazyadd_i=0,lazymul_i=1$： $$sum^\\prime_0=sum^\\prime_0\\times\\overbrace{1}^{lazymul_0} +\\overbrace{0}^{lazyadd_0}\\times span_0$$ 考虑将 $0$ 区间，先整体加上 $3$，再整体乘以 $4$，于是有： $$\\begin{aligned}sum_0=&amp;\\,(sum^\\prime_0\\times\\overbrace{1}^{lazymul_0} +\\overbrace{0}^{lazyadd_0}\\times span_0+3\\times span_0)\\times4\\\\=&amp;\\,(sum^\\prime_0\\times\\overbrace{1}^{lazymul_0} +\\overbrace{3}^{lazyadd_0}\\times span_0)\\times4\\\\=&amp;\\,sum^\\prime_0\\times\\overbrace{4}^{lazymul_0}+\\overbrace{12}^{lazyadd_0}\\times span_0\\end{aligned}$$ 上式中转换的两步，分别对应了递归更新区间 “懒惰加法” 和 “懒惰乘法” 的代码（rs[p] - ls[p] 即 $span_p$）： 1234567// 加法sum[p] += val * (rs[p] - ls[p]);lazyadd[p] += val;// 乘法sum[p] *= val;lazyadd[p] *= val;lazymul[p] *= val; 接下来考虑父区间将信息传递给子区间的 pushdown 操作。以子区间 $1$ 为例，将父区间加上 $3$ 和乘以 $4$ 的信息传入。假设该区间本身就有懒惰标记，其初始值分别为 $lazyadd^\\prime_1$ 和 $lazymul^\\prime_1$，于是有： $$\\begin{aligned}sum_1&amp;=\\,(sum^\\prime_1\\times\\overbrace{lazymul^\\prime_1}^{lazymul_1}+\\overbrace{lazyadd^\\prime_1}^{lazyadd_1}\\times span_1+3\\times span_1)\\times4\\\\&amp;=\\,[sum^\\prime_1\\times\\overbrace{lazymul^\\prime_1}^{lazymul_1} +\\overbrace{(lazyadd^\\prime_1+3)}^{lazyadd_1}\\times span_1]\\times4\\\\&amp;=\\, sum^\\prime_1\\times\\overbrace{lazymul^\\prime_1\\times4}^{lazymul_1}+\\overbrace{(lazyadd^\\prime_1\\times4+12)}^{lazyadd_1}\\times span_1\\\\&amp;=\\, sum^\\prime_1\\times\\overbrace{lazymul^\\prime_1\\times lazymul_0}^{lazymul_1} +\\overbrace{(lazyadd^\\prime_1\\times lazymul_0+lazyadd_0)}^{lazyadd_1}\\times span_1\\end{aligned}$$ 上式最后一步的转换比较关键，这样就和父区间建立起了联系。这对应了父区间向下传递的代码： 123456789101112131415#define chl (p * 2 + 1)#define chr (p * 2 + 2)void pushdown(int p) { // 更新子区间的区间和与懒惰标记 sum[chl] = sum[chl] * lazymul[p] + lazyadd[p] * (rs[chl] - ls[chl]); sum[chr] = sum[chr] * lazymul[p] + lazyadd[p] * (rs[chr] - ls[chr]); lazyadd[chl] = lazyadd[chl] * lazymul[p] + lazyadd[p]; lazyadd[chr] = lazyadd[chr] * lazymul[p] + lazyadd[p]; lazymul[chl] *= lazymul[p]; lazymul[chr] *= lazymul[p]; // 最后别忘了清零父区间的懒惰标记 lazyadd[p] = 0; lazymul[p] = 1;} 有了这些思路，代码自然就有了。 参考代码P3373.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;bits/stdc++.h&gt;#define chl (p * 2 + 1)#define chr (p * 2 + 2)using namespace std;using ll = long long;constexpr int maxn = 1e5;constexpr int maxt = 1 &lt;&lt; 18;ll a[maxn], mod;int n, m;struct segtree { ll ls[maxt], rs[maxt]; ll sum[maxt], lazyadd[maxt], lazymul[maxt]; void build(int l, int r, int p = 0) { ls[p] = l, rs[p] = r, lazyadd[p] = 0, lazymul[p] = 1; if (r - l == 1) { sum[p] = a[l] % mod; return; } int mid = (l + r) &gt;&gt; 1; build(l, mid, chl); build(mid, r, chr); sum[p] = (sum[chl] + sum[chr]) % mod; } void pushdown(int p) { sum[chl] = (sum[chl] * lazymul[p] + lazyadd[p] * (rs[chl] - ls[chl])) % mod; sum[chr] = (sum[chr] * lazymul[p] + lazyadd[p] * (rs[chr] - ls[chr])) % mod; lazyadd[chl] = (lazyadd[chl] * lazymul[p] + lazyadd[p]) % mod; lazyadd[chr] = (lazyadd[chr] * lazymul[p] + lazyadd[p]) % mod; lazymul[chl] = (lazymul[chl] * lazymul[p]) % mod; lazymul[chr] = (lazymul[chr] * lazymul[p]) % mod; lazyadd[p] = 0, lazymul[p] = 1; } void add(int x, int y, ll val, int p = 0) { if (x &lt;= ls[p] &amp;&amp; rs[p] &lt;= y) { sum[p] = (sum[p] + val * (rs[p] - ls[p])) % mod; lazyadd[p] = (lazyadd[p] + val) % mod; return; } pushdown(p); int mid = (ls[p] + rs[p]) &gt;&gt; 1; if (x &lt; mid) add(x, y, val, chl); if (y &gt; mid) add(x, y, val, chr); sum[p] = (sum[chl] + sum[chr]) % mod; } void mul(int x, int y, ll val, int p = 0) { if (x &lt;= ls[p] &amp;&amp; rs[p] &lt;= y) { sum[p] = (sum[p] * val) % mod; lazyadd[p] = (lazyadd[p] * val) % mod; lazymul[p] = (lazymul[p] * val) % mod; return; } pushdown(p); int mid = (ls[p] + rs[p]) &gt;&gt; 1; if (x &lt; mid) mul(x, y, val, chl); if (y &gt; mid) mul(x, y, val, chr); sum[p] = (sum[chl] + sum[chr]) % mod; } ll query(int x, int y, int p = 0) { if (ls[p] == x &amp;&amp; rs[p] == y) return sum[p]; pushdown(p); int mid = (ls[p] + rs[p]) &gt;&gt; 1; if (y &lt;= mid) return query(x, y, chl); if (x &gt;= mid) return query(x, y, chr); return (query(x, mid, chl) + query(mid, y, chr)) % mod; }} seg;int main(){ scanf(\"%d%d%lld\", &amp;n, &amp;m, &amp;mod); for (int i = 0; i != n; ++i) scanf(\"%lld\", &amp;a[i]); seg.build(0, n); int op, x, y; ll k; while (m--) { scanf(\"%d%d%d\", &amp;op, &amp;x, &amp;y), --x; if (op == 3) printf(\"%lld\\n\", seg.query(x, y)); else { scanf(\"%lld\", &amp;k); if (op == 1) seg.mul(x, y, k); else seg.add(x, y, k); } }} 【习题】市场提供一个序列，要求你维护四种操作： 区间整体加上 $x$ 区间的每一个数除以 $x$，并向下取整 查询区间最小值 查询区间和 题解这题让我深刻地体会到了，自己是个大常数选手。同一段代码别人用 $2500{\\rm ms}$，我的要用 $3300{\\rm ms}$&hairsp;。代码常数的差别，不是一两处修改就能赶上来的，有些习惯让大常数的代码无处不在… 说了一些废话。 这四种操作，我认为第二种是最重要的，其它都只是摆设罢了。 除以一个数容易想，维护两个懒惰标记，一个对应加法、一个对应除法就行了。可对于整除来说，这方法完全行不通。于是想到，很接近的数，比如 $9$ 和 $10$，在除以 $5$ 并向下取整后将变为 $1$ 和 $2$&hairsp;。相当于给两个数都减去了 $8$&hairsp;。于是，区间整除就变成了区间减法。 判断整个区间的数是否具备将整除转为区间减法的条件，需要记录下区间的最大值和最小值。一般来说只有最大值等于最小值，也就是区间数字都相同时符合条件。但比如说刚才 $9$ 和 $10$ 的例子，比较大的数能够被除数整除，则最小值可以比最大值小 $1$&hairsp;。 参考代码LOJ6029.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include &lt;bits/stdc++.h&gt;#define chl (p * 2 + 1)#define chr (p * 2 + 2)using namespace std;typedef long long ll;const int maxn = 1e5;const int maxt = 1 &lt;&lt; 18;ll floor(ll a, ll b){ if ((a &lt; 0) ^ (b &lt; 0) &amp;&amp; a % b) return a / b - 1; return a / b;}ll a[maxn];struct segtree { int ls[maxt], rs[maxt]; ll mn[maxt], mx[maxt], sum[maxt], lazy[maxt]; void pushup(int p) { sum[p] = sum[chl] + sum[chr]; mx[p] = max(mx[chl], mx[chr]); mn[p] = min(mn[chl], mn[chr]); } void pushdown(int p) { if (lazy[p]) { sum[chl] += lazy[p] * (rs[chl] - ls[chl]); sum[chr] += lazy[p] * (rs[chr] - ls[chr]); mn[chl] += lazy[p]; mn[chr] += lazy[p]; mx[chl] += lazy[p]; mx[chr] += lazy[p]; lazy[chl] += lazy[p]; lazy[chr] += lazy[p]; lazy[p] = 0; } } void build(int l, int r, int p = 0) { ls[p] = l, rs[p] = r, lazy[p] = 0; if (r - l == 1) { sum[p] = mn[p] = mx[p] = a[l]; return; } int mid = (l + r) &gt;&gt; 1; build(l, mid, chl); build(mid, r, chr); pushup(p); } void intv_add(int x, int y, ll val, int p = 0) { if (x &lt;= ls[p] &amp;&amp; rs[p] &lt;= y) { sum[p] += val * (rs[p] - ls[p]); lazy[p] += val; mn[p] += val; mx[p] += val; return; } pushdown(p); int mid = (ls[p] + rs[p]) &gt;&gt; 1; if (x &lt; mid) intv_add(x, y, val, chl); if (y &gt; mid) intv_add(x, y, val, chr); pushup(p); } void intv_div(int x, int y, ll val, int p = 0) { if (x &lt;= ls[p] &amp;&amp; rs[p] &lt;= y) { if (mn[p] == mx[p] || (mx[p] - mn[p] == 1 &amp;&amp; !(mx[p] % val))) { val = floor(mn[p], val) - mn[p]; sum[p] += val * (rs[p] - ls[p]); lazy[p] += val; mn[p] += val; mx[p] += val; return; } } pushdown(p); int mid = (ls[p] + rs[p]) &gt;&gt; 1; if (x &lt; mid) intv_div(x, y, val, chl); if (y &gt; mid) intv_div(x, y, val, chr); pushup(p); } ll query_min(int x, int y, int p = 0) { if (ls[p] == x &amp;&amp; rs[p] == y) return mn[p]; pushdown(p); int mid = (ls[p] + rs[p]) &gt;&gt; 1; if (y &lt;= mid) return query_min(x, y, chl); if (x &gt;= mid) return query_min(x, y, chr); return min(query_min(x, mid, chl), query_min(mid, y, chr)); } ll query_sum(int x, int y, int p = 0) { if (ls[p] == x &amp;&amp; rs[p] == y) return sum[p]; pushdown(p); int mid = (ls[p] + rs[p]) &gt;&gt; 1; if (y &lt;= mid) return query_sum(x, y, chl); if (x &gt;= mid) return query_sum(x, y, chr); return query_sum(x, mid, chl) + query_sum(mid, y, chr); }} seg;int main(){ int n, q; scanf(\"%d%d\", &amp;n, &amp;q); for (int i = 0; i != n; ++i) scanf(\"%lld\", &amp;a[i]); seg.build(0, n); int op, x, y; ll k; while (q--) { scanf(\"%d%d%d\", &amp;op, &amp;x, &amp;y), ++y; if (op == 1) { scanf(\"%lld\", &amp;k); seg.intv_add(x, y, k); } else if (op == 2) { scanf(\"%lld\", &amp;k); seg.intv_div(x, y, k); } else if (op == 3) { printf(\"%lld\\n\", seg.query_min(x, y)); } else { printf(\"%lld\\n\", seg.query_sum(x, y)); } }}","link":"/posts/segment-tree-lazytag/"},{"title":"线段树之基本概念","text":"本文介绍了线段树的基础知识，辅之以相关例题。 2020-03-15 修改 “什么是线段树？” 部分，存储线段树的数组大小。 基本概念部分，因为是初学，理解没有那么深入，自己总结出来可能质量不高，所以本文的前半部分基本照搬了 $\\text{SilentEAG}$ 大佬的 这篇文章（有修改），自己着重写了习题部分。 什么是线段树？首先，你得有树的基本知识。 然后。 线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树的一个结点。 百度百科线段树 很懵？没关系，我们继续。 其实，线段树(Segment Tree)是一种基于分治思想的二叉树结构，如果你学过树状数组，你会清楚地知道两者的差异性，并且随着学习的深入，你会发现线段树是一种更为通用的数据结构。 可以说，只要是能满足区间可加性（也就是大区间的信息能由它的两个子区间整理得到）的操作，大都可以用线段树解决。 最基本的线段树包含以下几个概念： 线段树每个节点表示一个区间； 线段树的唯一根节点表示整个区间统计范围，如 $[1,N]$&hairsp;； 线段树的每个叶节点表示一个长度为 $1$ 的元区间，如 $[x,x]$&hairsp;； 线段树上的每个节点 $[l,r]$，它的左子节点是 $[l,mid]$，右子节点是 $[mid+1,r]$，其中 $mid=(l+r)/2$ (这是线段树最常见的写法，也会有适用于不同问题的其它写法，不过这用于理解线段树的要义足矣）。 如图，这就是一棵线段树。我们可以发现，当整个区间统计长度为 $2$ 的整数次幂时，整棵线段树一定是一棵完全二叉树，那我们就可以用堆的编号方法来给线段树来编号啊（其实图中已经编好了）。 如果根节点编号为 $1$&hairsp;。编号为 $x$ 的节点，它的左儿子编号为 $2x$，右儿子编号为 $2x+1$&hairsp;。 这样，我们就可以用一个数组来存所有节点的编号了！ 诶等等，那万一整个区间长度不是 $2$ 的整数次幂呢？ 可以惊讶地发现，我们同样可以使用 “父子二倍标记法”。正确性显然，只不过，正是因为这种情况，所以树的最后一层节点编号在数组中的位置可能不是连续的。 如果区间长度为 $N$，在最理想的状况下，即 $N$ 是 $2$ 的整数次幂时，$N$ 个叶节点的满二叉树有 $N+N/2+N/4+\\ldots+1=2N−1$ 个节点。只要不是这种情况，那就还有一层，所以我们保存线段树节点编号的数组的长度 $T$ 要足够。实际应用时将 $N$ 补至 $2$ 的整数次幂，再乘以 $2$ 即可，实际使用时就是这样： $$\\begin{aligned}N=10^4\\to T=2^{15}\\\\N=10^5\\to T=2^{18}\\\\N=10^6\\to T=2^{21}\\end{aligned}$$ 当然，不想麻烦的话，可以直接 $T=4N$，也没有问题。 于是线段树信息储存如下： 1234struct node { int l, r; // 每个区间左右端点 int sum; // 其它区间数据，这里是区间和的例子} seg[maxn * 4]; 当然，线段树的写法多种多样，这是最稳的一种，还有一种是记录左右儿子编号的，据说叫做zkw线段树，我以后遇到了可能会补充。 建树我们需要从根节点 “$1$” 出发，向下递归建树，并把每个节点所代表的区间赋给它。当到达了根节点，便传值，再向上维护信息。 以维护区间和为例，我们可以这样建树： 12345678910111213void build(int l, int r, int p = 1){ node&amp; par = seg[p]; par.l = l, par.r = r; if (l == r) { // 叶节点赋值 par.val = par.prel = par.prer = par.sum = a[l]; return; } int mid = (l + r) / 2; build(l, mid, p * 2); // 递归建左子树 build(mid + 1, r, p * 2 + 1); // 递归建右子树 par.sum = seg[p * 2].sum + seg[p * 2 + 1].sum; // 向上传递区间和的信息} 单点修改显然，每次操作，我们都需要从根节点开始遍历，递归找到需要修改的叶子节点，然后修改，然后向上传递信息。 1234567891011121314void modify(int x, int val, int p = 1){ node&amp; par = seg[p]; if (par.l == par.r) { // 找到了要修改的位置 par.val = par.prel = par.prer = par.sum = val; return; } int mid = (par.l + par.r) / 2; if (x &lt;= mid) modify(x, val, p * 2); else modify(x, val, p * 2 + 1); par.sum = seg[p * 2].sum + seg[p * 2 + 1].sum; // 向上传递区间和的信息} 因为整棵树的深度是 $\\lceil\\log N\\rceil$，所以单次修改的时间复杂度为 $O(\\log N)$&hairsp;。 区间查询这里直接给出算法过程，正确性显然。 若当前节点所表示的区间已经被询问区间所完全覆盖，则立即回溯，并传回该点的信息； 若当前节点的左儿子所表示的区间已经被询问区间所完全覆盖，就递归访问它的左儿子； 若当前节点的右儿子所表示的区间已经被询问区间所完全覆盖，就递归访问它的右儿子。 以返回区间和为例： 12345678910111213int query(int x, int y, int p = 1){ node&amp; par = seg[p]; if (x &lt;= par.l &amp;&amp; par.r &lt;= y) return par.sum; // 对应操作1 int sum = 0; int mid = (par.l + par.r) / 2; if (mid &gt;= y) sum += query(x, y, p * 2); // 对应操作2 if (mid &lt; x) sum += query(x, y, p * 2 + 1); // 对应操作3 return sum;} 为什么使用线段树？先来对比一下普通数组和线段树，看看它们各种操作的时间复杂度。 ​ 初始化 区间查询 单节点修改 普通数组 $O(n)$ $O(n)$ $O(1)$ 线段树 $O(n)$ $O(\\log n)$ $O(\\log n)$ 可见，线段树主要是在区间查询上有速度优势，能够应对更多、范围更大的查询。但是相应地，单节点修改需要耗费很多时间。 然而，线段树很懒，懒得一个个地处理节点修改的请求。为了应对需要修改多个节点的情况，线段树有它自己的策略——“懒惰标记”，接下来会学到。 不过在这之前，先做几道练习题。 【习题】Can you answer these queries III需要你提供一种数据结构使之能够查询区间最大连续子段和，并且支持单点修改。 题解首先考虑区间的最大子段的这些情况： 连续最大和的区间只在左儿子所对应的区间上； 连续最大和的区间只在右儿子所对应的区间上； 连续最大和的区间横跨左右儿子的区间。 第 $1$ 和第 $2$ 种情况，答案就是左边部分（右边部分）的最大子段和。第 $3$ 种情况复杂一点，答案等于 左边部分从其右端开始的最大子段和 加上 右边部分从其左端开始的最大子段和。 当然，为了维护区间从其端点开始的最大子段和，还需维护区间和&hairsp;$(sum)$&hairsp;。如此，一个区间从其左端开始的最大子段和，假设左右儿子的位置分别为 $chl$ 和 $chr$，便可以如此维护： $$prel_p =\\max\\lbrace prel_{chl} , sum_{chl} + prel_{chr}\\rbrace$$ 从右端开始的最大子段和同理。 总的来说，我们要维护这几种区间信息： 区间的最大连续子段和&hairsp;$(val)$ 区间和&hairsp;$(sum)$ 区间从其左端开始的最大子段和&hairsp;$(prel)$ 区间从其左端开始的最大子段和&hairsp;$(prer)$ 接下来是查询部分，一开始当然是在根节点查询所给的区间。在每个节点处的查询又可以分为三种情况处理： 所查询的区间刚好是该节点的区间，则直接返回该区间； 所查询的区间全部在该节点区间的左半部分，则返回该节点左儿子查询该区间的结果； 所查询的区间全部在该节点区间的右半部分，则返回该节点右儿子查询该区间的结果； 所查询的区间横跨该节点区间的中间，则将所查询的区间根据该节点区间的中点分为左右两部分，分别让该节点的左儿子和右儿子查询这两个区间，并将查询结果 “合并” 后返回。 所谓 “合并” 的操作其实就是建树时，子节点向上传播信息的操作，我们可以复用这段代码，也就是下方参考代码中的 pushup 函数。 参考代码can-you-answer-these-queries.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;constexpr int maxn = 50007;struct node { int l, r; ll prel, prer, val, sum;} seg[maxn * 4];ll a[maxn];void pushup(node&amp; par, const node&amp; lson, const node&amp; rson){ par.prel = max(lson.prel, lson.sum + rson.prel); par.prer = max(rson.prer, rson.sum + lson.prer); par.val = max(max(lson.val, rson.val), lson.prer + rson.prel); par.sum = lson.sum + rson.sum;}void build(int l, int r, int p = 1){ node&amp; par = seg[p]; par.l = l, par.r = r; if (l == r) { par.val = par.prel = par.prer = par.sum = a[l]; return; } int mid = (l + r) / 2; build(l, mid, p * 2); build(mid + 1, r, p * 2 + 1); pushup(par, seg[p * 2], seg[p * 2 + 1]);}void modify(int x, int val, int p = 1){ node&amp; par = seg[p]; if (par.l == par.r) { par.val = par.prel = par.prer = par.sum = val; return; } int mid = (par.l + par.r) / 2; if (x &lt;= mid) modify(x, val, p * 2); else modify(x, val, p * 2 + 1); pushup(par, seg[p * 2], seg[p * 2 + 1]);}node query(int x, int y, int p = 1){ node&amp; par = seg[p]; if (x == par.l &amp;&amp; y == par.r) return par; int mid = (par.l + par.r) / 2; if (mid &gt;= y) return query(x, y, p * 2); if (mid &lt; x) return query(x, y, p * 2 + 1); node res; pushup(res, query(x, mid, p * 2), query(mid + 1, y, p * 2 + 1)); return res;}int main(){ int n, q, op, x, y; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%lld\", &amp;a[i]); build(1, n); for (scanf(\"%d\", &amp;q); q--;) { scanf(\"%d%d%d\", &amp;op, &amp;x, &amp;y); if (op) printf(\"%lld\\n\", query(x, y).val); else modify(x, y); }} 【习题】Crane有一台起重机。起重机可以看成由 $N$ 条线段首尾相接而成。第 $i$ 条线段的长度是 $L_i$&hairsp;。最开始，所有的线段都笔直连接，指向上方。 有 $C$ 条操纵起重机的指令。指令 $i$ 给出两个整数 $S_i$ 和 $A_i$，效果是使线段 $S_i$ 和 $S_{i+1}$ 之间的角度变成 $A_i$ 度。其中角度指的是从线段 $S_i$ 开始沿逆时针方向旋转到 $S_{i+1}$ 所经过的角度。最开始所有的角度都是 $180$ 度。 按顺序执行这 $C$ 条指令，在每条执行后，输出起重机末端（第 $N$ 条线段的端点）的坐标。假设起重机支点的坐标是 $(0,0)$&hairsp;。 题解这是在白书上看到的题目，思维难度比较高。花了两天时间才搞懂，我还是太菜了。思路是运用分治的思想，将整个起重机逐次二分为小区间，用线段树解决。每个节点代表一段连续的线段的集合，并维护这两个值： 将节点左子节点的向量所指的方向作为竖直向上的正方向后，从该节点左子节点的向量起点指向该节点右子节点的向量终点的向量； 将节点的左右子节点的向量拼接后，右子节点的向量需要旋转的角度。 第一个值容易维护，如果节点 $p$ 表示的向量是 $(x_p,y_p)$，角度是 $ang_p$，两个儿子节点分别是 $chl$ 和 $chr$，则有： $$\\begin{aligned}x_p=x_{chl}+(\\cos(ang_p)\\times x_{chr}-\\sin(ang_p)\\times y_{chr})\\\\y_p=y_{chl}+(\\sin(ang_p)\\times x_{chr}+\\cos(ang_p)\\times y_{chr})\\end{aligned}$$ 比较难维护的是第二个值，旋转角度。我随手画了个图方便理解。 这张图是 $N=8$ 时的两种情况，左图是将第 $5$ 节变为 $90$ 度，右图是将 $2$ 节变为 $90$ 度。每个带方向的箭头都是某个节点所对应的向量。其中标记黑点的代表需要更新角度值，标记圆圈的代表需要更新向量值。 可以发现： 区间长度为 $1$ 的节点不需要更新角度值和向量值； 若某个节点所对应的区间包含要改变角度的位置 $(l_p &lt; pos &lt; r_p)$，则需要更新其向量值； 若某个节点需要更新向量值，且其右子节点没有更新角度值，则需要更新其角度值。 这样，每次更新便可以在 $O(\\log n)$ 时间内完成，而根节点所对应向量的值就是要输出的结果。 参考代码crane.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;cmath&gt;#include &lt;cstdio&gt;#define chl (p * 2 + 1)#define chr (p * 2 + 2)const int maxn = 10007;const double pi = acos(-1.0);struct node { int l, r; double x, y, ang;} seg[maxn * 4];double prv[maxn], len[maxn];void build(int l, int r, int p = 0){ node&amp; par = seg[p]; par.l = l, par.r = r, par.x = par.ang = 0.0; if (r - l == 1) { par.y = len[l]; return; } int mid = (l + r) / 2; build(l, mid, chl); build(mid, r, chr); // 默认方向是朝上，只需更新纵坐标 par.y = seg[chl].y + seg[chr].y;}void modify(int pos, double delta, int p = 0){ node&amp; par = seg[p]; if (pos &lt;= par.l || pos &gt;= par.r) return; // 若要旋转的位置是该节点区间的端点，甚至不在节点区间内，则没有任何影响 modify(pos, delta, chl); modify(pos, delta, chr); if (pos &lt;= (par.l + par.r) / 2) par.ang += delta; // 若右子节点没有被更新，需要将其向量旋转 double s = sin(par.ang), c = cos(par.ang); // 将左右子节点的向量拼接，更新本节点 par.x = seg[chl].x + (c * seg[chr].x - s * seg[chr].y); par.y = seg[chl].y + (s * seg[chr].x + c * seg[chr].y);}int main(){ int m, n, cnt = 0; while (scanf(\"%d%d\", &amp;m, &amp;n) != EOF) { if (cnt++) puts(\"\"); for (int i = 1; i != m; ++i) prv[i] = pi; // 初始方向为上方 for (int i = 0; i != m; ++i) scanf(\"%lf\", &amp;len[i]); build(0, m); for (int pos, deg; n--;) { scanf(\"%d%d\", &amp;pos, &amp;deg); // 利用prv数组，算出角度的变化值，单位是弧度 double rad = (double)deg / 180.0 * pi; modify(pos, rad - prv[pos]); prv[pos] = rad; printf(\"%.2f %.2f\\n\", seg[0].x, seg[0].y); } }}","link":"/posts/segment-tree/"},{"title":"“滑动窗口” 的优先队列解法","text":"题目链接：POJ2823 - Sliding Window 按顺序输出一个序列中每个固定大小的区间里的最值。这题可以用线段树解决，但不如用单调队列效率高。 题目描述给你一个长度为 $n\\leq10^6$ 的序列。有一个大小为 $k$ 的窗口正从序列的最左边滑向最右边，你只能看到窗口中的 $k$ 个数。每过单位时间，窗口就向右平移一个单位。这里举一个序列为 [1 3 -1 -3 5 3 6 7]，$k=3$ 的例子。 窗口位置 最小值 最大值 [$1$&nbsp;&nbsp;$3$&nbsp;&nbsp;$-1$]&nbsp;$-3$&nbsp;&nbsp;$5$&nbsp;&nbsp;$3$&nbsp;&nbsp;$6$&nbsp;&nbsp;$7$&nbsp; $-1$ $3$ &nbsp;$1$&nbsp;[$3$&nbsp;&nbsp;$-1$&nbsp;&nbsp;$-3$]&nbsp;$5$&nbsp;&nbsp;$3$&nbsp;&nbsp;$6$&nbsp;&nbsp;$7$&nbsp; $-3$ $3$ &nbsp;$1$&nbsp;&nbsp;$3$&nbsp;[$-1$&nbsp;&nbsp;$-3$&nbsp;&nbsp;$5$]&nbsp;$3$&nbsp;&nbsp;$6$&nbsp;&nbsp;$7$&nbsp; $-3$ $5$ &nbsp;$1$&nbsp;&nbsp;$3$&nbsp;&nbsp;$-1$&nbsp;[$-3$&nbsp;&nbsp;$5$&nbsp;&nbsp;$3$]&nbsp;$6$&nbsp;&nbsp;$7$&nbsp; $-3$ $5$ &nbsp;$1$&nbsp;&nbsp;$3$&nbsp;&nbsp;$-1$&nbsp;&nbsp;$-3$&nbsp;[$5$&nbsp;&nbsp;$3$&nbsp;&nbsp;$6$]&nbsp;$7$&nbsp; $3$ $6$ &nbsp;$1$&nbsp;&nbsp;$3$&nbsp;&nbsp;$-1$&nbsp;&nbsp;$-3$&nbsp;&nbsp;$5$&nbsp;[$3$&nbsp;&nbsp;$6$&nbsp;&nbsp;$7$] $3$ $7$ 你需要找出每一个位置时，窗口中的最大数和最小数，并按顺序输出。 题解这道题，图省事的话，套个线段树的板子就好（没看出来哪里省事了）。建两棵线段树，一棵用于查询区间最小值，另一棵用于查询区间最大值。 分析一下线段树的效率，建树时间为 $O(n)$，单次查询时间为 $O(\\log n)$&hairsp;；又一共有 $2(n-k+1)$ 次查询，所以总体时间复杂度大约为 $O(n\\log n)$&hairsp;。这对于所给数据来说很可能会超时，所以考虑使用单调队列来解决。 单调队列具有队列内所有元素单调递增或者单调递减的性质，所以队列中的最小（最大）值一定出现在队首。 为了维护单调队列，在插入元素 $a_i$ 时需要进行以下操作（以队首为最大值举例）： 判断队首元素是否超出窗口范围，若是，将其弹出队列； 将队尾所有小于 $a_i$ 的元素全部弹出队列； 将 $a_i$ 从队尾入队。 解决这道题，先将前 $k$ 个元素按规则入队，之后每插入一个元素前都输出队首，便得到了题目要求的结果。 需要注意，为了判断队首元素是否在窗口范围内，需要保存元素在序列中的位置（代码中的 $pos$ 数组）。 最后，记得这个，创建并维护一个单调队列并不一定真的得用标准库的 deque&lt;int&gt;，并且用其 push_back 等方法进行操作（大常数选手飘过）。我试过，大概有一个 $2$ 的常数在它前面，在解决这题时效率甚至不及线段树解法。 完全可以用一个数组模拟双向队列，用 $l$ 和 $r$ 记录队列在数组中的范围。这样，例如弹出队尾元素的操作，仅仅用 --r 就可以完成了。只要确保数组开得足够大，并且操作过程中 $l$ 不会小于 $0$ 即可。 参考代码 (Monotonic Queue)MQ.cpp123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#define maxn 1000007int val[maxn], pos[maxn], a[maxn];int n, k;inline bool greater(int a, int b) { return a &gt; b; }inline bool less(int a, int b) { return a &lt; b; }void solve(bool (*func)(int, int)){ int l = 0, r = 0; for (int i = 0; i != k; ++i) { while (l != r &amp;&amp; func(a[i], val[r - 1])) --r; val[r] = a[i], pos[r++] = i; } for (int i = k; i != n; ++i) { printf(\"%d \", val[l]); if (l != r &amp;&amp; pos[l] + k &lt;= i) ++l; while (l != r &amp;&amp; func(a[i], val[r - 1])) --r; val[r] = a[i], pos[r++] = i; } printf(\"%d\\n\", val[l]);}int main(){ scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 0; i != n; ++i) scanf(\"%d\", &amp;a[i]); solve(less); solve(greater);} 参考代码 (Segment Tree)线段树版本的代码过于丑陋了，所以把它放在了后面。 ST.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;algorithm&gt;#include &lt;cstdio&gt;#define maxn 1000007#define chl (p * 2 + 1)#define chr (p * 2 + 2)int a[maxn];int m_max[maxn * 4], m_min[maxn * 4];void build(int l, int r, int p = 0){ if (r - l == 1) { m_max[p] = m_min[p] = a[l]; return; } int mid = (l + r) / 2; build(l, mid, chl); build(mid, r, chr); m_max[p] = std::max(m_max[chl], m_max[chr]); m_min[p] = std::min(m_min[chl], m_min[chr]);}int query_min(int x, int y, int l, int r, int p = 0){ if (l == x &amp;&amp; r == y) return m_min[p]; int mid = (l + r) / 2; if (y &lt;= mid) return query_min(x, y, l, mid, chl); if (x &gt;= mid) return query_min(x, y, mid, r, chr); return std::min(query_min(x, mid, l, mid, chl), query_min(mid, y, mid, r, chr));}int query_max(int x, int y, int l, int r, int p = 0){ if (l == x &amp;&amp; r == y) return m_max[p]; int mid = (l + r) / 2; if (y &lt;= mid) return query_max(x, y, l, mid, chl); if (x &gt;= mid) return query_max(x, y, mid, r, chr); return std::max(query_max(x, mid, l, mid, chl), query_max(mid, y, mid, r, chr));}int main(){ int n, k; scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 0; i != n; ++i) scanf(\"%d\", &amp;a[i]); build(0, n); for (int i = 0; i + k &lt;= n; ++i) printf(\"%d \", query_min(i, i + k, 0, n)); puts(\"\"); for (int i = 0; i + k &lt;= n; ++i) printf(\"%d \", query_max(i, i + k, 0, n)); puts(\"\");}","link":"/posts/sliding-window/"},{"title":"稀疏表及其应用","text":"本文介绍了稀疏表的基本用法，以及如何在相关习题中应用它。 本文的简介部分主要参照了 $\\text{OI WiKi}$ 的这篇文章。$\\text{OI WiKi}$ 整合了各类有关编程竞赛的实用知识，感谢贡献者们！ 为什么使用稀疏表？稀疏表是用于解决 “可重复贡献问题” 的数据结构，什么是 “可重复贡献问题”？ 若一个运算 ${\\rm op}$ 满足 $x\\,{\\rm op}\\,x=x$，则其对应的区间查询就是 “可重复贡献问题”。例如，最大值有 $\\max(x,x)=x$，所以 RMQ 是这类问题；最大公约数有 $\\gcd(x,x)=x$，区间最大公约数也是这类问题。区间和就不具备这个性质，如果求区间和所采用的区间有重叠，重叠部分就会被计算两次，这是我们不希望看到的。 另外，除了 RMQ、区间最大公约数以外，区间按位与、区间按位或等问题，都能够用稀疏表高效解决。这些问题都有着某种相似之处，例如区间按位与，就是每一位都取最小值；区间按位或，就是每一位都取最大值。 类似的解决这类问题的工具还有线段树。虽然稀疏表不支持修改操作，但是其查询时间被降至常数，在处理有大量询问的问题时十分有效。 ​ 初始化 区间查询 单节点修改 线段树 $O(n)$ $O(\\log n)$ $O(\\log n)$ 稀疏表 $O(n\\log n)$ $O(1)$ 不可 如何使用稀疏表？稀疏表使用 $O(n\\log n)$ 的时间，预处理出一张二维的表格 $f(i,j)$&hairsp;。接下来以区间最大值为例，$f(i,j)$ 的含义为 “区间 $[i,i+2^j)$ 上的最大值”。 假设原数列为 $a$，显然有 $f(i,0)=a_i$&hairsp;。之后使用状态转移方程 $f(i,j)=\\max\\lbrace f(i,j-1),f(i+2^{j-1},j-1)\\rbrace$ 填充完整张表格即可完成预处理。 若要查询区间 $[l,r)$ 上的最大值，返回 $\\max\\lbrace f(l,s),f(r-2^s,s)\\rbrace$ 即可，其中 $s=\\lfloor\\log_2(r-l)\\rfloor$&hairsp;。 【习题】Balanced Lineup给出一个序列，每次询问要求回答出某个区间中最大值和最小值之差。 题解模板题，需要维护两张稀疏表，一张用于查询区间最大值，另一张用于查询区间最小值。查询后相减得到答案。 参考代码P2880.cpp123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 50001;const int lg2maxn = 16;int f[maxn][lg2maxn][2], lg2[maxn];int main(){ int n, q, l, r; scanf(\"%d%d\", &amp;n, &amp;q); for (int i = 2; i &lt;= n; ++i) lg2[i] = lg2[i &gt;&gt; 1] + 1; for (int i = 0; i != n; ++i) scanf(\"%d\", &amp;f[i][0][0]), f[i][0][1] = f[i][0][0]; for (int j = 1; j &lt;= lg2[n]; ++j) for (int i = n - (1 &lt;&lt; j); i != -1; --i) f[i][j][0] = min(f[i][j - 1][0], f[i + (1 &lt;&lt; (j - 1))][j - 1][0]); for (int j = 1; j &lt;= lg2[n]; ++j) for (int i = n - (1 &lt;&lt; j); i != -1; --i) f[i][j][1] = max(f[i][j - 1][1], f[i + (1 &lt;&lt; (j - 1))][j - 1][1]); while (q--) { scanf(\"%d%d\", &amp;l, &amp;r), --l; int s = lg2[r - l]; printf(\"%d\\n\", max(f[l][s][1], f[r - (1 &lt;&lt; s)][s][1]) - min(f[l][s][0], f[r - (1 &lt;&lt; s)][s][0])); }} 【习题】降雨量“$X$ 年是自 $Y$ 年以来降雨量最多的”，它的含义是 $X$ 年的降雨量不超过 $Y$ 年，且对于任意 $Y\\lt Z\\lt X$，$Z$ 年的降雨量严格小于 $X$ 年。给出两个年份，判断 “$X$ 年是自 $Y$ 年以来降雨量最多的” 这句话是否正确。由于有些年份的降雨量未知，有的说法是可能正确也可以不正确的。 题解这题中稀疏表的地位很明确——只是个小工具，用于查询 $X$ 和 $Y$ 年之间的最大降雨量。这题的重头戏在于有些年份的降雨量是未知的，所以回答可能是 “无法判断”。 代码中的关键点、我曾经忘记考虑的点，都补上了注释，便于查看。 参考代码LOJ2279.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 50001;const int lg2maxn = 16;int n, q;int key[maxn], val[maxn], f[maxn][lg2maxn], lg2[maxn];int intvmax(int x, int y){ if (x &gt;= y) return -1; int s = lg2[y - x]; return max(f[x][s], f[y - (1 &lt;&lt; s)][s]);}int judge(int x, int y){ int ix = lower_bound(key, key + n, x) - key, iy = lower_bound(key, key + n, y) - key; if (key[ix] == x) { // x年的降雨量有记录 int q = intvmax(ix + 1, iy); if (key[iy] == y) { // y年的降雨量有记录 if (val[iy] &gt; val[ix]) return -1; // y年的降雨量多于x年，则至少得 “自(x-1)年以来……” 才正确 if (val[iy] &gt; q) { if (iy - ix == y - x) // 之间所有年份的降雨量都已知 return 1; return 0; } return -1; } if (val[ix] &gt; q) // x年的降雨量至少要比中间多才可能正确 return 0; return -1; } if (key[iy] == y) { if (iy &lt;= ix) // 之间所有年份的降雨量都未知 return 0; int q = intvmax(ix, iy); if (val[iy] &gt; q) return 0; return -1; } return 0;}int main(){ scanf(\"%d\", &amp;n); for (int i = 2; i &lt;= n; ++i) lg2[i] = lg2[i &gt;&gt; 1] + 1; for (int i = 0; i != n; ++i) scanf(\"%d%d\", &amp;key[i], &amp;val[i]), f[i][0] = val[i]; for (int j = 1; j &lt;= lg2[n]; ++j) for (int i = n - (1 &lt;&lt; j); i != -1; --i) f[i][j] = max(f[i][j - 1], f[i + (1 &lt;&lt; (j - 1))][j - 1]); scanf(\"%d\", &amp;q); int x, y; while (q--) { scanf(\"%d%d\", &amp;x, &amp;y); int flag = judge(x, y); if (flag == 1) puts(\"true\"); else if (flag == 0) puts(\"maybe\"); else puts(\"false\"); }}","link":"/posts/sparse-table/"},{"title":"“十字翻转棋问题” 的解法","text":"十字翻转棋问题有更巧妙的解法吗？线性代数带给我们不少启发。 题目描述“传火” 这个游戏，需要点燃 $16$ 个火堆。每个火堆可以处于以下两种状态之一：点燃或熄灭。这 $16$ 个火堆可以表示为一个 $4\\times4$ 的方阵，可以对任何一个位置上的火堆进行 “切换”。例如，对 $[i,j]$ 位置的火堆进行切换，会使得第 $i$ 行和第 $j$ 列上的所有火堆的状态也随着改变。要求最终所有的火堆都被点亮。 输入格式输入一共包含 $4$ 行，每行包含 $4$ 个火堆的初始状态。符号 “+” 表示火堆处于熄灭状态，而符号 “-” 表示火堆处于燃烧状态。输入数据保证至少一个火堆的初始状态是熄灭的。 输出格式第一行输出一个整数 $N$，表示所需的最少切换次数。接下来 $N$ 行描述切换顺序，每行输入两个整数，代表被切换状态的火堆的行号和列号，数字之间用空格隔开。切换动作按照整体从上到下、同行从左到右的顺序输出。 样例输入样例 1234+++-+--++--+-+++ 输出样例 12321 14 4 思路与题解最直接的思路当然是递归枚举所有可能的切换方式了。先枚举只切换一次的 $16$ 种情况，再枚举切换两次的 $15\\times15$ 种情况，以此类推。 由此看来，这样做效率十分低下。假设最少切换次数是 $12$，运算量也可以达到 $10^9$ 数量级，根本无法应对需要更多切换次数的情况。 所以我们引入如下方法，首先给这 $16$ 个火堆编号： $$\\begin{array}{|c|c|c|c|}\\hline1&amp;2&amp;3&amp;4\\\\\\hline5&amp;6&amp;7&amp;8\\\\\\hline9&amp;10&amp;11&amp;12\\\\\\hline13&amp;14&amp;15&amp;16\\\\\\hline\\end{array}$$ 用 $b_i$ 表示第 $i$ 个火堆的状态，$b_i$ 取值 $1$ 为熄灭状态，取值 $0$ 为燃烧状态。样例中，$b$ 就可以如此表示为如下的 “状态向量”： $$b=(1,1,1,0,1,0,0,1,1,0,0,1,0,1,1,1)^{\\rm T}$$ 接下来定义向量 $x$，用 $x_i$ 表示是否需要对第 $i$ 个火堆进行切换，是为 $1$，不是为 $0$&hairsp;。我们发现，火堆状态的切换可以用异或运算来表示；又由于火堆最终都将处于熄灭状态，我们可以对第一个火堆列出方程，并化简： $$b_1\\oplus x_1\\oplus x_2\\oplus x_3\\oplus x_4\\oplus x_5\\oplus x_9\\oplus x_{13} = 0$$ $$x_1\\oplus x_2\\oplus x_3\\oplus x_4\\oplus x_5\\oplus x_9\\oplus x_{13} = b_1$$ 类似地，可以对第 $2,3,\\ldots,16$ 个火堆列出方程，并组成方程组： $$\\begin{cases}x_1\\oplus x_2\\oplus x_3\\oplus x_4\\oplus x_5\\oplus x_9\\oplus x_{13}&amp;=&amp;b_1\\\\x_1\\oplus x_2\\oplus x_3\\oplus x_4\\oplus x_6\\oplus x_{10}\\oplus x_{14}&amp;=&amp;b_2\\\\\\qquad\\qquad\\cdots\\\\x_4\\oplus x_8\\oplus x_{12}\\oplus x_{13}\\oplus x_{14}\\oplus x_{15}\\oplus x_{16}&amp;=&amp;b_{16}\\end{cases}$$ 于是，求解哪些火堆需要切换的问题则转化为了求解方程组的问题。 到了这一步，你的线性代数知识是否已被唤起？这里不再是线性方程组，而将线性方程中的加法换为异或，变为了 “异或方程组”，同样可以化为矩阵形式： $$Ax=b\\quad\\Leftrightarrow\\quad\\left[\\begin{array}{c}\\textcolor{red}{1}\\,\\textcolor{red}{1}\\,\\textcolor{red}{1}\\,\\textcolor{red}{1}\\,\\textcolor{red}{1}\\,0\\,0\\,0\\,\\textcolor{red}{1}\\,0\\,0\\,0\\,\\textcolor{red}{1}\\,0\\,0\\,0\\\\\\textcolor{red}{1}\\,\\textcolor{red}{1}\\,\\textcolor{red}{1}\\,\\textcolor{red}{1}\\,0\\,\\textcolor{red}{1}\\,0\\,0\\,0\\,\\textcolor{red}{1}\\,0\\,0\\,0\\,\\textcolor{red}{1}\\,0\\,0\\\\\\cdots\\;\\text{another 13 lines}\\;\\cdots\\\\0\\,0\\,0\\,\\textcolor{red}{1}\\,0\\,0\\,0\\,\\textcolor{red}{1}\\,0\\,0\\,0\\,\\textcolor{red}{1}\\,\\textcolor{red}{1}\\,\\textcolor{red}{1}\\,\\textcolor{red}{1}\\,\\textcolor{red}{1}\\end{array}\\right]x=b$$ 利用高斯消元法，对增广矩阵 $[A|b]$ 进行初等行变换（只包括行之间的异或运算），直到矩阵 A$ 化为单位矩阵；而变换后的状态向量 $b$ 便成了我们需要求解的 $x$ 向量。 最后根据向量 $x$，按顺序输出即可。 如此，$4\\times4$ 的 “传火” 问题，甚至是 $m\\times n$ 的十字翻转棋问题，便能在 $O((mn)^2)$ 的时间复杂度下解决了。 参考代码solution.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;array&gt;#include &lt;bitset&gt;#include &lt;cstdio&gt;using namespace std;void solve(bitset&lt;16&gt;&amp; x){ // generate matrix A array&lt;bitset&lt;16&gt;, 16&gt; A; for (int i = 0; i != 4; ++i) for (int j = 0; j != 4; ++j) for (int k = 0; k != 4; ++k) { A[i * 4 + j].set(i * 4 + k); A[i * 4 + j].set(k * 4 + j); } for (int i = 0; i != 15; ++i) { // if A[i][i] is not a pivot // swap row i with the first row which has a pivot if (!A[i][i]) for (int j = i + 1; j != 16; ++j) if (A[j][i]) { swap(A[j], A[i]); bool tmp = x[j]; x[j] = x[i]; x[i] = tmp; break; } // eliminate for (int j = i + 1; j != 16; ++j) if (A[j][i]) { A[j] ^= A[i]; x[j] = x[j] ^ x[i]; } } // eliminate for (int i = 15; i != 0; --i) for (int j = i - 1; j &gt;= 0; --j) if (A[j][i]) { A[j] ^= A[i]; x[j] = x[j] ^ x[i]; }}int main(){ bitset&lt;16&gt; x; for (int i = 0; i != 4; ++i) { for (int j = 0; j != 4; ++j) if (getchar() == '+') x.set(i * 4 + j); getchar(); } solve(x); printf(\"%ld\\n\", x.count()); for (int i = 0; i != 16; ++i) if (x[i]) printf(\"%d %d\\n\", (i / 4) + 1, (i % 4) + 1);}","link":"/posts/the-cross-flip-game/"},{"title":"DAG的拓扑顺序与深度优先搜索","text":"刷 AtCoder 动态规划专题时，卡在了G题上面，大概是因为不熟悉拓扑顺序。 所以这篇文章将探讨有向无环图中的拓扑顺序与深度优先搜索算法。 定义In computer science, a topological sort or topological ordering of a directed graph is a linear ordering of its vertices such that for every directed edge uv from vertex u to vertex v, u comes before v in the ordering. WikipediaTopological sorting 拓扑排序，是将一个有向无环图中所有顶点排成一个线性序列，使得图中任意一条边 $\\langle u,v\\rangle$ 都满足 $u$ 在线性序列中出现在 $v$ 之前。 算法常见的实现算法有这两种，更常见的是第一种，它更符合直观理解。 Kahn’s algorithm简单来说，首先创建一个列表用于存储排序后的顶点。找到一个没有出度的顶点，将其放入列表的最后，切断以该顶点为起点的所有边，再去找没有出度的点，并一直重复这些过程直至所有顶点都已加入列表（如果没有全部加入列表却找不出没有出度的顶点了，这张图一定是有环图）。 示例代码Kahn.cpp123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int MAXN = 1e5 + 7;int cnt[MAXN]; // cnt[v] means the number of edges end with vvector&lt;int&gt; from[MAXN]; // to[v] stores ends of edges starting from int result[MAXN], idx;bool vis[MAXN]; // wether a vertx is already in the result listint main(){ int n, m; // n for vertices, m for edges scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 0; i != m; ++i) { int u, v; // an edge from u to v scanf(\"%d%d\", &amp;u, &amp;v); from[u].push_back(v); ++cnt[v]; } while (idx != n) { bool flag = true; for (int i = 1; i &lt;= n; ++i) { if (!vis[i] &amp;&amp; !cnt[i]) { flag = false; vis[i] = true; result[idx++] = i; for (int j : from[i]) --cnt[j]; } } if (flag) // finding no vertex with no predecessor puts(\"Not a DAG (cyclic graph).\"), exit(0); } // print vertices out in topological order printf(\"%d\", result[0]); for (int i = 1; i != n; ++i) printf(\" %d\", result[i]); puts(\"\");} Depth-first search另一种算法使用了深度优先搜索。随意抽取一个未被造访的点进行深度优先搜索，搜索到 “叶子顶点”（只有入度没有出度的顶点）后将其加入搜索结果。深度优先搜索的过程中如果重复遇到同一个顶点，则该图不是 DAG（有回环）。 这里的深度优先搜索的目的是探索叶子顶点，探索完成后才会将顶点标上已造访的标记。为了判断是否重复遇到同一个顶点，需要使用另一个 “临时标记”，沿途记录某个顶点是否已被造访，并在一次探索完成后删除。要注意与判断该顶点是否已被造访的 “永久标记” 进行区分。 示例代码Depth-first-search.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int MAXN = 1e5 + 7;vector&lt;int&gt; from[MAXN]; // to[v] stores ends of edges starting from vint result[MAXN], idx;bool perm[MAXN], temp[MAXN]; // permanent mark and temporary markvoid dfs(int u){ if (temp[u]) puts(\"Not a DAG (cyclic graph).\"), exit(0); temp[u] = true; for (int v : from[u]) if (!perm[v]) dfs(v); temp[u] = false; perm[u] = true; // mind that recursion means deferred operations // that's why we have to do insertions from back to front result[--idx] = u;}int main(){ int n, m; // n for vertices, m for edges scanf(\"%d%d\", &amp;n, &amp;m); idx = n; for (int i = 0; i != m; ++i) { int u, v; // an edge from u to v scanf(\"%d%d\", &amp;u, &amp;v); from[u].push_back(v); } while (idx) for (int i = 1; i &lt;= n; ++i) if (!perm[i]) dfs(i); // print vertices out in topological order printf(\"%d\", result[0]); for (int i = 1; i != n; ++i) printf(\" %d\", result[i]); puts(\"\");} 应用这里就用 AtCoder 动态规划专题的 G 题来举例。 题目链接：AtCoder Educational DP Contest - G - Longest Path 题意给出一张有向无环图，每条边的长度都是 $1$，求出图中最长路径的长度。 将前面的深度优先搜索算法改一改，除去 “临时标记”，并且在回溯过程中记下以某顶点为起点的最长路径长度&hairsp;$(dp_i)$&hairsp;。 为什么这与拓扑序有关？深度优先搜索的顺序其实就是拓扑序，先被访问的顶点不会再被访问。所以沿途记录下的最长路径长度，确定后便不再改变。基于先前的的计算结果，按照一定的顺序和规则不断更新，这也是使用动态规划的理由。 示例代码G.cpp12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int MAXN = 1e5 + 7;vector&lt;int&gt; from[MAXN];int dp[MAXN];int ans;void dfs(int u){ if (dp[u]) return; for (int v : from[u]) { dfs(v); dp[u] = max(dp[u], 1 + dp[v]); } if (dp[u] &gt; ans) ans = dp[u];}int main(){ int n, m; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 0; i != m; ++i) { int u, v; scanf(\"%d%d\", &amp;u, &amp;v); from[u].push_back(v); } for (int i = 1; i &lt;= n; ++i) if (!dp[i]) dfs(i); printf(\"%d\\n\", ans);}","link":"/posts/topological-order-and-depth-first-searching/"},{"title":"新增Valine评论系统","text":"给博客添加了评论系统 Valine，支持 Markdown 写作和 Gravatar 头像。 当然，博客本身的内容更重要，可是谁不喜欢折腾呢……","link":"/posts/valine-comment-system/"},{"title":"Concrete Mathematics Notes","text":"I have finished reading the second chapter of Concrete Mathematics. Here are my notes on the book and solutions to the exercises.","link":"/redirect/concrete-mathematics/"},{"title":"Miller–Rabin 素性测试","text":"整理了 Miller–Rabin 素性测试的原理及实现方法。 为了探究一奇数 $n&gt;1$ 是否为素数，将其用 $e$ 和 $k$ 来表示，使得 $n-1=2^ek$，其中 $k$ 为奇数。 根据 Keith Conrad [1] 的推导，多项式 $x^{n-1}-1=x^{2^ek}-1$ 可以被分解，直到指数不是 $2$ 的倍数： $$\\begin{aligned}x^{n-1}-1&amp;=x^{2^ek}-1\\\\&amp;=(x^{2^{e-1}k}-1)(x^{2^{e-1}k}+1)\\\\&amp;=(x^{2^{e-2}k}-1)(x^{2^{e-2}k}+1)(x^{2^{e-1}k}+1)\\\\&amp;\\;\\;\\vdots\\\\&amp;=(x^k-1)(x^k+1)(x^{2k}+1)(x^{4k}+1)\\cdots(x^{2^{e-1}k}+1)\\end{aligned}$$ 若 $n$ 为素数，且 $1\\leq a\\leq n-1$，那么根据费马小定理，可知 $a^{n-1}-1\\equiv0\\;({\\rm mod}\\;n)$，再根据上式的分解过程，可以得出 $$(a^k-1)(a^k+1)(a^{2k}+1)(a^{4k}+1)\\cdots(a^{2^{e-1}k}+1)\\equiv0\\;({\\rm mod}\\;n)$$ 所以上式中的某一项必须等于 $0\\;({\\rm mod}\\;n)$，也就是 $$a^k\\equiv1\\;({\\rm mod}\\;n)\\;\\text{or}\\;a^{2^ik}\\equiv-1\\;({\\rm mod}\\;n)\\;\\text{for some}\\;i\\in\\lbrace0,\\ldots,n-1\\rbrace$$ 像 Fermat test&hairsp;、Miller–Rabin test 等基于概率的素性测试算法，目的是找出能够证明 $n$ 是合数的证据。若找不到这样的证据，那么 $n$ 很可能是素数。用这类方法找出的素数称为伪素数&hairsp;(pseudo prime)&hairsp;。 对于一个奇数 $n&gt;1$，在 $\\lbrace1,\\ldots,n-1\\rbrace$ 中取一整数 $a$，如果某个 $a$ 使上式不成立，也就是 $$a^k\\not\\equiv1\\;({\\rm mod}\\;n)\\;\\text{and}\\;a^{2^ik}\\not\\equiv-1\\;({\\rm mod}\\;n)\\;\\text{for all}\\;i\\in\\lbrace0,\\ldots,n-1\\rbrace\\quad(*)$$ 那么称这个 $a$ 为一个 Miller–Rabin witness&hairsp;，在素性测试中，术语 “witness” 意为某个能够证明 $n$ 为合数的数。 可以证明 [1]，若一奇数是合数，那么 $\\lbrace2,\\ldots,n-2\\rbrace$ 中超过 $75\\%$ 的数都是 Miller–Rabin witness&hairsp;。所以经过 $k$ 轮的随机检测，该算法判断某个数是素数时，它有概率至少为 $(1-4^{-k})$ 的把握。 我在 SICP 的 练习 1.28 中用 Scheme 实现了该素性测试，其中用非平凡平方根&hairsp;(nontrivial square root) 的概念巧妙地找出了 Miller–Rabin witness，关键点是修改后的 expmod 过程，在本来执行 square 的地方加入了检测非平凡平方根的过程。 我也用 C++ 实现了一遍，当然不再是递归版的，思考方式变化极大，不过更加直接地体现了 $(*)$ 式。 Miller-Rabin.cpp12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll expmod(ll base, ll ex, ll mod){ ll ans = 1, x = base; while (ex) { if (ex &amp; 1) ans = (ans * x) % mod; x = (x * x) % mod; ex &gt;&gt;= 1; } return ans;}bool miller_rabin(ll n, int rounds){ ll k = n - 1, e = 0; while (!(k &amp; 1)) k &gt;&gt;= 1, ++e; while (rounds--) { ll a = (rand() % (n - 1)) + 1, b = expmod(a, k, n); if (b == 1 || b == n - 1) continue; bool composite = true; for (int i = 1; composite &amp;&amp; i &lt; e; ++i) if ((b = (b * b) % n) == n - 1) composite = false; if (composite) return false; } return true;} References [1] Keith Conrad, “The Miller–Rabin Test,” https://kconrad.math.uconn.edu/blurbs/ugradnumthy/millerrabin.pdf.","link":"/SICP/assets/miller-rabin/"}],"tags":[{"name":"Offline Query","slug":"offline-query","link":"/tags/offline-query/"},{"name":"Sparse Table","slug":"sparse-table","link":"/tags/sparse-table/"},{"name":"Brute Force","slug":"brute-force","link":"/tags/brute-force/"},{"name":"Depth-first Searching","slug":"depth-first-searching","link":"/tags/depth-first-searching/"},{"name":"Dynamic Programming","slug":"dynamic-programming","link":"/tags/dynamic-programming/"},{"name":"Graph Theory","slug":"graph-theory","link":"/tags/graph-theory/"},{"name":"Segment Tree","slug":"segment-tree","link":"/tags/segment-tree/"},{"name":"Monotonic Queue","slug":"monotonic-queue","link":"/tags/monotonic-queue/"},{"name":"Linear Algebra","slug":"linear-algebra","link":"/tags/linear-algebra/"},{"name":"Number Theory","slug":"number-theory","link":"/tags/number-theory/"}],"categories":[{"name":"Algorithm Contest","slug":"algorithm-contest","link":"/categories/algorithm-contest/"},{"name":"Segment Tree","slug":"algorithm-contest/segment-tree","link":"/categories/algorithm-contest/segment-tree/"},{"name":"Mathematics","slug":"mathematics","link":"/categories/mathematics/"}]}