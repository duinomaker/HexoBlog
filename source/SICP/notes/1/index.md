---
title: 第一章 构造抽象过程
canonical_url: https://duinomaker.top/SICP/notes/1/
widgets:
comment:
---

---

## 1.1 程序设计的基本元素

<div class="foreword">
为了让我们能通过程序语言组织自己有关计算过程的思想，每一种强有力的语言都提供了三种机制，使我们能够将简单的认识组合起来形成更复杂的认识：

- **基本表达式**，指语言中最基本的实体
- **组合的方法**，通过它们可以用简单元素构成复合元素
- **抽象的方法**，通过它们可以给复合元素命名，并将其视为单元操作
</div>

---

**组合式求值**有以下步骤：

1. 对组合式的各个子表达式求值
2. 将运算符的值应用于其它子表达式的值

对子表达式求值时也必须遵循这样的步骤，这意味着求值步骤本身就是递归的。

`define` 是我们给值**命名**的方式，也是最简单的抽象方式，形如 `(define x 3)` 。这样做会导致名字 `x` 与值 `3` 相关联。将名字与值相关联，又能根据名字提取出值，解释器需要存储空间来维护名字-值关联，这存储空间被称为**环境**。

**过程定义**形如 `(define (<name> <formal parameters>) <body>)`，将用对应的实际参数替换形式参数，再求值的这一过程，在环境中绑定给一个名字，便于以后的调用。

**应用序求值与正则序求值**是表达式求值的两种方式。应用序求值时，解释器首先对运算符和各个对象求值，之后将得到的过程应用于得到的实际参数。而正则序求值时，先不求出运算对象的值，直到需要它们时再去求。

- 应用序，概括为 “先求值而后应用”
- 正则序，概括为 “完全展开后规约”

{% blockquote %}
Lisp 采用应用序求值，部分原因在于这样做能避免对于表达式的重复求值，从而可以提高一些效率。更重要的是，在超出了可以采用代换方式模拟的过程范围后，正则序的处理将变得复杂得多。
{% endblockquote %}

**条件表达式和谓词**，形如：

    (cond (<p1> <e1>)
          (<p2> <e2>)
          ...
          (<pn> <en>))

    (if <predicate> <consequent> <alternative>)

`cond` 之后跟随着形如 `(<p> <e>)` 的表达式，称为从句。从句中的 `<p>` 是谓词，与结果表达式 `<e>` 相对应。整个 `cond` 表达式的值是从左到右第一个谓词为真的从句的结果表达式，其中 `else` 是一个永远为真的谓词。

要对一个 `if` 表达式求值，首先对 `<predicate>` 求值。如果其为真，求出 `<consequent>` 的值，否则求出 `<alternative>` 的值作为整个 `if` 表达式的值。

由于 `cond` 和 `if` 不一定对其所有子表达式求值，它们不是一般的过程，而是**特殊形式**。

形式参数叫什么名字，其实无所谓，这样的名字称为**约束变量**。如果一个变量不是被约束的，我们就称它为自由的。名字在其中被约束的表达式的集合称为名字的**作用域**。约束变量在将其作为形式参数的过程中的作用域是这个过程的过程体。

**词法作用域**是作用域的一种工作模型。内层过程中的自由变量，实际上是外围过程定义中的约束变量。

嵌套定义的过程，称为**块结构**。块结构的好处是，可以省去将某些变量在内层过程中传递的过程。